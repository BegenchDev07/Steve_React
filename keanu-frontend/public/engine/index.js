function match(regex, str) {
    let m, result = [];
    while ((m = regex.exec(str)) !== null) {
        // This is necessary to avoid infinite loops with zero-width matches
        if (m.index === regex.lastIndex) {
            regex.lastIndex++;
        }

        // The result can be accessed through the `m`-variable.
        m.forEach((match, groupIndex) => {
            // console.log(`Found match, group ${groupIndex}: ${match}`);
            result.push(match);
        });
    }
    return result;
}
//TODO: new URL
//https://developer.mozilla.org/en-US/docs/Web/API/URL
//https://stackoverflow.com/questions/27745/getting-parts-of-a-url-regex
function parseURL(url = '/test/test.jpg') {


    let regex = /^((http[s]?|ftp):\/)?\/?([^:\/\s]+)(:(\d+))?((\/\w+)*\/)([\w\-\.]+[^#?\s]+)(.*)?(#[\w\-]+)?$/gm;

    let info = match(regex, url);
    let baseURL = {};
    baseURL['protocol'] = info[2];
    baseURL['host'] = info[3];
    baseURL['port'] = info[5];
    baseURL['path'] = info[6];
    baseURL['file'] = info[8];
    baseURL['params'] = {};

    regex = /(\?|\&)([^=]+)\=([^&]+)/gm;
    info = match(regex, url);

    for (let i = 2; i < info.length; i += 2)
        baseURL['params'][info[i]] = info[i + 1];
    return baseURL;


}

// 0 : No button or un-initialized
// 1 : Primary button (usually the left button)
// 2 : Secondary button (usually the right button)
// 4 : Auxilary button (usually the mouse wheel button or middle button)
// 8 : 4th button (typically the "Browser Back" button)
// 16 : 5th button (typically the "Browser Forward" button)

const MOUSE_BUTTONS = {nothing:0,leftBtn:1,rightBtn:2,midBtn:4,backwardBtn:8,forwardBtn:16};


// STATUS = {
//     visible:1,
//     selected:2,
//     dynamic:4,
//     sleep:8
// },

const SHAPE_TYPE$1 = {none:0,edge:1,sphere:4,box:16, poly:16};
const JOINT_STATUS$1 = {active:1,inactive:2,invisible:4,visible:8};


const ManifoldType$2 = {e_circles:'e_circles',e_face:'e_face'};

const CONTROLLER_MODE = {async:1,recording:2,emulating:4};//prepared:2048



const ENGINE_SETTING = {performance:5330,powerSaver: 5030};
const ENGINE_STATUS = {init:1, start:2, stop:4, pause:8, stepover:16};

const CONTACT_STATUS$1 ={init:0,escape:1,touching:2, renew:4};


const CONTACT_EVT$2 = {NewCollisionEvt:'NewCollisionEvt',DeleteCollisionEvt:'DeleteCollisionEvt'};





const AABBEXTENSION$1 = 0.1, AABBMULTIPLIER$1 = 4,
    LINEAR_SLOP$1 = 0.005, POLYGON_RADIUS$1 = 2*LINEAR_SLOP$1;


let TARGET_UPDATE_FPS = 0,
    TARGET_DRAW_FPS = 0,
    TARGET_DRAW_INTERVAL = 0,
    TARGET_UPDATE_INTERVAL = 0;

const   b2_epsilon$1 = 0.001,
    b2_velocityThreshold$1 = 1.0,
    b2_maxLinearCorrection$1 = 0.2,
    b2_maxFloat$1	 = 100000.00;

const   b2_maxManifoldPoints$1 = 2;

const BASIC_STATUS = {
    error:1,
    creating:2,
    loading:4,
    rendering:8,
    deleting:16,
    deleted:32,
    visible:64,
    clippingBoundary:128,
    clippingWindow:256,
    focus:512,
    animation:1024,//1024
    updating:Math.pow(2,11),
},CTRL_STATUS = {
    //Controller
    active:Math.pow(2,12),
    click:Math.pow(2,13),
    mouse:Math.pow(2,14),
    drag:Math.pow(2,15),
    wheel:Math.pow(2,16),
},UI_STATUS={
    layoutable:Math.pow(2,17),
    expand:Math.pow(2,18),

};
const TYPE = {
    graphic:1,
    buffer:2,
    ui:4,
    music:8,
    script:16,
    animation:32,
};
const TARGET_WINs ={
    'global':  1+2+4+8+16+32+64,
    'uiCanvas':1+2+4,

    //////////////////////////////
    'Palette': 1,
    'Scene': 2,
    'Brush': 4,
    'Outline': 8,
    'History':16,
    'Inspector':32,
    'Animation':64,
};

const LAYOUT_MODE$1 ={
    create:1, //drawClipping:2,
    update:2,
    folding:4,
    left:8, center:16, right:32,top:64,middle:128,bottom:256,
    ANCHOR_VERTICAL_MASK:64+128+256,
    ANCHOR_HORIZONTAL_MASK:8+16+32,
    ANCHOR_MASK:8+16+32+64+128+256,
    vertical:512, horizontal:1024,

    ignoreTranslate:2048,
    resizeX:4096,
    resizeY:Math.pow(2,13),//8192

    expandX:Math.pow(2,15),
    expandY:Math.pow(2,16),

    lockRatio:Math.pow(2,14),




};
// const TILEBr = {
//     sliceable:1,
// }
const TOOL_MODE={
    interactionEnd:1,
    interactionStart:2,
    import:4,

    add:8,
    subtract:16,
    select:32,

    camTumble:64,
    camZoom:128,
    paint:256,
    cut:512,
    copy:1024,

    all:1+2+8+16+32+64+128+256+512+1024,
};

const CANVAS_MODE ={



    regular:1024,
    isometric:2048,
    hexagon:4096,
    animation:4096*2,

    gridModes:1024+2048+4096+4096*2,
};

const EVT_TYPES = {
    INTERNAL_PREFIX:'@',


    onConnect:'@onConnect',
    onRecord:'record',
    onClear:'@clear',
    onCreate:"onCreate",
    onInitialized:"onInitialized",
    onHistoryStackAdd:"@onHistoryStackAdd",
    onRecallingStart:"@onRecallingStart",
    onRecallingEnd:"@onRecallingEnd",
    onUIAction:"@onUIAction",
    onError:'@onError',
    onErrorFixed:'@onErrorFixed',
    onProcess:'@onProcess',
    onCheckGUI:'@onCheckGUI',
    onPopupMenu:'@onPopupMenu',
    onHierarchyFullNameChange:'@onHierarchyFullNameChange',
    onControllerAttached:'@onControllerAttached',
    onControllerDetached:'@onControllerDetached',
    onPaletteSelectionChange:'@onPaletteSelectionChange',
    onPaletteRenderChange:'@onPaletteRenderChange',


    undo:'undo',
    redo:'redo',
    lock:'lock',
    unlock:'unlock',

    // createFileTEST:"createFile_LOCAL_TEST",
    createFile:"create",
    deleteFile:'delete',
    renameFile:'rename',

    setAttr:"setAttr",
    updateAttr:"updateAttr",
    delAttr:"delAttr",
    paint:'paint',
    import:'import',
    translate:'translate',
    rotate:'rotate',
    scale:'scale',

    openFile:'%open',
    toggleFolder:'%folder',
    select:'%select',
    focus:'%focus',


},CMDs = {
    'undo':EVT_TYPES.undo,
    'redo':'@'+EVT_TYPES.redo,
    'lock':EVT_TYPES.lock,
    'unlock':EVT_TYPES.unlock,

    // 'addSelection':'addSelection',
    // 'removeSelection':'removeSelection',

    'paint':'paint',
    'select':'select',
    'cut':'cut',
    'translate':'translate',

    'camTumble':'camTumble',
    'camZoom':'camZoom',
},KEYS_INTERACTION_TYPE = {
    // 'mouse':1,
    'interaction':2,
    'immediate':4
},KEYS = {
    SYS_KEYS:[{
        cmd:CMDs.undo,
        keys:['Meta','!Shift','z'],
        type:KEYS_INTERACTION_TYPE.immediate,
        target:TARGET_WINs.global,
    }, {
        cmd:CMDs.redo,
        keys:['Meta','Shift','z'],
        type:KEYS_INTERACTION_TYPE.immediate,
        target:TARGET_WINs.global,
    }, {
        cmd:CMDs.lock,
        keys:['Meta','!Shift','l'],
        type:KEYS_INTERACTION_TYPE.immediate,
        target:TARGET_WINs.global,
    }, {
        cmd:CMDs.unlock,
        keys:['Meta','Shift','l'],
        type:KEYS_INTERACTION_TYPE.immediate,
        target:TARGET_WINs.global,
    }, ],
    ///////////////////////////////////////////////////////////
    ///////////////////////////////////////////////////////////
    ///////////////////////////////////////////////////////////
    APP_KEYS : [
    {
        cmd:CMDs.camZoom,
        keys:['Meta'],
        type:KEYS_INTERACTION_TYPE.interaction,
        target:TARGET_WINs.uiCanvas
    },{
        cmd:CMDs.camTumble,
        keys:[' '],//space
        type:KEYS_INTERACTION_TYPE.interaction,
        target:TARGET_WINs.uiCanvas
    },

    ///////////////////////////////////////////////////////////
    {
        cmd:CMDs.paint,
        keys:['b'],
        type:KEYS_INTERACTION_TYPE.interaction,
        target:TARGET_WINs.Palette
    }, {
        cmd:CMDs.cut,
        keys:['c'],
        type:KEYS_INTERACTION_TYPE.interaction,
        target:TARGET_WINs.Brush
    },{
        cmd:CMDs.select,
        keys:['q'],
        type:KEYS_INTERACTION_TYPE.interaction,
        target:TARGET_WINs.uiCanvas
    },{
        cmd:CMDs.translate,
        keys:['w'],
        type:   KEYS_INTERACTION_TYPE.interaction,
        target:TARGET_WINs.uiCanvas
    },





    ],
};


const EVT_KEYS = [

    'menu',
    'drop',

    "press",
    "move",
    "release",
    'click',
    'dblclick',

    'over',
    'out',
    'enter',
    'leave',

    'dragstart',
    'drag',
    'dragend',

    'scroll', //wheel
    'gesture', //gesture
];

const FILTER_BITs = {};

for(let i=0;i<EVT_KEYS.length;i++)
    FILTER_BITs[EVT_KEYS[i]] = 1<<i;
console.log(FILTER_BITs);

// FILTER_BITs['click'] = FILTER_BITs["release"];
// FILTER_BITs['dblclick'] = FILTER_BITs["release"];
//
// FILTER_BITs["over"] = FILTER_BITs["move"];
// FILTER_BITs["out"] = FILTER_BITs["move"];
//
// FILTER_BITs['enter'] = FILTER_BITs["move"];
// FILTER_BITs['leave'] = FILTER_BITs["move"];
// //
// //
// FILTER_BITs['dragstart'] = FILTER_BITs["press"];
// FILTER_BITs['drag'] = FILTER_BITs["move"];
// FILTER_BITs['dragend'] = FILTER_BITs["release"];


const SYS_FLAG = {Desktop:1,Mobile:2,IOS:4,OSX:8,Windows:16,Linux:32,Android:64, Intel:128};

const system = {
    SYS_FLAG,
    SYS_INFO: {
        'Macintosh; Intel Mac OS X':SYS_FLAG.OSX|SYS_FLAG.Desktop|SYS_FLAG.Intel,
        'Windows NT':SYS_FLAG.Windows|SYS_FLAG.Desktop,
        'Android':SYS_FLAG.Linux|SYS_FLAG.Android|SYS_FLAG.Mobile,
        'CPU iPhone OS':SYS_FLAG.IOS|SYS_FLAG.Mobile,
        'CPU OS':SYS_FLAG.IOS|SYS_FLAG.Mobile
    },
    BROWSER_FLAG:{
        wechatdevtools:1,
        Chrome:2,
        Safari:4,
        Firefox:8,
        MQQBrowser:16,
        MicroMessenger:32,
        MiuiBrowser:64,
        QQBrowser:128,
        Edg:256
    }
};
if(typeof window != 'undefined'){
    const isIPAD = parseURL(window.location.href).params.ipad??false;
    if(isIPAD)
    system.SYS_INFO['Macintosh; Intel Mac OS X'] = SYS_FLAG.OSX|SYS_FLAG.Mobile|SYS_FLAG.Intel;
}

const setting$4 = {

    CLICK_DELAY:300,
    CONTROL_FILTER_BITs:FILTER_BITs,

    FOCUS_CHECKER_TIMEOUT:10000,
    SYNC_TIME_THRESHOLD:1000,
    MAX_CANVAS_SIZE:32767,

    PROJ_TYPES:{
        private:'private', public:'public'
    },
    KEYS_INTERACTION_TYPE:KEYS_INTERACTION_TYPE,
    KEYS:{
        ...KEYS,
        ALL_KEYS:[...KEYS.SYS_KEYS, ...KEYS.APP_KEYS]
    },
    EVT_TYPES,

    LAYOUT_MODE: LAYOUT_MODE$1,
    CANVAS_MODE,
    TOOL_MODE,
    TARGET_WINs:TARGET_WINs,

    TYPE:TYPE,

    BASIC_STATUS:BASIC_STATUS,
    CTRL_STATUS:CTRL_STATUS,
    UI_STATUS:UI_STATUS,
    STATUS:{...BASIC_STATUS,...CTRL_STATUS, ...UI_STATUS},
    // STATUS:STATUS,
    SHAPE_TYPE:SHAPE_TYPE$1,
    JOINT_STATUS:JOINT_STATUS$1,
    ManifoldType:ManifoldType$2,


    CONTROLLER_MODE:CONTROLLER_MODE,
    MOUSE_BUTTONS:MOUSE_BUTTONS,
    TEST_SWITCH_XYINPUT:false,


    ENGINE_SETTING:ENGINE_SETTING,
    ENGINE_STATUS:ENGINE_STATUS,

    CONTACT_STATUS:CONTACT_STATUS$1,
    CONTACT_EVT:CONTACT_EVT$2,



    TARGET_UPDATE_FPS:TARGET_UPDATE_FPS,
    TARGET_UPDATE_INTERVAL:TARGET_UPDATE_INTERVAL,
    TARGET_DRAW_FPS:TARGET_DRAW_FPS,
    TARGET_DRAW_INTERVAL:TARGET_DRAW_INTERVAL,


    AABBEXTENSION:AABBEXTENSION$1,
    AABBMULTIPLIER:AABBMULTIPLIER$1,
    POLYGON_RADIUS:POLYGON_RADIUS$1,
    LINEAR_SLOP:LINEAR_SLOP$1,

    b2_epsilon:b2_epsilon$1,
    b2_velocityThreshold:b2_velocityThreshold$1,
    b2_maxLinearCorrection:b2_maxLinearCorrection$1,
    b2_maxFloat:b2_maxFloat$1,
    b2_maxManifoldPoints:b2_maxManifoldPoints$1


};
const ENGINE_EVT = {START:'START',ADD:'ADD',DEL:'DEL',MODIFY:'MODIFY',CLEAR:'CLEAR'};

const event = {
    ENGINE_EVT:ENGINE_EVT
};

const simulation = {JOINT_VEL_ITERATION:4,POS_ITERATION:4,VEL_ITERATION:4};


const error = {
    ERR_TYPE:{
        internalErr:    1,
        nameConflict:   2,
        illegalPath:    4,
        guiErr:8,
        paramsErr:16,
        unimplementInterface: 128,



        serverErr:1024,
        cosErr: 1024*2,
        illegalURL404:1024*4,
    }
},cmd = {
    ui:{
        createWindow: function(
            root,
            windowClass, windowName, {
            position=[100,100,0],
            titleHeight=20,
            titleColor = 'red',
            strokeColor = 'rgba(0,0,0,0)',
            lineWidth = 0,
            style={width:'400px',height:'420px'}
        },initCallback){
            return new Promise(async resolve=>{
                let win;
                try{
                    win = new windowClass(windowName,{
                        position,
                        titleHeight,
                        titleColor,
                        strokeColor,
                        lineWidth,
                        style
                    });
                    if(initCallback)
                        win.initCallback = initCallback;

                    root.appendChild(win);

                    win.Event.onUnicon(setting$4.EVT_TYPES.onCreate,
                        async function(evt){
                            const win = evt.publisher;
                            await win.onCreate();
                        });

                    console.log(`${windowName} is createWindow`);
                    win.Event.on(setting$4.EVT_TYPES.onInitialized,async (evt, editorName,)=>{
                        console.log('asdfasdfasdfasdf');
                        await win.beforeRefresh();
                        win.refresh();
                        if(win.initCallback){
                            win.onActive();
                            await win.initCallback(win,evt,editorName);
                        }
                        return resolve(win);
                    },{subscriber:win});
                }catch (err){
                    debugger;
                }
            })

        }
    }
};


function INTERNAL(input){
    if(Array.isArray(input))
        return JSON.parse(JSON.stringify(input)).map(ele=>{ele.type = `@${ele.type}`; return ele});
    else
        return `${setting$4.EVT_TYPES.INTERNAL_PREFIX}${input}`;
}

var common$1 = {system,setting: setting$4, error,cmd,event,simulation};

// import {$assert} from "./commonHelper.js";
function $assert$2(condition, info = {
    errorType: 1, //internel err
    msg: `assertion failed`,
    path: null
}) {
    if (!condition) {
        debugger;
        let {msg, errorType, path} = info;

        msg = msg || info;
        if (msg)
            console.error(msg);
        throw new Error(msg);
    }
}
class IEvtHandler{
    setAttr(){};
    delAttr(){};
    import(){};

    paint(){};

    renameFile(){};
    createFile(){};
    deleteFile(){};
    process(){};
    check(){};

}

class ISerializable{
    static serialize(json){
        // return serializer.bson.serialize(json);
    };
    static deserialize(bson){
        // return serializer.bson.deserialize(bson);
    };


    // static downloadBlob(uint8, fileName, mimeType='application/octet-stream') {
    //     let blob = new Blob([uint8], {type: mimeType}),
    //         url = window.URL.createObjectURL(blob);
    //     downloadURL(url, fileName);
    //     setTimeout(function() {
    //         return window.URL.revokeObjectURL(url);
    //     }, 1000);
    // };
}


class ITransform2D{
    get Pivot(){};
    set Pivot(value){};

    set Position(value){};
    get Position(){};
    get GlobalPosition(){};

    set Rotation(val){};
    get Rotation(){};

    set Scale(value){};
    get Scale(){};

    get Matrix(){};
    get LocalMatrix(){};


    update(){};
}



// export class ITransform2D{
//     name = null;
//     #globalPosition = null;
//     #updateCallback = null;
//
//
//     position = null;
//     scale = null;
//     rotation = null;
//     q = {sin:0,cos:0};
//     pivot = null;
//     localMatrix = null;
//     globalMatrix = null;
//     set(value, newValue){};
//     clone(transform){}
//     get Matrix(){};
//     set Position(value){};
//     get Position(){}
//     get GlobalPosition(){}
//
//
//
//     set Scale(val){}
//     get Scale(){}
//
//     set Rotation(val){}
//     get Rotation(){}
//     set Pivot(value){};
//
//     get Pivot(){}
//
//     move(value){}
//
//
//
//     update(){};
//     static multiply(out, a, b, mode = 'boundary'){};
//     static multiplyInv(out, a, b){};
// }


class IHierachy {

    get Parent(){};
    set Parent(val){};
    get Children(){};

    get FullName(){}
}

class IData{
    get Path(){return null;}
    set Path(value){}
}

class ICamera{

    // set TargetWidth(val){};
    // set TargetHeight(val){};
    set Width(val){};
    set Height(val){};

    get Matrix(){};
    get ViewMatrix(){};
    get ProjectionMatrix(){};
}
class IToolAction{


    onUIActionStart(cmd){

    }

    onUIActionEnd(cmd){

    }
}
class IUICanvas{

    static MODE = common$1.setting.CANVAS_MODE;

    get Mode(){}
    set Mode(val){}

    get Canvas(){};
}
class IDrawable {


    get Alpha(){return 1};
    initialize(){};

    get Padding(){return {left:0,top:0,right:0,bottom:0}}

    get Margin(){return {left:0,right:0,top:0,bottom:0}};
    get RenderIndex(){return this.renderIndex;};
    set RenderIndex(val){this.renderIndex = val;};

    get DrawHandler(){return this.drawHandler;}


    draw(ctx,cam){};
    getClipPath(boundary){
        const region = new Path2D();
        region.rect(boundary[0], boundary[1], boundary[2], boundary[3]);
        return region;
    }
    //TODO: setTransform would be faster
    preDraw(ctx) {//https://stackoverflow.com/questions/38069462/html5-canvas-save-and-restore-performance/38079796
        ctx.save();
        ctx.globalAlpha = this.Alpha;
        $assert$2(this.transform);
        const   transMat = this.transform.Matrix;
        //         cam = this.Camera;
        // if(cam){
        //     math.mat2d.multiply(tmpMat, transMat,cam.Matrix);
        //     ctx.setTransform(tmpMat[0], tmpMat[1], tmpMat[2], tmpMat[3], tmpMat[4], tmpMat[5]);
        // }else
        ctx.setTransform(transMat[0], transMat[1], transMat[2], transMat[3], transMat[4], transMat[5]);



        const RIGHT = this.Width + this.Margin.left + this.Margin.right,
            BOTTOM = this.Height + this.Margin.top + this.Margin.bottom;

        ctx.fillStyle = this.marginColor;
        if(this.Margin.top)
            ctx.fillRect(-this.Margin.left, -this.Margin.top, RIGHT, this.Margin.top);

        if(this.Margin.right)
            ctx.fillRect(this.Width, -this.Margin.top, this.Margin.right,BOTTOM);

        if(this.Margin.bottom)
            ctx.fillRect(-this.Margin.left, this.Height, RIGHT, this.Margin.bottom);


        if(this.Margin.left)
            ctx.fillRect(-this.Margin.left, -this.Margin.top, this.Margin.left,BOTTOM);

        if(this.name === '_entry7-error')
            console.log();
        if(this.name === '_entry7')
            console.log();

        if((this.Status & common$1.setting.BASIC_STATUS.clippingBoundary)||
            (this.Status & common$1.setting.BASIC_STATUS.clippingWindow)
        ){
            $assert$2(this.boundary);
            ctx.beginPath();
            const boundary = this.boundary.slice();
            boundary[0] += this.Padding.left;
            boundary[1] += this.Padding.top;
            boundary[2] -= this.Padding.left + this.Padding.right;
            boundary[3] -= this.Padding.top + this.Padding.bottom;
            ctx.clip(this.getClipPath(boundary));
        }
    };

    postDraw(ctx) {
        ctx.restore();

    };
}

// export const IContainer = Base => class extends Base {
class IContainer {
    static STATUS = common$1.setting.STATUS;
    get Name (){};
    set Status(value){};
    get Status(){};

    set Style(value){}


    connectedCallback() {}


    init(){}
    registEvt(){}
    initListeners(){}

    handleResize(entry){}
    resize(size){}



    onCreate(){}
    // onClear(){}

}



// export class ISideDock{
//     static STATUS = common.setting.UI_STATUS;
//
//     set Status(value){};
//     get Status(){};
//
//     get Layouts(){};
// }


class IPanelContainer{
    get Renderables(){};
}


class IWindow {
    static Windows = [];

    get Width(){}
    get Height(){}

    get CanvasDiv(){}
    get Controller(){}
    static STATUS = common$1.setting.BASIC_STATUS;

    get Title(){}
    get Content (){}
    get Body(){}
    get RootLayout(){}


    moveWindow(evt){}
    get BeforeRefreshHandlers(){}
    async beforeRefresh(){}
    refresh(){

    }

    drawUI(){};



    clear(){}

}

class IUIScrollable {


    get VerticalSlider(){}
    get HorizontalSlider(){}

}



class ITexture{
    get Image(){};
    get Size(){};
    onload(){};
    update(){};
}





class IElement{
    static STATUS = common$1.setting.BASIC_STATUS;
    get Width(){};
    get Height(){};
    set Width(val){};
    set Height(val){};
    get Status(){};
    set Status(val){};
}

class IImage{
    static MODE = {
        image:1,
        animation:2,
        tileAnimation:4,
        colorFilterAnimation:8,
        background:16
    };
    get Mode(){};
    set Mode(val){};
}

// export const IControllable  = Base => class extends Base {
class IControllable {
    static STATUS = common$1.setting.CTRL_STATUS;
    get Boundary(){}
    get Filters(){};
    get EvtPool(){};
    appendChild(){};
    insertChild(){};
    removeChild(){};
    addEventListener(){};
    removeEventListener(){};
}
class IDraggable{

}


// export const ISelectable  = Base => class extends Base {
class ISelectable {
    get IsSelected(){};
    set IsSelected(value){};

    get SelectedColor(){};
    set SelectedColor(value){};
}
const ConnectionType = {inputs:'inputs',outputs:'outputs'};
// export const IConnection  = Base => class extends Base {
class IConnection {

    static linkHierachy(parent, child, onCheckName){
        let children = parent.getConnection(ConnectionType.outputs,'children');
        $assert$2(children&&child&& !(child & common$1.setting.BASIC_STATUS.deleting));
        if(onCheckName)
            onCheckName(parent,child);
        children.push(child);
        child.setConnection(ConnectionType.inputs,'parent',parent);
    }
    static clearHierachy(child){
        const parent = child.getConnection(ConnectionType.inputs,'parent');
        child.deleteConnection(ConnectionType.inputs, 'parent');
        parent.deleteConnection(ConnectionType.outputs, 'children', child);
    }
    deleteConnection(connType,propertyName, value){
        if(connType == ConnectionType.inputs)
            propertyName = '=>' + propertyName;

        else if(connType == ConnectionType.outputs)
            propertyName =  propertyName + '=>';


        if(this[connType][propertyName] instanceof  Array){
            if(typeof value == 'undefined')
                this[connType][propertyName] = [];
            else
                this[connType][propertyName] = this[connType][propertyName].filter(ele=>ele!=value);
        }else  if(this[connType][propertyName] instanceof  Object)
            this[connType][propertyName] = null;

    }



    setConnection(connType,propertyName, value){
        if(connType == ConnectionType.inputs)
            propertyName = '=>' + propertyName;

        else if(connType == ConnectionType.outputs)
            propertyName =  propertyName + '=>';
        else
            $assert$2(false);

        $assert$2(this[connType]);

        if(typeof this[connType][propertyName] === 'undefined')
            throw new Error(propertyName+'is not initialized');

        this[connType][propertyName] = value;
    }
    getConnection(connType,propertyName){
        if(connType == 'inputs')
            propertyName = '=>' + propertyName;

        else if(connType == 'outputs')
            propertyName =  propertyName + '=>';
        else
            $assert$2(false);

        $assert$2(this[connType]);
        // if(typeof this[connType][propertyName] === 'undefined')
        //     throw new Error(propertyName+'is not initialized');
        return this[connType][propertyName]?this[connType][propertyName]:null;
    }


    initDataType(type){
        return type == 'object'?null:[];
    }


    initConnection(conn){
        this.inputs = {};
        this.outputs = {};


        if(conn.inputs)
            for(let key in conn.inputs) {
                const property = conn.inputs[key];
                this.inputs[key] = this.initDataType(property.type);
            }

        if(conn.outputs)
            for(let key in conn.outputs) {
                const property = conn.outputs[key];
                this.outputs[key] = this.initDataType(property.type);
            }
    }

    clearConnection(){

        const parent = this.getConnection(ConnectionType.inputs,'parent');
        this.deleteConnection(ConnectionType.inputs, 'parent');
        if(parent)
            parent.deleteConnection(ConnectionType.outputs, 'children', this);

        const children = this.getConnection(ConnectionType.outputs, 'children', this);
        if(children)
            for(const child of children)
                child.deleteConnection(ConnectionType.inputs, 'parent');

        // for(const [key, input] of Object.entries(this.inputs)){
        //
        // }

        this.inputs = {};
        this.outputs = {};
    }
}

class ILoad{
    static async  onLoad(){
    }

    onFinishLoad(res){}
}


// export const ILayoutComponent  = Base => class extends Base {
class ILayoutComponent {

    static LAYOUT_MODE = common$1.setting.LAYOUT_MODE;


    get Margin(){return {left:0,right:0,top:0,bottom:0}};

    get LayoutMode(){}
    set LayoutMode(val){}

    // get PreferredSize(){return null;}
    get Ratio(){return 1.3333;}
    set Ratio(value){$assert$2(value);}

    get UIPosition(){$assert$2(this.transform);return this.transform.Position;}
    set UIPosition(value){$assert$2(this.transform);this.transform.Position = value;}

    // set MaxSize(val){};
    // set MinSize(val){};
    //
    // get MaxSize(){return [64,64];};
    // get MinSize(){return [32,32];};



    resize(size){};
}

// export const ILayout  = Base => class extends Base {
class ILayout {
    static LAYOUT_MODE = common$1.setting.LAYOUT_MODE;



    static set CurLayout(val){}
    static get CurLayout(){}

    static beginInit(newEditor){}
    static endInit(){}
    static begin(){}
    static end(){}

    get LayoutMode(){}
    set LayoutMode(val){}

    // get RefreshDoneHandlers(){}


    get Renderables(){};


    get ContentLayout(){return this;}

    get Margin(){return {left:10,right:10,top:10,bottom:10}};


    resize(size){};
    refresh(){};
}

const
    cameraConnection = {
        inputs:{'=>transform':{type:'transform'}},
        outputs:{'localMatrix=>':{type:'matrix'}},
    },
    transformConnection = {
        inputs:{
            '=>object':{type:'object'},
            '=>localMatrix':{type:'matrix'},
        },
        outputs:{
            "globalMatrix=>":{type:'matrix'},
            "localMatrix=>":{type:'matrix'},
        }
    },
    hierarchyConnection = {
        inputs:{
            '=>parent':{type:'object'},
        },
        outputs:{
            'children=>':{type:'array'}
        }
    };

const DEFAULT_RETRY_DELAY = 50;

const __locker_waitList = {};
const $check = (condition,onSuccess,retryDelay= DEFAULT_RETRY_DELAY)=> new Promise(resolve=>{
    if(condition()){
        onSuccess();
        return resolve();
    }else
        setTimeout(async _=>await $check(condition, onSuccess, retryDelay),retryDelay);
});




function acquireLockByQueue(lockName){
    __locker_waitList[lockName][0]();
}
function releaseLockByQueue(lockName){
    __locker_waitList[lockName].shift();

    if(__locker_waitList[lockName].length === 0)
        delete __locker_waitList[lockName];
    else
        acquireLockByQueue(lockName);
}


function lock$1 (lockName) {
    return new Promise(resolve => {
        if(__locker_waitList[lockName] == undefined)
            __locker_waitList[lockName] = [];
        if (!lockName)
            throw new Error("You must specify a lock string. It is on the redis key `lock.[string]` that the lock is acquired.");

        const release = _=>{
            if(__locker_waitList[lockName] === undefined)
                throw new Error("Cannot release twice");

            releaseLockByQueue(lockName);
        };

        __locker_waitList[lockName].push(_=>  resolve(release));
        acquireLockByQueue(lockName);
    });
}

const cancel = (lockName)=> new Promise(async resolve=>

    $check(_=>__locker_waitList[lockName] === undefined || __locker_waitList[lockName].length === 0,
        _=> {
            delete __locker_waitList[lockName];
            return resolve();
        })
);

const checkValid = (lockName)=> __locker_waitList[lockName] === undefined || __locker_waitList[lockName].length === 0;

function $imgCrop(image, srcX, srcY, srcWidth, srcHeight, dstWidth = srcWidth,dstHeight= srcHeight){
    $assert($isNumber$1(srcX)&&$isNumber$1(srcY)&&$isNumber$1(srcWidth)&&$isNumber$1(srcHeight));
    return new Promise(res=>{
        const backupCanvas = document.createElement('canvas');
        backupCanvas.width = dstWidth;
        backupCanvas.height = dstHeight;
        const ctx = backupCanvas.getContext('2d');

        ctx.imageSmoothingEnabled = false;
        ctx.drawImage(image,srcX, srcY, srcWidth, srcHeight, 0, 0, dstWidth,dstHeight);
        res(backupCanvas);})
    // .then(base64ToImg);;
}
function $imgCropBlend(canvas,image, srcX, srcY, srcWidth, srcHeight,dX=srcX,dY=srcY, dstWidth = srcWidth,dstHeight= srcHeight){
    $assert($isNumber$1(srcX)&&$isNumber$1(srcY)&&$isNumber$1(srcWidth)&&$isNumber$1(srcHeight));
    const ctx = canvas.getContext('2d');

    ctx.imageSmoothingEnabled = false;
    ctx.drawImage(image,srcX, srcY, srcWidth, srcHeight, dX, dY, dstWidth,dstHeight);
    return canvas;
}

const

    ROOT_LOCKER_EMIT = `$batchEmit.lock`,
    LOCKER_CHAR='!',
    READONLY_CHAR = '+',
    HIDDEN_CHAR = '.',
    TEMP_CHAR = '~',
    __TYPES =
        [
            'null','array','number','object',
            'string','path','stack',
            'function','emun','button',
            'autoTile','tile','palette','QR',   //====GUI


            'transform2d', 'transform3d'        //======scene
        ],
    DATA_TYPES = {
        QR:8388608,array:2048,autoTile:1048576,button:524288,emun:262144,function:131072,number:4096,object:8192,palette:4194304,path:32768,stack:65536,string:16384,tile:2097152,transform2d:16777216,transform3d:33554432,null:1024,
    };

    for(const i in __TYPES)
        DATA_TYPES[__TYPES[i]] = 1024*Math.pow(2,i);//BigInt();//1024 is FILE_TYPES offset

    let code = '';
    Object.entries(DATA_TYPES).forEach(([index,value])=>code+=`${index}:${value},`);

const


    FILE_TYPES = {
        projSetting:1,js:2, image:4,tileBrush:8,
        autoBrush:16,palette:32, model:256,
    };
FILE_TYPES.brush = FILE_TYPES.tileBrush + FILE_TYPES.autoBrush + FILE_TYPES.palette;
FILE_TYPES.importFiles = FILE_TYPES.js + FILE_TYPES.image;
FILE_TYPES.binary = FILE_TYPES.image;


const FileExt2Meta  = {
        'keanu':FILE_TYPES.projSetting,
        'js':FILE_TYPES.js,
        'jpg':FILE_TYPES.image,'jpeg':FILE_TYPES.image,'png':FILE_TYPES.image,
        'JPG':FILE_TYPES.image,'JPEG':FILE_TYPES.image,'PNG':FILE_TYPES.image,
        'gif':FILE_TYPES.image,
        'autoBrush':FILE_TYPES.autoBrush,
        'tileBrush':FILE_TYPES.tileBrush,
        'palette':FILE_TYPES.palette,
    },
    projData = {


        'record':{
            video:1,
            audio:1,
            codec:{
                value:3,
                options:[
                    'video/webm;codecs=h264,opus',
                    'video/webm;codecs=vp9,opus',
                    'video/webm;codecs=vp8,opus',
                    'video/mp4;codecs=h264,aac',
                ],
            },
            'initRecord':{
                text:'record tutorial',
                color:'orange',
                fnc:'initRecord'
            },

            'startRecord':{
                text:'record tutorial',
                color:'green',
                fnc:'startRecord'
            },

            'stopRecord':{
                text:'record tutorial',
                color:'grey',
                fnc:'stopRecord'
            },

            'replay':{
                text:'record tutorial',
                color:'green',
                fnc:'replay'
            },

        },
        // 'QR':{
        //     '.name':'generate QR Code',
        //     text:'genQR',
        //     canvas:null,
        // },

        '.dataTypes':{
            '.':DATA_TYPES.object,
            'replay':DATA_TYPES.object,
            'record':DATA_TYPES.object,
            '.assets':DATA_TYPES.object,
            'record|video':DATA_TYPES.number,
            'record|audio':DATA_TYPES.number,
            'record|initRecord':DATA_TYPES.button,
            'record|startRecord':DATA_TYPES.button,
            'record|stopRecord':DATA_TYPES.button,
            'record|replay':DATA_TYPES.button,
            'QR':DATA_TYPES.QR,

        },
        '.assets':{},
        '.files':{},
    },




    jsData = {
        '.name':'js:',
        // '.path':'',
        '.dataTypes':{

        },
        '+SDKVersion':'1.0',
        '+versionHash':'test',
    },imgData = {
        '.name':'image:',
        // '.path':'',
        '.refers':[],
        '.dataTypes':{
        },
        // '+width':256,
        // '+height':256,
    },tileBrushData = {
        '.name':'tileBrush:',
        // '.path':'',
        '.dataTypes':{
            '.':DATA_TYPES.tile,
            'cellSize':DATA_TYPES.number,
            'offset':DATA_TYPES.object|DATA_TYPES.number,
            'padding':DATA_TYPES.object|DATA_TYPES.number,
            'slices':DATA_TYPES.array,
            'source':DATA_TYPES.path|FILE_TYPES.image,
        },
        source:null,
        cellSize:'64',
        offset:['0','0'],
        padding:['0','0'],
        slices:[

            // {
            //     "name":"unnamed0",
            //     boundary:[0,0,4,2]
            // },{
            //     "name":"unnamed0",
            //     boundary:[0,0,4,2]
            // }

        ],
    },

    autoBrushData = {
        '.name':'autoBrush:',
        // '.path':'',
        '.dataTypes':{
            '.':DATA_TYPES.autoTile,
            'source':DATA_TYPES.path|FILE_TYPES.tileBrush
        },
        source:null,
        "autoTile":[
            // {
            //     ruleMatrix:[
            //         0,  1,  0,
            //         1,  -1,  1,
            //         0,  1,  0
            //     ]
            // },
        ]
    },
    paletteData={
        '.name':'palette:',
        // '.path':'',
        '.dataTypes':{
            '.':DATA_TYPES.palette,
            'cellSize':DATA_TYPES.number,
            'numOfGrids':DATA_TYPES.object|DATA_TYPES.number,
            'mode':DATA_TYPES.number,
            'sources':DATA_TYPES.object,
        },
        // regular:1024,
        // isometric:2048,
        // hexagon:4096,
        // animation:4096*2,
        mode:'2048',
        numOfGrids:['128','128'],
        cellSize:'64',

        sources:{},

        ".contents":{},


    },objData = {
        '.name':'object',
        // '.path':'',
        'stack':{
            Transform2D:{},
        }
        ,'.dataTypes':{
            'stack':DATA_TYPES.stack,
        },
    };

function genData(path){
    const
        [,fileNm,fileExt] = path.match(/(.+)\.([^.]*)$/)??[,null,null],
        type = FileExt2Meta[fileExt];
    let res;
    switch (type){
        case FILE_TYPES.autoBrush:
            res =  getDataTemplate(FILE_TYPES.autoBrush);
            break;
        case FILE_TYPES.tileBrush:
            res =  getDataTemplate(FILE_TYPES.tileBrush);
            break;
        case FILE_TYPES.palette:
            res =  getDataTemplate(FILE_TYPES.palette);
            break;
    }
    // res['.path'] = path;
    return res;
}

function getDataTemplate(type){
    if(type & FILE_TYPES.projSetting)
        return JSON.parse(JSON.stringify(projData));
    if(type & FILE_TYPES.js)
        return JSON.parse(JSON.stringify(jsData));
    if(type & FILE_TYPES.image)
        return JSON.parse(JSON.stringify(imgData));
    if(type & FILE_TYPES.autoBrush)
        return JSON.parse(JSON.stringify(autoBrushData));
    if(type & FILE_TYPES.tileBrush)
        return JSON.parse(JSON.stringify(tileBrushData));
    if(type & FILE_TYPES.palette)
        return JSON.parse(JSON.stringify(paletteData));
    // if(type & FILE_TYPES.scene)
    //     return JSON.parse(JSON.stringify(sceneData));
    if(type & FILE_TYPES.object)
        return JSON.parse(JSON.stringify(objData));


    console.error('type error');
    return null;
}

const SHAPE_TYPE = {none:0,edge:1,sphere:4,box:16, poly:16};
const JOINT_STATUS = {active:1,inactive:2,invisible:4,visible:8};


const ManifoldType$1 = {e_circles:'e_circles',e_face:'e_face'};

const CONTACT_STATUS ={init:0,escape:1,touching:2, renew:4};


const CONTACT_EVT$1 = {NewCollisionEvt:'NewCollisionEvt',DeleteCollisionEvt:'DeleteCollisionEvt'};



const SIM_STATUS = {awake:1,sleep:2,dynamic:4,static:8,passive:16};


const AABBEXTENSION = 0.1, AABBMULTIPLIER = 4,
    LINEAR_SLOP = 0.005, POLYGON_RADIUS = 2*LINEAR_SLOP;



const   b2_epsilon = 0.001,
    b2_velocityThreshold = 1.0,
    b2_maxLinearCorrection = 0.2,
    b2_maxFloat	 = 100000.00;

const   b2_maxManifoldPoints = 2;





const setting$3 = {

    SIM_STATUS,


    SHAPE_TYPE,
    JOINT_STATUS,
    ManifoldType: ManifoldType$1,




    CONTACT_STATUS,
    CONTACT_EVT: CONTACT_EVT$1,





    AABBEXTENSION,
    AABBMULTIPLIER,
    POLYGON_RADIUS,
    LINEAR_SLOP,

    b2_epsilon,
    b2_velocityThreshold,
    b2_maxLinearCorrection,
    b2_maxFloat,
    b2_maxManifoldPoints


};

var phyEngine = {setting: setting$3};

/**
 * Common utilities
 * @module glMatrix
 */

// Configuration Constants
const EPSILON = 0.000001;
let ARRAY_TYPE = (typeof Float32Array !== 'undefined') ? Float32Array : Array;

if (!Math.hypot) Math.hypot = function() {
  var y = 0, i = arguments.length;
  while (i--) y += arguments[i] * arguments[i];
  return Math.sqrt(y);
};

/**
 * 2x2 Matrix
 * @module mat2
 */

/**
 * Creates a new identity mat2
 *
 * @returns {mat2} a new 2x2 matrix
 */
function create$9() {
  let out = new ARRAY_TYPE(4);
  if(ARRAY_TYPE != Float32Array) {
    out[1] = 0;
    out[2] = 0;
  }
  out[0] = 1;
  out[3] = 1;
  return out;
}

/**
 * Create a new mat2 with the given values
 *
 * @param {Number} m00 Component in column 0, row 0 position (index 0)
 * @param {Number} m01 Component in column 0, row 1 position (index 1)
 * @param {Number} m10 Component in column 1, row 0 position (index 2)
 * @param {Number} m11 Component in column 1, row 1 position (index 3)
 * @returns {mat2} out A new 2x2 matrix
 */
function fromValues$1(m00, m01, m10, m11) {
  let out = new ARRAY_TYPE(4);
  out[0] = m00;
  out[1] = m01;
  out[2] = m10;
  out[3] = m11;
  return out;
}

/**
 * Inverts a mat2
 *
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the source matrix
 * @returns {mat2} out
 */
function invert$3(out, a) {
  let a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3];

  // Calculate the determinant
  let det = a0 * a3 - a2 * a1;

  if (!det) {
    return null;
  }
  det = 1.0 / det;

  out[0] =  a3 * det;
  out[1] = -a1 * det;
  out[2] = -a2 * det;
  out[3] =  a0 * det;

  return out;
}

/**
 * Multiplies two mat2's
 *
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the first operand
 * @param {mat2} b the second operand
 * @returns {mat2} out
 */
function multiply$4(out, a, b) {
  let a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3];
  let b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3];
  out[0] = a0 * b0 + a2 * b1;
  out[1] = a1 * b0 + a3 * b1;
  out[2] = a0 * b2 + a2 * b3;
  out[3] = a1 * b2 + a3 * b3;
  return out;
}

/**
 * 2x3 Matrix
 * @module mat2d
 *
 * @description
 * A mat2d contains six elements defined as:
 * <pre>
 * [a, c, tx,
 *  b, d, ty]
 * </pre>
 * This is a short form for the 3x3 matrix:
 * <pre>
 * [a, c, tx,
 *  b, d, ty,
 *  0, 0, 1]
 * </pre>
 * The last row is ignored so the array is shorter and operations are faster.
 */

/**
 * Creates a new identity mat2d
 *
 * @returns {mat2d} a new 2x3 matrix
 */
function create$8() {
  let out = new ARRAY_TYPE(6);
  if(ARRAY_TYPE != Float32Array) {
    out[1] = 0;
    out[2] = 0;
    out[4] = 0;
    out[5] = 0;
  }
  out[0] = 1;
  out[3] = 1;
  return out;
}

/**
 * Copy the values from one mat2d to another
 *
 * @param {mat2d} out the receiving matrix
 * @param {mat2d} a the source matrix
 * @returns {mat2d} out
 */
function copy$1(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  out[4] = a[4];
  out[5] = a[5];
  return out;
}

/**
 * Inverts a mat2d
 *
 * @param {mat2d} out the receiving matrix
 * @param {mat2d} a the source matrix
 * @returns {mat2d} out
 */
function invert$2(out, a) {
  let aa = a[0], ab = a[1], ac = a[2], ad = a[3];
  let atx = a[4], aty = a[5];

  let det = aa * ad - ab * ac;
  if(!det){
    return null;
  }
  det = 1.0 / det;

  out[0] = ad * det;
  out[1] = -ab * det;
  out[2] = -ac * det;
  out[3] = aa * det;
  out[4] = (ac * aty - ad * atx) * det;
  out[5] = (ab * atx - aa * aty) * det;
  return out;
}

/**
 * Multiplies two mat2d's
 *
 * @param {mat2d} out the receiving matrix
 * @param {mat2d} a the first operand
 * @param {mat2d} b the second operand
 * @returns {mat2d} out
 */
function multiply$3(out, a, b) {
  let a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3], a4 = a[4], a5 = a[5];
  let b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3], b4 = b[4], b5 = b[5];
  out[0] = a0 * b0 + a2 * b1;
  out[1] = a1 * b0 + a3 * b1;
  out[2] = a0 * b2 + a2 * b3;
  out[3] = a1 * b2 + a3 * b3;
  out[4] = a0 * b4 + a2 * b5 + a4;
  out[5] = a1 * b4 + a3 * b5 + a5;
  return out;
}

/**
 * Alias for {@link mat2d.multiply}
 * @function
 */
const mul$2 = multiply$3;

/**
 * 3x3 Matrix
 * @module mat3
 */

/**
 * Creates a new identity mat3
 *
 * @returns {mat3} a new 3x3 matrix
 */
function create$7() {
  let out = new ARRAY_TYPE(9);
  if(ARRAY_TYPE != Float32Array) {
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[5] = 0;
    out[6] = 0;
    out[7] = 0;
  }
  out[0] = 1;
  out[4] = 1;
  out[8] = 1;
  return out;
}

/**
 * Copies the upper-left 3x3 values into the given mat3.
 *
 * @param {mat3} out the receiving 3x3 matrix
 * @param {mat4} a   the source 4x4 matrix
 * @returns {mat3} out
 */
function fromMat4$1(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[4];
  out[4] = a[5];
  out[5] = a[6];
  out[6] = a[8];
  out[7] = a[9];
  out[8] = a[10];
  return out;
}

/**
 * Multiplies two mat3's
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the first operand
 * @param {mat3} b the second operand
 * @returns {mat3} out
 */
function multiply$2(out, a, b) {
  let a00 = a[0], a01 = a[1], a02 = a[2];
  let a10 = a[3], a11 = a[4], a12 = a[5];
  let a20 = a[6], a21 = a[7], a22 = a[8];

  let b00 = b[0], b01 = b[1], b02 = b[2];
  let b10 = b[3], b11 = b[4], b12 = b[5];
  let b20 = b[6], b21 = b[7], b22 = b[8];

  out[0] = b00 * a00 + b01 * a10 + b02 * a20;
  out[1] = b00 * a01 + b01 * a11 + b02 * a21;
  out[2] = b00 * a02 + b01 * a12 + b02 * a22;

  out[3] = b10 * a00 + b11 * a10 + b12 * a20;
  out[4] = b10 * a01 + b11 * a11 + b12 * a21;
  out[5] = b10 * a02 + b11 * a12 + b12 * a22;

  out[6] = b20 * a00 + b21 * a10 + b22 * a20;
  out[7] = b20 * a01 + b21 * a11 + b22 * a21;
  out[8] = b20 * a02 + b21 * a12 + b22 * a22;
  return out;
}

/**
* Calculates a 3x3 matrix from the given quaternion
*
* @param {mat3} out mat3 receiving operation result
* @param {quat} q Quaternion to create matrix from
*
* @returns {mat3} out
*/
function fromQuat(out, q) {
  let x = q[0], y = q[1], z = q[2], w = q[3];
  let x2 = x + x;
  let y2 = y + y;
  let z2 = z + z;

  let xx = x * x2;
  let yx = y * x2;
  let yy = y * y2;
  let zx = z * x2;
  let zy = z * y2;
  let zz = z * z2;
  let wx = w * x2;
  let wy = w * y2;
  let wz = w * z2;

  out[0] = 1 - yy - zz;
  out[3] = yx - wz;
  out[6] = zx + wy;

  out[1] = yx + wz;
  out[4] = 1 - xx - zz;
  out[7] = zy - wx;

  out[2] = zx - wy;
  out[5] = zy + wx;
  out[8] = 1 - xx - yy;

  return out;
}

function create$6() {
  let out = new ARRAY_TYPE(12);
  if(ARRAY_TYPE != Float32Array) {
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[5] = 0;
    out[6] = 0;
    out[7] = 0;
    out[9] = 0;
    out[10] = 0;
    out[11] = 0;
  }

  out[0] = 1;
  out[4] = 1;
  out[8] = 1;
  return out;
}

/**
 * Inverts a mat3d
 *
 * @param {mat3d} out the receiving matrix
 * @param {mat3d} a the source matrix
 * @returns {mat3d} out
 */
function invert$1(out, a) {
  let a00 = a[0], a01 = a[1], a02 = a[2], a03 = 0;
  let a10 = a[3], a11 = a[4], a12 = a[5], a13 = 0;
  let a20 = a[6], a21 = a[7], a22 = a[8], a23 = 0;
  let a30 = a[9], a31 = a[10], a32 = a[11], a33 = 1;

  let b00 = a00 * a11 - a01 * a10;
  let b01 = a00 * a12 - a02 * a10;
  let b02 = a00 * a13 - a03 * a10;
  let b03 = a01 * a12 - a02 * a11;
  let b04 = a01 * a13 - a03 * a11;
  let b05 = a02 * a13 - a03 * a12;
  let b06 = a20 * a31 - a21 * a30;
  let b07 = a20 * a32 - a22 * a30;
  let b08 = a20 * a33 - a23 * a30;
  let b09 = a21 * a32 - a22 * a31;
  let b10 = a21 * a33 - a23 * a31;
  let b11 = a22 * a33 - a23 * a32;

  // Calculate the determinant
  let det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;

  if (!det) {
    return null;
  }
  det = 1.0 / det;

  out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
  out[1] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
  out[2] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
  // out[3] = (a22 * b04 - a21 * b05 - a23 * b03) * det;
  out[3] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
  out[4] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
  out[5] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
  // out[7] = (a20 * b05 - a22 * b02 + a23 * b01) * det;
  out[6] = (a10 * b10 - a11 * b08 + a13 * b06) * det;
  out[7] = (a01 * b08 - a00 * b10 - a03 * b06) * det;
  out[8] = (a30 * b04 - a31 * b02 + a33 * b00) * det;
  // out[11] = (a21 * b02 - a20 * b04 - a23 * b00) * det;
  out[9] = (a11 * b07 - a10 * b09 - a12 * b06) * det;
  out[10] = (a00 * b09 - a01 * b07 + a02 * b06) * det;
  out[11] = (a31 * b01 - a30 * b03 - a32 * b00) * det;
  // out[15] = (a20 * b03 - a21 * b01 + a22 * b00) * det;

  return out;
}


/**
 * Copies the upper-left 3x3 values into the given mat3.
 *
 * @param {mat3d} out the receiving 3x4 matrix
 * @param {mat4} a   the source 4x4 matrix
 * @returns {mat3} out
 */
function fromMat4(out, a) {
  out[0] = a[0]; out[3] = a[4]; out[6] = a[8]; out[9] = a[12];
  out[1] = a[1]; out[4] = a[5]; out[7] = a[9]; out[10] = a[13];
  out[2] = a[2]; out[5] = a[6]; out[8] = a[10]; out[11] = a[14];

  return out;
}




/**
 * Copy the values from one mat3 to another
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the source matrix
 * @returns {mat3} out
 */
function copy(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  out[4] = a[4];
  out[5] = a[5];
  out[6] = a[6];
  out[7] = a[7];
  out[8] = a[8];
  out[9] = a[9];
  out[10] = a[10];
  out[11] = a[11];
  return out;
}


/**
 * Multiplies two mat3's
 *
 * @param {mat3d} out the receiving matrix
 * @param {mat3d} a the first operand
 * @param {mat3d} b the second operand
 * @returns {mat3d} out
 */
function multiply$1(out, a, b) {

  let a00,    a01,  a02,  a03,
      a10,    a11,  a12,  a13,
      a20,    a21,  a22,  a23,
      a30 = 0,a31=0,a32=0,a33=1;

  if(a.length == 12){
    a00 = a[0], a01 = a[3], a02 = a[6], a03 = a[9],
    a10 = a[1], a11 = a[4], a12 = a[7], a13 = a[10],
    a20 = a[2], a21 = a[5], a22 = a[8], a23 = a[11];
  }else if(a.length == 16)
    [a00, a10,a20,a30,
      a01,a11,a21,a31,
      a02,a12,a22,a32,
      a03,a13,a23,a33] = a;


  let b00,    b01,  b02,  b03,
      b10,    b11,  b12,  b13,
      b20,    b21,  b22,  b23,
      b30 = 0,b31=0,b32=0,b33=1;

  if(b.length == 12){
    b00 = b[0], b01 = b[3], b02 = b[6], b03 = b[9],
        b10 = b[1], b11 = b[4], b12 = b[7], b13 = b[10],
        b20 = b[2], b21 = b[5], b22 = b[8], b23 = b[11];
  }else if(b.length == 16)
    [b00, b10,b20,b30,
      b01,b11,b21,b31,
      b02,b12,b22,b32,
      b03,b13,b23,b33] = b;




  if(out.length == 12){
    out[0] = a00*b00 + a01*b10 + a02*b20;
    out[1] = a10*b00 + a11*b10 + a12*b20;
    out[2] = a20*b00 + a21*b10 + a22*b20;

    out[3] = a00*b01 + a01*b11 + a02*b21;
    out[4] = a10*b01 + a11*b11 + a12*b21;
    out[5] = a20*b01 + a21*b11 + a22*b21;

    out[6] = a00*b02 + a01*b12 + a02*b22;
    out[7] = a10*b02 + a11*b12 + a12*b22;
    out[8] = a20*b02 + a21*b12 + a22*b22;

    out[9] = a00*b03 + a01*b13 + a02*b23;
    out[10] = a10*b03 + a11*b13 + a12*b23;
    out[11] = a20*b03 + a21*b13 + a22*b23;
  }else {
    out[0] = a00*b00 + a01*b10 + a02*b20 + a03*b30;
    out[1] = a10*b00 + a11*b10 + a12*b20 + a13*b30;
    out[2] = a20*b00 + a21*b10 + a22*b20 + a23*b30;
    out[3] = a30*b00 + a31*b10 + a32*b20 + a33*b30;

    out[4] = a00*b01 + a01*b11 + a02*b21 + a03*b31;
    out[5] = a10*b01 + a11*b11 + a12*b21 + a13*b31;
    out[6] = a20*b01 + a21*b11 + a22*b21 + a23*b31;
    out[7] = a30*b01 + a31*b11 + a32*b21 + a33*b31;


    out[8] = a00*b02 + a01*b12 + a02*b22 + a03*b32;
    out[9] = a10*b02 + a11*b12 + a12*b22 + a13*b32;
    out[10] = a20*b02 + a21*b12 + a22*b22 + a23*b32;
    out[11] = a30*b02 + a31*b12 + a32*b22 + a33*b32;



    out[12] = a00*b03 + a01*b13 + a02*b23 + a03*b33;
    out[13] = a10*b03 + a11*b13 + a12*b23 + a13*b33;
    out[14] = a20*b03 + a21*b13 + a22*b23 + a23*b33;
    out[15] = a30*b03 + a31*b13 + a32*b23 + a33*b33;
  }
  return out;
}

/**
 * 4x4 Matrix<br>Format: column-major, when typed out it looks like row-major<br>The matrices are being post multiplied.
 * @module mat4
 */

/**
 * Creates a new identity mat4
 *
 * @returns {mat4} a new 4x4 matrix
 */
function create$5() {
  let out = new ARRAY_TYPE(16);
  if(ARRAY_TYPE != Float32Array) {
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
  }
  out[0] = 1;
  out[5] = 1;
  out[10] = 1;
  out[15] = 1;
  return out;
}


/**
 * Set a mat4 to the identity matrix
 *
 * @param {mat4} out the receiving matrix
 * @returns {mat4} out
 */
function identity(out) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = 1;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = 1;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}

/**
 * Generates a perspective projection matrix with the given bounds.
 * Passing null/undefined/no value for far will generate infinite projection matrix.
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {number} fovy Vertical field of view in radians
 * @param {number} aspect Aspect ratio. typically viewport width/height
 * @param {number} near Near bound of the frustum
 * @param {number} far Far bound of the frustum, can be null or Infinity
 * @returns {mat4} out
 */
function perspective(out, fovy, aspect, near, far) {
  let f = 1.0 / Math.tan(fovy / 2), nf;
  out[0] = f / aspect;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = f;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[11] = -1;
  out[12] = 0;
  out[13] = 0;
  out[15] = 0;
  if (far != null && far !== Infinity) {
    nf = 1 / (near - far);
    out[10] = (far + near) * nf;
    out[14] = (2 * far * near) * nf;
  } else {
    out[10] = -1;
    out[14] = -2 * near;
  }
  return out;
}

/**
 * Generates a look-at matrix with the given eye position, focal point, and up axis.
 * If you want a matrix that actually makes an object look at another object, you should use targetTo instead.
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {vec3} eye Position of the viewer
 * @param {vec3} center Point the viewer is looking at
 * @param {vec3} up vec3 pointing up
 * @returns {mat4} out
 */
function lookAt(out, eye, center, up, isInverse = false,lookAxis = '-z') {
  let x0, x1, x2, y0, y1, y2, z0, z1, z2, len;
  let eyex = eye[0];
  let eyey = eye[1];
  let eyez = eye[2];
  let upx = up[0];
  let upy = up[1];
  let upz = up[2];
  let centerx = center[0];
  let centery = center[1];
  let centerz = center[2];

  if (Math.abs(eyex - centerx) < EPSILON &&
      Math.abs(eyey - centery) < EPSILON &&
      Math.abs(eyez - centerz) < EPSILON) {
    return identity(out);
  }



  switch(lookAxis){
    case '-z':
      z0 = eyex - centerx;
      z1 = eyey - centery;
      z2 = eyez - centerz;

      len = 1 / Math.hypot(z0, z1, z2);
      z0 *= len;
      z1 *= len;
      z2 *= len;

      x0 = upy * z2 - upz * z1;
      x1 = upz * z0 - upx * z2;
      x2 = upx * z1 - upy * z0;
      len = Math.hypot(x0, x1, x2);
      if (!len) {
        x0 = 0;
        x1 = 0;
        x2 = 0;
      } else {
        len = 1 / len;
        x0 *= len;
        x1 *= len;
        x2 *= len;
      }
      break;
    case 'z':
      z0 = - eyex + centerx;
      z1 = - eyey + centery;
      z2 = - eyez + centerz;

      len = 1 / Math.hypot(z0, z1, z2);
      z0 *= len;
      z1 *= len;
      z2 *= len;

      x0 = upy * z2 - upz * z1;
      x1 = upz * z0 - upx * z2;
      x2 = upx * z1 - upy * z0;
      len = Math.hypot(x0, x1, x2);
      if (!len) {
        x0 = 0;
        x1 = 0;
        x2 = 0;
      } else {
        len = 1 / len;
        x0 *= len;
        x1 *= len;
        x2 *= len;
      }
      break;
    case 'x':
      x0 = - eyex + centerx;
      x1 = - eyey + centery;
      x2 = - eyez + centerz;
      len = 1 / Math.hypot(x0, x1, x2);
      x0 *= len;
      x1 *= len;
      x2 *= len;
      z0 = x1 * upz - x2 * upy;
      z1 = x2 * upx - x0 * upz;
      z2 = x0 * upy - x1 * upx;

      if (!len) {
        z0 = 0;
        z1 = 0;
        z2 = 0;
      }else {
        len = 1 / Math.hypot(z0, z1, z2);
        z0 *= len;
        z1 *= len;
        z2 *= len;
      }
      break;
    case '-x':
      x0 =  eyex - centerx;
      x1 =  eyey - centery;
      x2 =  eyez - centerz;
      len = 1 / Math.hypot(x0, x1, x2);
      x0 *= len;
      x1 *= len;
      x2 *= len;
      z0 = x1 * upz - x2 * upy;
      z1 = x2 * upx - x0 * upz;
      z2 = x0 * upy - x1 * upx;

      if (!len) {
        z0 = 0;
        z1 = 0;
        z2 = 0;
      }else {
        len = 1 / Math.hypot(z0, z1, z2);
        z0 *= len;
        z1 *= len;
        z2 *= len;
      }
      break;
  }



  y0 = z1 * x2 - z2 * x1;
  y1 = z2 * x0 - z0 * x2;
  y2 = z0 * x1 - z1 * x0;

  len = Math.hypot(y0, y1, y2);
  if (!len) {
    y0 = 0;
    y1 = 0;
    y2 = 0;
  } else {
    len = 1 / len;
    y0 *= len;
    y1 *= len;
    y2 *= len;
  }

  if(isInverse){
    out[0] = x0; out[4] = x1; out[8] = x2;  out[12] = -(x0 * eyex + x1 * eyey + x2 * eyez);
    out[1] = y0; out[5] = y1; out[9] = y2;  out[13] = -(y0 * eyex + y1 * eyey + y2 * eyez);
    out[2] = z0; out[6] = z1; out[10] = z2; out[14] = -(z0 * eyex + z1 * eyey + z2 * eyez);
    out[3] = 0; out[7] = 0;   out[11] = 0;  out[15] = 1;
  }else {
    out[0] = x0;    out[4] = y0;    out[8] = z0;    out[12] = eyex;//-(x0 * eyex + y0 * eyey + z0 * eyez);
    out[1] = x1;    out[5] = y1;    out[9] = z1;    out[13] = eyey;//-(x1 * eyex + y1 * eyey + z1 * eyez);
    out[2] = x2;    out[6] = y2;    out[10] = z2;   out[14] = eyez;//-(x2 * eyex + y2 * eyey + z2 * eyez);
    out[3] = 0;     out[7] = 0;     out[11] = 0;    out[15] = 1;
  }



  return out;
}

/**
 * 3 Dimensional Vector
 * @module vec3
 */

/**
 * Creates a new, empty vec3
 *
 * @returns {vec3} a new 3D vector
 */
function create$4() {
  let out = new ARRAY_TYPE(3);
  if(ARRAY_TYPE != Float32Array) {
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
  }
  return out;
}

/**
 * Calculates the length of a vec3
 *
 * @param {vec3} a vector to calculate length of
 * @returns {Number} length of a
 */
function length(a) {
  let x = a[0];
  let y = a[1];
  let z = a[2];
  return Math.hypot(x, y, z);
}

/**
 * Creates a new vec3 initialized with the given values
 *
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @returns {vec3} a new 3D vector
 */
function fromValues(x, y, z) {
  let out = new ARRAY_TYPE(3);
  out[0] = x;
  out[1] = y;
  out[2] = z;
  return out;
}

/**
 * Normalize a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a vector to normalize
 * @returns {vec3} out
 */
function normalize$4(out, a) {
  let x = a[0];
  let y = a[1];
  let z = a[2];
  let len = x*x + y*y + z*z;
  if (len > 0) {
    //TODO: evaluate use of glm_invsqrt here?
    len = 1 / Math.sqrt(len);
  }
  out[0] = a[0] * len;
  out[1] = a[1] * len;
  out[2] = a[2] * len;
  return out;
}

/**
 * Calculates the dot product of two vec3's
 *
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {Number} dot product of a and b
 */
function dot$2(a, b) {
  return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];
}

/**
 * Computes the cross product of two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */
function cross$2(out, a, b) {
  let ax = a[0], ay = a[1], az = a[2];
  let bx = b[0], by = b[1], bz = b[2];

  out[0] = ay * bz - az * by;
  out[1] = az * bx - ax * bz;
  out[2] = ax * by - ay * bx;
  return out;
}

/**
 * Transforms the vec3 with a mat4.
 * 4th vector component is implicitly '1'
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the vector to transform
 * @param {mat34} m matrix to transform with
 * @returns {vec3} out
 */
function transformMat3d(out, a, m) {
  let x = a[0], y = a[1], z = a[2];

  out[0] = m[0] * x + m[3] * y + m[6] * z + m[9];
  out[1] = m[1] * x + m[4] * y + m[7] * z + m[10];
  out[2] = m[2] * x + m[5] * y + m[8] * z + m[11];
  return out;
}

/**
 * Alias for {@link vec3.length}
 * @function
 */
const len = length;

/**
 * Perform some operation over an array of vec3s.
 *
 * @param {Array} a the array of vectors to iterate over
 * @param {Number} stride Number of elements between the start of each vec3. If 0 assumes tightly packed
 * @param {Number} offset Number of elements to skip at the beginning of the array
 * @param {Number} count Number of vec3s to iterate over. If 0 iterates over entire array
 * @param {Function} fn Function to call for each vector in the array
 * @param {Object} [arg] additional argument to pass to fn
 * @returns {Array} a
 * @function
 */
((function() {
  let vec = create$4();

  return function(a, stride, offset, count, fn, arg) {
    let i, l;
    if(!stride) {
      stride = 3;
    }

    if(!offset) {
      offset = 0;
    }

    if(count) {
      l = Math.min((count * stride) + offset, a.length);
    } else {
      l = a.length;
    }

    for(i = offset; i < l; i += stride) {
      vec[0] = a[i]; vec[1] = a[i+1]; vec[2] = a[i+2];
      fn(vec, vec, arg);
      a[i] = vec[0]; a[i+1] = vec[1]; a[i+2] = vec[2];
    }

    return a;
  };
}))();

/**
 * 4 Dimensional Vector
 * @module vec4
 */

/**
 * Creates a new, empty vec4
 *
 * @returns {vec4} a new 4D vector
 */
function create$3() {
  let out = new ARRAY_TYPE(4);
  if(ARRAY_TYPE != Float32Array) {
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
  }
  return out;
}

/**
 * Normalize a vec4
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a vector to normalize
 * @returns {vec4} out
 */
function normalize$3(out, a) {
  let x = a[0];
  let y = a[1];
  let z = a[2];
  let w = a[3];
  let len = x*x + y*y + z*z + w*w;
  if (len > 0) {
    len = 1 / Math.sqrt(len);
  }
  out[0] = x * len;
  out[1] = y * len;
  out[2] = z * len;
  out[3] = w * len;
  return out;
}

/**
 * Perform some operation over an array of vec4s.
 *
 * @param {Array} a the array of vectors to iterate over
 * @param {Number} stride Number of elements between the start of each vec4. If 0 assumes tightly packed
 * @param {Number} offset Number of elements to skip at the beginning of the array
 * @param {Number} count Number of vec4s to iterate over. If 0 iterates over entire array
 * @param {Function} fn Function to call for each vector in the array
 * @param {Object} [arg] additional argument to pass to fn
 * @returns {Array} a
 * @function
 */
((function() {
  let vec = create$3();

  return function(a, stride, offset, count, fn, arg) {
    let i, l;
    if(!stride) {
      stride = 4;
    }

    if(!offset) {
      offset = 0;
    }

    if(count) {
      l = Math.min((count * stride) + offset, a.length);
    } else {
      l = a.length;
    }

    for(i = offset; i < l; i += stride) {
      vec[0] = a[i]; vec[1] = a[i+1]; vec[2] = a[i+2]; vec[3] = a[i+3];
      fn(vec, vec, arg);
      a[i] = vec[0]; a[i+1] = vec[1]; a[i+2] = vec[2]; a[i+3] = vec[3];
    }

    return a;
  };
}))();

/**
 * Quaternion
 * @module quat
 */

/**
 * Creates a new identity quat
 *
 * @returns {quat} a new quaternion
 */
function create$2() {
  let out = new ARRAY_TYPE(4);
  if(ARRAY_TYPE != Float32Array) {
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
  }
  out[3] = 1;
  return out;
}

/**
 * Sets a quat from the given angle and rotation axis,
 * then returns it.
 *
 * @param {quat} out the receiving quaternion
 * @param {vec3} axis the axis around which to rotate
 * @param {Number} rad the angle in radians
 * @returns {quat} out
 **/
function setAxisAngle(out, axis, rad) {
  rad = rad * 0.5;
  let s = Math.sin(rad);
  out[0] = s * axis[0];
  out[1] = s * axis[1];
  out[2] = s * axis[2];
  out[3] = Math.cos(rad);
  return out;
}

/**
 * Performs a spherical linear interpolation between two quat
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a the first operand
 * @param {quat} b the second operand
 * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
 * @returns {quat} out
 */
function slerp(out, a, b, t) {
  // benchmarks:
  //    http://jsperf.com/quaternion-slerp-implementations
  let ax = a[0], ay = a[1], az = a[2], aw = a[3];
  let bx = b[0], by = b[1], bz = b[2], bw = b[3];

  let omega, cosom, sinom, scale0, scale1;

  // calc cosine
  cosom = ax * bx + ay * by + az * bz + aw * bw;
  // adjust signs (if necessary)
  if ( cosom < 0.0 ) {
    cosom = -cosom;
    bx = - bx;
    by = - by;
    bz = - bz;
    bw = - bw;
  }
  // calculate coefficients
  if ( (1.0 - cosom) > EPSILON ) {
    // standard case (slerp)
    omega  = Math.acos(cosom);
    sinom  = Math.sin(omega);
    scale0 = Math.sin((1.0 - t) * omega) / sinom;
    scale1 = Math.sin(t * omega) / sinom;
  } else {
    // "from" and "to" quaternions are very close
    //  ... so we can do a linear interpolation
    scale0 = 1.0 - t;
    scale1 = t;
  }
  // calculate final values
  out[0] = scale0 * ax + scale1 * bx;
  out[1] = scale0 * ay + scale1 * by;
  out[2] = scale0 * az + scale1 * bz;
  out[3] = scale0 * aw + scale1 * bw;

  return out;
}

/**
 * Creates a quaternion from the given 3x3 rotation matrix.
 *
 * NOTE: The resultant quaternion is not normalized, so you should be sure
 * to renormalize the quaternion yourself where necessary.
 *
 * @param {quat} out the receiving quaternion
 * @param {mat3} m rotation matrix
 * @returns {quat} out
 * @function
 */
function fromMat3(out, m) {
  // Algorithm in Ken Shoemake's article in 1987 SIGGRAPH course notes
  // article "Quaternion Calculus and Fast Animation".
  let fTrace = m[0] + m[4] + m[8];
  let fRoot;

  if ( fTrace > 0.0 ) {
    // |w| > 1/2, may as well choose w > 1/2
    fRoot = Math.sqrt(fTrace + 1.0);  // 2w
    out[3] = 0.5 * fRoot;
    fRoot = 0.5/fRoot;  // 1/(4w)
    out[0] = (m[5]-m[7])*fRoot;
    out[1] = (m[6]-m[2])*fRoot;
    out[2] = (m[1]-m[3])*fRoot;
  } else {
    // |w| <= 1/2
    let i = 0;
    if ( m[4] > m[0] )
      i = 1;
    if ( m[8] > m[i*3+i] )
      i = 2;
    let j = (i+1)%3;
    let k = (i+2)%3;

    fRoot = Math.sqrt(m[i*3+i]-m[j*3+j]-m[k*3+k] + 1.0);
    out[i] = 0.5 * fRoot;
    fRoot = 0.5 / fRoot;
    out[3] = (m[j*3+k] - m[k*3+j]) * fRoot;
    out[j] = (m[j*3+i] + m[i*3+j]) * fRoot;
    out[k] = (m[k*3+i] + m[i*3+k]) * fRoot;
  }

  return out;
}

/**
 * Creates a quaternion from the given euler angle x, y, z.
 *
 * @param {quat} out the receiving quaternion
 * @param {x} Angle to rotate around X axis in degrees.
 * @param {y} Angle to rotate around Y axis in degrees.
 * @param {z} Angle to rotate around Z axis in degrees.
 * @returns {quat} out
 * @function
 */
function fromEuler(out, x, y, z) {
    let halfToRad = 0.5 * Math.PI / 180.0;
    x *= halfToRad;
    y *= halfToRad;
    z *= halfToRad;

    let sx = Math.sin(x);
    let cx = Math.cos(x);
    let sy = Math.sin(y);
    let cy = Math.cos(y);
    let sz = Math.sin(z);
    let cz = Math.cos(z);

    out[0] = sx * cy * cz - cx * sy * sz;
    out[1] = cx * sy * cz + sx * cy * sz;
    out[2] = cx * cy * sz - sx * sy * cz;
    out[3] = cx * cy * cz + sx * sy * sz;

    return out;
}

/**
 * Normalize a quat
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a quaternion to normalize
 * @returns {quat} out
 * @function
 */
const normalize$2 = normalize$3;

/**
 * Sets a quaternion to represent the shortest rotation from one
 * vector to another.
 *
 * Both vectors are assumed to be unit length.
 *
 * @param {quat} out the receiving quaternion.
 * @param {vec3} a the initial vector
 * @param {vec3} b the destination vector
 * @returns {quat} out
 */
((function() {
  let tmpvec3 = create$4();
  let xUnitVec3 = fromValues(1,0,0);
  let yUnitVec3 = fromValues(0,1,0);

  return function(out, a, b) {
    let dot = dot$2(a, b);
    if (dot < -0.999999) {
      cross$2(tmpvec3, xUnitVec3, a);
      if (len(tmpvec3) < 0.000001)
        cross$2(tmpvec3, yUnitVec3, a);
      normalize$4(tmpvec3, tmpvec3);
      setAxisAngle(out, tmpvec3, Math.PI);
      return out;
    } else if (dot > 0.999999) {
      out[0] = 0;
      out[1] = 0;
      out[2] = 0;
      out[3] = 1;
      return out;
    } else {
      cross$2(tmpvec3, a, b);
      out[0] = tmpvec3[0];
      out[1] = tmpvec3[1];
      out[2] = tmpvec3[2];
      out[3] = 1 + dot;
      return normalize$2(out, out);
    }
  };
}))();

/**
 * Performs a spherical linear interpolation with two control points
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a the first operand
 * @param {quat} b the second operand
 * @param {quat} c the third operand
 * @param {quat} d the fourth operand
 * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
 * @returns {quat} out
 */
((function () {
  let temp1 = create$2();
  let temp2 = create$2();

  return function (out, a, b, c, d, t) {
    slerp(temp1, a, d, t);
    slerp(temp2, b, c, t);
    slerp(out, temp1, temp2, 2 * t * (1 - t));

    return out;
  };
})());

/**
 * Sets the specified quaternion with values corresponding to the given
 * axes. Each axis is a vec3 and is expected to be unit length and
 * perpendicular to all other specified axes.
 *
 * @param {vec3} view  the vector representing the viewing direction
 * @param {vec3} right the vector representing the local "right" direction
 * @param {vec3} up    the vector representing the local "up" direction
 * @returns {quat} out
 */
((function() {
  let matr = create$7();

  return function(out, view, right, up) {
    matr[0] = right[0];
    matr[3] = right[1];
    matr[6] = right[2];

    matr[1] = up[0];
    matr[4] = up[1];
    matr[7] = up[2];

    matr[2] = -view[0];
    matr[5] = -view[1];
    matr[8] = -view[2];

    return normalize$2(out, fromMat3(out, matr));
  };
}))();

/**
 * 2 Dimensional Vector
 * @module vec2
 */

/**
 * Creates a new, empty vec2
 *
 * @returns {vec2} a new 2D vector
 */
function create$1() {
  let out = new ARRAY_TYPE(2);
  if(ARRAY_TYPE != Float32Array) {
    out[0] = 0;
    out[1] = 0;
  }
  return out;
}

/**
 * Set the components of a vec2 to the given values
 *
 * @param {vec2} out the receiving vector
 * @param {Number} x X component
 * @param {Number} y Y component
 * @returns {vec2} out
 */
function set(out, x, y) {
  out[0] = x;
  out[1] = y;
  return out;
}

/**
 * Adds two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec2} out
 */
function add$1(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  return out;
}

/**
 * Subtracts vector b from vector a
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec2} out
 */
function subtract(out, a, b) {
  out[0] = a[0] - b[0];
  out[1] = a[1] - b[1];
  return out;
}

/**
 * Calculates the squared euclidian distance between two vec2's
 *
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {Number} squared distance between a and b
 */
function squaredDistance(a, b) {
  var x = b[0] - a[0],
    y = b[1] - a[1];
  return x*x + y*y;
}

/**
 * Normalize a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a vector to normalize
 * @returns {vec2} out
 */
function normalize$1(out, a) {
  var x = a[0],
    y = a[1];
  var len = x*x + y*y;
  if (len > 0) {
    //TODO: evaluate use of glm_invsqrt here?
    len = 1 / Math.sqrt(len);
  }    
  out[0] = a[0] * len;
  out[1] = a[1] * len;
  return out;
}

/**
 * Calculates the dot product of two vec2's
 *
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {Number} dot product of a and b
 */
function dot$1(a, b) {
  return a[0] * b[0] + a[1] * b[1];
}

/**
 * Computes the cross product of two vec2's
 * Note that the cross product must by definition produce a 3D vector
 *
 * @param {vec3} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec3} out
 */
// export function cross(out, a, b) {
//   var z = a[0] * b[1] - a[1] * b[0];
//   out[0] = out[1] = 0;
//   out[2] = z;
//   return out;
// }


/**
 * Computes the cross product of two vec2's
 * Note that the cross product must by definition produce a 3D vector
 *
 * @param {vec2,number} a the first operand
 * @param {vec2,number} b the second operand
 * @returns {number} out
 */
function cross$1(a, b) {
    if(a.length ==2 && b.length==2)
        return a[0]*b[1] - a[1]*b[0];
    else if(a.length == 2) // b is scalar
        return [b*a[1],-b*a[0]];
    else // a is scalar
        return [-a*b[1],a*b[0]];
}

/**
 * Transforms the vec2 with a mat2
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the vector to transform
 * @param {mat2} m matrix to transform with
 * @returns {vec2} out
 */
function transformMat2(out, a, m) {
  var x = a[0],
    y = a[1];
  out[0] = m[0] * x + m[2] * y;
  out[1] = m[1] * x + m[3] * y;
  return out;
}

/**
 * Transforms the vec2 with a mat2d
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the vector to transform
 * @param {mat2d} m matrix to transform with
 * @returns {vec2} out
 */
function transformMat2d(out, a, m) {
  var x = a[0],
    y = a[1];
  out[0] = m[0] * x + m[2] * y + m[4];
  out[1] = m[1] * x + m[3] * y + m[5];
  return out;
}

/**
 * Alias for {@link vec2.subtract}
 * @function
 */
const sub$1 = subtract;

/**
 * Alias for {@link vec2.squaredDistance}
 * @function
 */
const sqrDist = squaredDistance;

/**
 * Perform some operation over an array of vec2s.
 *
 * @param {Array} a the array of vectors to iterate over
 * @param {Number} stride Number of elements between the start of each vec2. If 0 assumes tightly packed
 * @param {Number} offset Number of elements to skip at the beginning of the array
 * @param {Number} count Number of vec2s to iterate over. If 0 iterates over entire array
 * @param {Function} fn Function to call for each vector in the array
 * @param {Object} [arg] additional argument to pass to fn
 * @returns {Array} a
 * @function
 */
((function() {
  let vec = create$1();

  return function(a, stride, offset, count, fn, arg) {
    let i, l;
    if(!stride) {
      stride = 2;
    }

    if(!offset) {
      offset = 0;
    }

    if(count) {
      l = Math.min((count * stride) + offset, a.length);
    } else {
      l = a.length;
    }

    for(i = offset; i < l; i += stride) {
      vec[0] = a[i]; vec[1] = a[i+1];
      fn(vec, vec, arg);
      a[i] = vec[0]; a[i+1] = vec[1];
    }

    return a;
  };
}))();

const combineAABB = function (out,a,b) {

    out[0] = Math.min(a[0],b[0]),
    out[1] = Math.min(a[1],b[1]),
    out[2] = Math.max(a[2],b[2]),
    out[3] = Math.max(a[3],b[3]);

    $assert$1(out.reduce((acc,prev)=>acc&=$isNumber$1(prev),true));

};

const isContainAABB = function(a,b){
    var result = true;
    result = result && a[0] <= b[0];
    result = result && a[1] <= b[1];
    result = result && a[2] >= b[2];
    result = result && a[3] >= b[3];
    return result;
};
const getPerimeter = function(aabb){

    return 2.0 * (aabb[2]-aabb[0] + aabb[3]-aabb[1]);
};

const isAABBOverlap = function(a, b) {
    // if(b[0] == 0 &&b[1] == 0 &&b[2] == 0 &&b[2] == 0)
    //     throw new Error('empty box');

    const d1 = [(b[0] - a[2]),(b[1] - a[3])],
            d2 = [(a[0] - b[2]),(a[1] - b[3])];

    if (d1[0] >= 0.0 || d1[1] >= 0.0)return false;
    if (d2[0] >= 0.0 || d2[1] >= 0.0)return false;

    return true;
};

class Node {
    constructor() {
        this.aabb = null;
        this.child1 = null;
        this.child2 = null;
        this.parent = null;
        this.next = null;
        this.proxy = null;
        // leaf = 0, free node = null
        this.height = null;
    };

    isLeaf() {
        return this.child1 == null;
    }
}



class DynamicTree {

    root = null;
    nodes = [];
    nodeCapacity = 16;
    nodeCount = 0;
    constructor() {

        this.clear();

    };

    clear() {


        this.root = null;
        this.nodes = [];
        this.nodeCapacity = 16;
        this.nodeCount = 0;

        for (let i = 0; i < this.nodeCapacity; i++)
            this.nodes.push(new Node());
        // Build a linked list for the free list.
        for (let i = 0; i < this.nodeCapacity - 1; ++i)
            this.nodes[i].next = i + 1;

        this.nodes[this.nodeCapacity - 1].next = null;
        this.freeListIndex = 0;

    }

    delNode(nodeId){

        this.removeLeaf(nodeId);
        this.freeNode(nodeId);

    }

    addAABB(aabb){
        const nodeIndex = this.allocateNode();

        this.nodes[nodeIndex].aabb = aabb.slice();
        this.nodes[nodeIndex].height = 0;

        this.insertLeaf(nodeIndex);

        return nodeIndex;
    }

    addProxy(proxy) {
        const nodeIndex = this.allocateNode();

        // Fatten the aabb.
        let r = [phyEngine.setting.AABBEXTENSION, phyEngine.setting.AABBEXTENSION];
        this.nodes[nodeIndex].proxy = proxy;
        let lowerBound = [0,0],
            upperBound = [0,0];

        sub$1(lowerBound,proxy.aabb, r);
        add$1(upperBound,[proxy.aabb[2], proxy.aabb[3]], r);


        $assert$1([...lowerBound,...upperBound].reduce((acc,prev)=>acc&=$isNumber$1(prev),true));

        this.nodes[nodeIndex].aabb = [lowerBound[0], lowerBound[1], upperBound[0], upperBound[1]];
        this.nodes[nodeIndex].height = 0;

        this.insertLeaf(nodeIndex);

        return nodeIndex;
    };

    updateProxy(nodeIndex, aabb) {
        $assert$1(this.nodes[nodeIndex]);
        if (isContainAABB(this.nodes[nodeIndex].aabb, aabb))
            return false;

        this.removeLeaf(nodeIndex);


        // // Extend AABB.
        // let b = [];
        // b[0] = aabb[0] - common.setting.AABBEXTENSION;
        // b[1] = aabb[1] - common.setting.AABBEXTENSION;
        // b[2] = aabb[2] + common.setting.AABBEXTENSION;
        // b[3] = aabb[3] + common.setting.AABBEXTENSION;

        // Predict AABB displacement.
        // let d = [AABBMULTIPLIER * displacement[0],AABBMULTIPLIER * displacement[1]];
        //
        // if (d[0] < 0.0)
        //     b[0] += d[0];
        // else
        //     b[2] += d[0];
        //
        // if (d[1] < 0.0)
        //     b[1] += d[1];
        // else
        //     b[3] += d[1];


        this.nodes[nodeIndex].aabb[0] = aabb[0];
        this.nodes[nodeIndex].aabb[1] = aabb[1];
        this.nodes[nodeIndex].aabb[2] = aabb[2];
        this.nodes[nodeIndex].aabb[3] = aabb[3];

        this.insertLeaf(nodeIndex);
        return true;
    }

    query(queryNodeId, queryCallback) {
        let stack = [];
        stack.push(this.root);

        while (stack.length > 0) {
            let nodeIndex = stack.pop();
            if (nodeIndex === null || queryNodeId === nodeIndex)
                continue;

            let node = this.nodes[nodeIndex];

                if (isAABBOverlap(node.aabb, this.nodes[queryNodeId].aabb)) {
                    if (node.isLeaf()) {

                        queryCallback(nodeIndex, queryNodeId);

                    } else {
                        stack.push(node.child1);
                        stack.push(node.child2);
                    }
                }
        }
    }

    // Perform a left or right rotation if node A is imbalanced.
    // Returns the new root index.
    balance(iA) {

        let A = this.nodes[iA];
        if (A.isLeaf() || A.height < 2) {
            return iA;
        }

        let iB = A.child1,
            iC = A.child2;
        let B = this.nodes[iB],
            C = this.nodes[iC];

        let balance = C.height - B.height;

        // Rotate C up
        if (balance > 1) {
            let iF = C.child1,
                iG = C.child2;
            let F = this.nodes[iF],
                G = this.nodes[iG];

            // Swap A and C
            C.child1 = iA;
            C.parent = A.parent;
            A.parent = iC;

            // A's old parent should point to C
            if (C.parent != null) {
                if (this.nodes[C.parent].child1 == iA)
                    this.nodes[C.parent].child1 = iC;
                else
                    this.nodes[C.parent].child2 = iC;

            } else
                this.root = iC;

            // Rotate
            if (F.height > G.height) {
                C.child2 = iF;
                A.child2 = iG;
                G.parent = iA;
                combineAABB(A.aabb, B.aabb, G.aabb);
                combineAABB(C.aabb, A.aabb, F.aabb);

                A.height = 1 + Math.max(B.height, G.height);
                C.height = 1 + Math.max(A.height, F.height);
            } else {
                C.child2 = iG;
                A.child2 = iF;
                F.parent = iA;
                combineAABB(A.aabb, B.aabb, F.aabb);
                combineAABB(C.aabb, A.aabb, G.aabb);


                A.height = 1 + Math.max(B.height, F.height);
                C.height = 1 + Math.max(A.height, G.height);
            }

            return iC;
        }

        // Rotate B up
        if (balance < -1) {
            let iD = B.child1,
                iE = B.child2;
            let D = this.nodes[iD],
                E = this.nodes[iE];

            // Swap A and B
            B.child1 = iA;
            B.parent = A.parent;
            A.parent = iB;

            // A's old parent should point to B
            if (B.parent != null) {
                if (this.nodes[B.parent].child1 == iA)
                    this.nodes[B.parent].child1 = iB;
                else
                    this.nodes[B.parent].child2 = iB;
            } else
                this.root = iB;


            // Rotate
            if (D.height > E.height) {
                B.child2 = iD;
                A.child1 = iE;
                E.parent = iA;
                combineAABB(A.aabb, C.aabb, E.aabb);
                combineAABB(B.aabb, A.aabb, D.aabb);


                A.height = 1 + Math.max(C.height, E.height);
                B.height = 1 + Math.max(A.height, D.height);

            } else {
                B.child2 = iE;
                A.child1 = iD;
                D.parent = iA;
                combineAABB(A.aabb, C.aabb, D.aabb);
                combineAABB(B.aabb, A.aabb, E.aabb);


                A.height = 1 + Math.max(C.height, D.height);
                B.height = 1 + Math.max(A.height, E.height);

            }

            return iB;
        }

        return iA;

    }

    allocateNode() {
        // Expand the node pool as needed.
        if (this.freeListIndex == null) {

            // The free list is empty. Rebuild a bigger pool.
            for (let i = 0; i < this.nodeCapacity; i++)
                this.nodes.push(new Node());
            this.nodeCapacity *= 2;


            // Build a linked list for the free list. The parent
            // pointer becomes the "next" pointer.
            for (let i = this.nodeCount; i < this.nodeCapacity - 1; ++i) {
                this.nodes[i].next = i + 1;
            }
            this.freeListIndex = this.nodeCount;
        }

        // Peel a node off the free list.
        let nodeIndex = this.freeListIndex;
        this.freeListIndex = this.nodes[nodeIndex].next;
        this.nodes[nodeIndex].height = 0;
        this.nodes[nodeIndex].aabb = [0,0,0,0];
        ++this.nodeCount;
        return nodeIndex;
    }

    freeNode(nodeIndex) {
        this.nodes[nodeIndex].child1 = null;
        this.nodes[nodeIndex].child2 = null;
        this.nodes[nodeIndex].parent = null;
        this.nodes[nodeIndex].height = null;
        this.nodes[nodeIndex].proxy = null;
        this.nodes[nodeIndex].aabb = null;

        this.nodes[nodeIndex].next = this.freeListIndex;
        this.freeListIndex = nodeIndex;
        --this.nodeCount;
    }

    insertLeaf(leafIndex) {
        // ++m_insertionCount;

        if (this.root == null) {
            this.root = leafIndex;
            this.nodes[leafIndex].parent = null;
            return;
        }

        // Find the best sibling for this node
        let leafAABB = this.nodes[leafIndex].aabb,
            index = this.root;
        while (this.nodes[index].isLeaf() == false) {
            let child1 = this.nodes[index].child1;
            let child2 = this.nodes[index].child2;


            let area = getPerimeter(this.nodes[index].aabb);
            let combinedAABB = [0, 0, 0, 0];//{lowerBound:[0,0],upperBound:[0,0]};
            combineAABB(combinedAABB, this.nodes[index].aabb, leafAABB);
            let combinedArea = getPerimeter(combinedAABB);

            // Cost of creating a new parent for this node and the new leaf
            let cost = 2.0 * combinedArea;

            // Minimum cost of pushing the leaf further down the tree
            let inheritanceCost = 2.0 * (combinedArea - area);

            // Cost of descending into child1
            let cost1;
            let aabb = [0, 0, 0, 0];//{lowerBound:[0,0],upperBound:[0,0]};
            if (this.nodes[child1].isLeaf()) {
                combineAABB(aabb, leafAABB, this.nodes[child1].aabb);
                cost1 = getPerimeter(aabb) + inheritanceCost;
            }
            else {
                combineAABB(aabb, leafAABB, this.nodes[child1].aabb);
                let oldArea = getPerimeter(this.nodes[child1].aabb);
                let newArea = getPerimeter(aabb);
                cost1 = (newArea - oldArea) + inheritanceCost;
            }

            // Cost of descending into child2
            let cost2;

            if (this.nodes[child2].isLeaf()) {
                combineAABB(aabb, leafAABB, this.nodes[child2].aabb);
                cost2 = getPerimeter(aabb) + inheritanceCost;
            } else {
                combineAABB(aabb, leafAABB, this.nodes[child2].aabb);
                let oldArea = getPerimeter(this.nodes[child2].aabb);
                let newArea = getPerimeter(aabb);
                cost2 = newArea - oldArea + inheritanceCost;
            }

            // Descend according to the minimum cost.
            if (cost < cost1 && cost < cost2)
                break;

            // Descend
            if (cost1 < cost2)
                index = child1;
            else
                index = child2;
        }

        let siblingIndex = index;

        // Create a new parent.
        let oldParentIndex = this.nodes[siblingIndex].parent;
        let newParentIndex = this.allocateNode();
        this.nodes[newParentIndex].parent = oldParentIndex;
        combineAABB(this.nodes[newParentIndex].aabb, leafAABB, this.nodes[siblingIndex].aabb);
        this.nodes[newParentIndex].height = this.nodes[siblingIndex].height + 1;

        if (oldParentIndex != null) {
            // The sibling was not the root.
            if (this.nodes[oldParentIndex].child1 == siblingIndex) {
                this.nodes[oldParentIndex].child1 = newParentIndex;
            }
            else {
                this.nodes[oldParentIndex].child2 = newParentIndex;
            }

            this.nodes[newParentIndex].child1 = siblingIndex;
            this.nodes[newParentIndex].child2 = leafIndex;
            this.nodes[siblingIndex].parent = newParentIndex;
            this.nodes[leafIndex].parent = newParentIndex;
        }
        else {
            // The sibling was the root.
            this.nodes[newParentIndex].child1 = siblingIndex;
            this.nodes[newParentIndex].child2 = leafIndex;
            this.nodes[siblingIndex].parent = newParentIndex;
            this.nodes[leafIndex].parent = newParentIndex;
            this.root = newParentIndex;
        }

        // Walk back up the tree fixing heights and AABBs
        index = this.nodes[leafIndex].parent;
        while (index != null) {//isRoot
            index = this.balance(index);

            let child1 = this.nodes[index].child1;
            let child2 = this.nodes[index].child2;


            this.nodes[index].height = 1 + Math.max(this.nodes[child1].height, this.nodes[child2].height);
            combineAABB(this.nodes[index].aabb, this.nodes[child1].aabb, this.nodes[child2].aabb);
            index = this.nodes[index].parent;
        }

        //Validate();
    }

    removeLeaf(nodeIndex) {
        if (nodeIndex === this.root) {
            this.root = null;
            return;
        }

        $assert$1(this.nodes[nodeIndex].parent);

        let parent = this.nodes[nodeIndex].parent,
            grandParent = this.nodes[parent].parent;

        const sibling = this.nodes[parent].child1 === nodeIndex?
                    this.nodes[parent].child2:this.nodes[parent].child1;

        // let sibling;
        // if (this.nodes[parent].child1 == nodeIndex)
        //     sibling = this.nodes[parent].child2;
        // else
        //     sibling = this.nodes[parent].child1;

        if (grandParent != null) {
            // Destroy parent and connect sibling to grandParent.
            // if (this.nodes[grandParent].child1 == parent)
            //     this.nodes[grandParent].child1 = sibling;
            // else
            //     this.nodes[grandParent].child2 = sibling;

            const child = this.nodes[grandParent].child1 === parent?
                'child1':'child2';
            this.nodes[grandParent][child] = sibling;


            this.nodes[sibling].parent = grandParent;
            this.freeNode(parent);

            // Adjust ancestor bounds.
            let index = grandParent;
            while (index != null) {//isRoot
                index = this.balance(index);

                let child1 = this.nodes[index].child1,
                    child2 = this.nodes[index].child2;

                combineAABB(this.nodes[index].aabb, this.nodes[child1].aabb, this.nodes[child2].aabb);
                this.nodes[index].height = 1 + Math.max(this.nodes[child1].height, this.nodes[child2].height);

                index = this.nodes[index].parent;
            }
        } else {
            this.root = sibling;
            this.nodes[sibling].parent = null;
            this.freeNode(parent);
        }

        //Validate();
    };
}

const mul$1 = multiply,
    mulT = multiplyInv,
    sub = sub$1,
    dot = dot$1,
    add = add$1,
    normalize = normalize$1,
    tmpVec0 = create$1(),
    tmpVec1 = create$1();

const collideCircles = function(dynamicTree,localManifold,pair){

    try{

        let circleA = dynamicTree.nodes[pair.nodeIndexA].proxy.shape,
            circleB = dynamicTree.nodes[pair.nodeIndexB].proxy.shape;


        localManifold.reference = circleA;
        localManifold.incidence = circleB;

        if(!localManifold.points) localManifold.points = [{}];

        let pA = create$1(),
            pB = create$1(),
            d = create$1();

        sub(d,pB,pA);

        let disSqr = d[0]*d[0] + d[1]*d[1],
            rA = circleA.Radius,
            rB = circleB.Radius,
            radius = rA + rB;


        mul$1(pA,circleA.transform,circleA.MassCenter);
        mul$1(pB,circleB.transform,circleB.MassCenter);

        if(disSqr > radius * radius)
            return false;


        localManifold.type = ManifoldType.e_circles;
        // localManifold.localPoint = circleA.MassCenter;

        // localManifold.points[0].localPoint = circleB.MassCenter;

        // let a = add(pA, mul(rA, normal)),
        let normal = create$1();
        normalize(normal,d);

        // mul(d,rB, [-normal[0],-normal[1]]);


        d[0] = -rB*normal[0], d[1] = -rB*normal[1];
        add$1(d,pB, d);
        localManifold.points[0].worldPoint = d;
        localManifold.normal = normal;

        return true;
    }catch(e){
        debugger;
    }
};

const collideCircleAndPolygon = function(dynamicTree,localManifold, pair){
    if(!localManifold.points) localManifold.points = [];

    let simObjA = dynamicTree.nodes[pair.nodeIndexA].proxy.shape,
        simObjB = dynamicTree.nodes[pair.nodeIndexB].proxy.shape;




    let poly, circle;

    if(simObjA.Type === phyEngine.setting.SHAPE_TYPE.box)
        poly = simObjA, circle = simObjB;
    else
        poly = simObjB, circle = simObjA;

    // Compute circle position in the frame of the polygon.
    let centerInWorld = create$1();
    mul$1(centerInWorld,circle.Transform, circle.MassCenter);
    let localCenter = create$1();//poly.Transform.pivot?poly.Transform.pivot:
    mulT(localCenter,poly.Transform, centerInWorld);


    // if(poly.name == 'kim2:rArm')
    // debugger;

    // Find the min separating edge.
    let normalIndex = 0,
        separation = -phyEngine.setting.b2_maxFloat,
        radius = phyEngine.setting.POLYGON_RADIUS + circle.Radius;
    for(let i in poly.Vertice){
        sub(tmpVec0,localCenter, poly.Vertice[i]);
        let s = dot(poly.normals[i],tmpVec0);
        if(s > radius)
            return false;

        if (s > separation){
            separation = s;normalIndex = parseInt(i);
        }
    }


    let v1 = poly.Vertice[normalIndex],
        v2 = poly.Vertice[normalIndex+1<poly.Vertice.length?normalIndex+1:0];


    // If the center is inside the polygon ...
    if (separation < phyEngine.setting.b2_epsilon) {
        localManifold.type = phyEngine.setting.ManifoldType.e_face;
        // localManifold.localNormal = poly.normals[normalIndex];
        // localManifold.localPoint =  mul(0.5, add(v1 , v2));

        let normal = create$1(),
            worldPoint = create$1();
        transformMat2(normal,poly.normals[normalIndex],poly.Transform.Matrix);
        localManifold.normal = normal;
        if(!localManifold.points[0])localManifold.points[0] = {};
        // localManifold.points[0].localPoint = circle.MassCenter;
        // manifold.points[0].id.key = 0;
        localManifold.points[0].worldPoint = worldPoint;
        add(worldPoint,centerInWorld,[-radius*normal[0],-radius*normal[1]]);
        localManifold.reference = poly;
        localManifold.incidence = circle;
        return true;
    }


    // Compute barycentric coordinates
    const rr = radius*radius;


    sub(tmpVec0,localCenter , v1),sub(tmpVec1,v2 , v1);

    let u1 = dot(tmpVec0,tmpVec1 );


    sub(tmpVec0,localCenter , v2),sub(tmpVec1,v1 , v2);
    let u2 = dot(tmpVec0, tmpVec1);


    if(u1 <= 0 || u2<= 0){ // if collision happens outside the line boundary
        let v = u1<=0? v1:v2;
        if(sqrDist(localCenter, v) > rr)
            return false;
        localManifold.type = phyEngine.setting.ManifoldType.e_face;
        // localManifold.localNormal = sub(localCenter,v);
        // normalize(localManifold.localNormal);
        // localManifold.localPoint = v;
        let normal = create$1();
        sub(normal,localCenter,v);
        normalize(normal,normal);
        transformMat2(normal,normal,poly.Transform.Matrix);
        localManifold.normal = normal;
        if(!localManifold.points[0])localManifold.points[0] = {};
        // localManifold.points[0].localPoint = circle.MassCenter;
        // manifold.points[0].id.key = 0;

        let worldPoint = create$1();
        add(worldPoint, centerInWorld, [-radius*normal[0], -radius*normal[1]]);
        localManifold.points[0].worldPoint = worldPoint;
    } else {
        // let faceCenter = mul(0.5, add(v1, v2));
        // let s = dot(sub(localCenter, faceCenter), poly.normals[normalIndex]);

        sub(tmpVec0,localCenter, v1);
        let s = dot(tmpVec0, poly.normals[normalIndex]);
        if(s>radius)
            return false;

        localManifold.type = phyEngine.setting.ManifoldType.e_face;

        // localManifold.localNormal = poly.normals[normalIndex];
        // localManifold.localPoint =  faceCenter;

        let normal = create$1();
        transformMat2(normal, poly.normals[normalIndex], poly.Transform.Matrix);
        localManifold.normal = normal;
        if(!localManifold.points[0])localManifold.points[0] = {};
        // localManifold.points[0].localPoint = circle.MassCenter;
        // manifold.points[0].id.key = 0;
        let worldPoint = create$1();
        add(worldPoint,centerInWorld,[-radius*normal[0],-radius*normal[1]]);
        localManifold.points[0].worldPoint = worldPoint;


    }

    localManifold.reference = poly;
    localManifold.incidence = circle;
    return true;

};

//////////////////////////////////////////////
//////////////////////////////////////////////
//////////////////////////////////////////////
//////////////////////////////////////////////
//////////////////////////////////////////////
//////////////////////////////////////////////
//////////////////////////////////////////////
//////////////////////////////////////////////

function __findEdgeSeperation(out, vertice, incidence){
    let normal = create$1();
    sub(normal,vertice[1], vertice[0]);
    //normal = [-normal[1], normal[0]];
    normal[0] = -normal[1];
    normal[1] = normal[0];
    normalize(normal,normal);

    let v0 = create$1();
    sub(v0,vertice[2], vertice[0]);
    let v1 = create$1();
    sub(v1,vertice[3], vertice[0]);

    let dot0 = dot(v0, normal),
        dot1 = dot(v1, normal);

    if(Math.abs(dot0)<phyEngine.setting.b2_epsilon){
        out.type = phyEngine.setting.ManifoldType.e_circles;
        if(dot0<0)
            normal = [-normal[0],-normal[1]];
        out.normal = normal;
        out.point = v0;
        out.maxSeparation = 0;
        return true;
    }else if(Math.abs(dot1)<phyEngine.setting.b2_epsilon){
        out.type = phyEngine.setting.ManifoldType.e_circles;
        if(dot1<0)
            normal = [-normal[0],-normal[1]];
        out.normal = normal;
        out.point = v1;
        out.maxSeparation = 0;
        return true;
    }else if(dot0*dot1<0){

        out.type = phyEngine.setting.ManifoldType.e_face;

        transformMat2d(tmpVec0,incidence.Transform.Matrix,incidence.MassCenter);
        let centerVec = create$1();
        sub(centerVec, tmpVec0, vertice[0]);
        if(dot(centerVec, normal)<0){
            normal = [-normal[0],-normal[1]];
            dot0 = -dot0; dot1 = -dot1;
        }

        out.normal = normal;
        out.point = dot0<0?vertice[2]:vertice[3];
        out.maxSeparation = dot0<0?dot0:dot1;


        return true;
    }else
        return false;
}

const collideEdge = function(dynamicTree,localManifold, pair){

    let edgeA = dynamicTree.nodes[pair.nodeIndexA].proxy.shape,
        edgeB = dynamicTree.nodes[pair.nodeIndexB].proxy.shape;


    if(!localManifold.points) localManifold.points = [{}];


    let vertice = [create$1(),create$1(),create$1(),create$1()];
    // Compute everything in frame of world
    // vertice[0] = mul(edgeA.Transform,edgeA.shape.Vertice[0]);
    // vertice[1] = mul(edgeA.Transform,edgeA.shape.Vertice[1]);
    // vertice[2] = mul(edgeB.Transform,edgeB.shape.Vertice[0]);
    // vertice[3] = mul(edgeB.Transform,edgeB.shape.Vertice[1]);

    transformMat2d(vertice[0],edgeA.shape.Vertice[0],edgeA.Transform.Matrix);
    transformMat2d(vertice[1],edgeA.shape.Vertice[0],edgeA.Transform.Matrix);
    transformMat2d(vertice[2],edgeB.shape.Vertice[0],edgeB.Transform.Matrix);
    transformMat2d(vertice[3],edgeB.shape.Vertice[0],edgeB.Transform.Matrix);


    if(checkStatus$1(edgeA.status, phyEngine.setting.STATUS.static)) {
        let result = {};
        if (__findEdgeSeperation(result, vertice, edgeB)){
            localManifold.reference = edgeA;
            localManifold.incidence = edgeB;
            localManifold.type = phyEngine.setting.ManifoldType.e_circles;
            localManifold.normal = result.normal;
            localManifold.points[0].worldPoint = result.point;
            return true;
        }else
            return false;
    }else if(checkStatus$1(edgeB.status, phyEngine.setting.STATUS.static)) {

        let result = {};
        if (__findEdgeSeperation(result, [vertice[2],vertice[3],vertice[0],vertice[1]], edgeA)){
            localManifold.reference = edgeB;
            localManifold.incidence = edgeA;
            localManifold.type = phyEngine.setting.ManifoldType.e_circles;
            localManifold.normal = result.normal;
            localManifold.points[0].worldPoint = result.point;
            return true;
        }else
            return false;

    }else {


        let resultA = {},resultB = {};
        if (__findEdgeSeperation(resultA, vertice, edgeA)){

            __findEdgeSeperation(resultB, [vertice[2],vertice[3],vertice[0],vertice[1]], edgeB);
            if(resultA.maxSeparation>resultB.maxSeparation){
                localManifold.type = phyEngine.setting.ManifoldType.e_face;
                localManifold.reference = edgeA;
                localManifold.incidence = edgeB;
                localManifold.normal = resultA.normal;
                localManifold.points[0].worldPoint = resultA.point;
            }else {
                localManifold.reference = edgeB;
                localManifold.incidence = edgeA;
                localManifold.normal = resultB.normal;
                localManifold.points[0].worldPoint = resultB.point;
            }

            return true;
        }else
            return false;


    }








};


// Compute contact points for edge versus circle.
const collideEdgeAndCircle = function(dynamicTree,localManifold, pair) {
    let simObjA = dynamicTree.nodes[pair.nodeIndexA].proxy.shape,
        simObjB = dynamicTree.nodes[pair.nodeIndexB].proxy.shape;

    let edgeA = simObjA.type<simObjB.type?simObjA:simObjB,
        circleB = simObjA.type>simObjB.type?simObjA:simObjB;



    if(!localManifold.points) localManifold.points = [{}];

    let circleCenterInWorldSpace = create$1();
    transformMat2d(circleCenterInWorldSpace,circleB.Transform.Matrix, circleB.MassCenter);
    // Compute circle in frame of edge
    let Q = create$1();
    mulT(Q,edgeA.Transform.Matrix, circleCenterInWorldSpace);

    //let A = [edgeA.shape.Vertice[0],edgeA.shape.Vertice[1]], B = [edgeA.shape.Vertice[2],edgeA.shape.Vertice[3]];
    let e = create$1();
    sub(e, edgeA.shape.Vertice[1],edgeA.shape.Vertice[0]);

    // Barycentric coordinates
    sub(tmpVec0, edgeA.shape.Vertice[1] , Q);
    let u = dot(e,tmpVec0);
    sub(tmpVec1, Q , edgeA.shape.Vertice[0]);
    let v = dot(e, tmpVec1);

    //?????????????????????
    let radius = phyEngine.setting.POLYGON_RADIUS + circleB.Radius;//edgeA.Radius + circleB.Radius;



    localManifold.reference = edgeA;
    localManifold.incidence = circleB;

    // //b2ContactFeature cf;
    // let cf = {};
    // cf.indexB = 0;
    // cf.typeB = ContactFeature.vertex;

    // Region A
    if (v <= 0.0) {
        //sub(Q , edgeA.shape.Vertice[0])
        let dd = dot(tmpVec1, tmpVec1);
        if (dd > radius * radius) {
            return false;
        }
        // //?????????
        // cf.indexA = 0;
        // cf.typeA = ContactFeature.vertex;
        localManifold.type = phyEngine.setting.ManifoldType.e_circles;
        //localManifold.localNormal = [0,0];
        //localManifold.localPoint = edgeA.shape.Vertice[0];
        //localManifold.points[0].id.key = 0;
        //localManifold.points[0].id.cf = cf;
        //localManifold.points[0].localPoint = circleB.MassCenter;

        // let normal = normalize(d);
        normalize(tmpVec1,tmpVec1);
        let normal = create$1();
        transformMat2(normal,tmpVec1,edgeA.Transform.Matrix);
        localManifold.normal = normal;// only rotate vec
        let worldPoint = create$1();
        add(worldPoint,circleCenterInWorldSpace,[-circleB.Radius*normal[0],-circleB.Radius*normal[1]]);
        localManifold.points[0].worldPoint = worldPoint;
        return true;
    }

    // Region B
    if (u <= 0.0) {
        sub(tmpVec0, Q,edgeA.shape.Vertice[1]);
        let dd = dot(tmpVec0, tmpVec0);
        if (dd > radius * radius)
        {
            return false;
        }

        // cf.indexA = 1;
        // cf.typeA = ContactFeature.vertex;
        localManifold.type = phyEngine.setting.ManifoldType.e_circles;
//                localManifold.localNormal = [0,0];
//         localManifold.localPoint = edgeA.shape.Vertice[1];
        // localManifold.points[0].id.key = 0;
        // localManifold.points[0].id.cf = cf;
        // localManifold.points[0].localPoint = circleB.MassCenter;


        // let normal = normalize(d);
        normalize(tmpVec0,tmpVec0);
        let normal = create$1();
        transformMat2(normal,tmpVec0,edgeA.Transform.Matrix);
        localManifold.normal = normal;// only rotate vec

        let worldPoint = create$1();
        add(worldPoint,circleCenterInWorldSpace,[-circleB.Radius*normal[0],-circleB.Radius*normal[1]]);
        localManifold.points[0].worldPoint =worldPoint;
        return true;
    }

    // Region AB
    let den = dot(e, e);
    if(den <=0)
        throw new Error('devide by Zero');

    //let P = mul((1.0 / den) , add(mul(u , edgeA.shape.Vertice[0]) , mul(v , edgeA.shape.Vertice[1])));

    let P = create$1();
    tmpVec0[0] = edgeA.shape.Vertice[0][0]*u;
    tmpVec0[1] = edgeA.shape.Vertice[0][1]*u;
    tmpVec1[0] = edgeA.shape.Vertice[1][0]*v;
    tmpVec1[1] = edgeA.shape.Vertice[1][1]*v;


    add(P, tmpVec0,tmpVec1);


    //let d = sub(Q , P);
    sub(tmpVec0, Q , P);

    let dd = dot(tmpVec0, tmpVec0);
    if (dd > radius * radius)
        return false;

    let n = create$1();//[-e[1], e[0]];
    set(n,-e[1],e[0]);

    //sub(Q , edgeA.shape.Vertice[0])
    sub(tmpVec0, Q , edgeA.shape.Vertice[0]);

    if (dot(n, tmpVec0) < 0.0)
        //n = [-n[0], -n[1]];
        set(n,-n[0],-n[1]);

    normalize(n,n);

    // cf.indexA = 0;
    // cf.typeA = ContactFeature.face;
    localManifold.type = phyEngine.setting.ManifoldType.e_face;
    localManifold.localNormal = n;
    // localManifold.localPoint = edgeA.shape.Vertice[0];
    // localManifold.points[0].localPoint = circleB.MassCenter;


    set(tmpVec0,-radius*n[0],-radius*n[1]);
    let worldPoint = create$1();
    add(worldPoint,circleCenterInWorldSpace, tmpVec0);
    localManifold.points[0].worldPoint = worldPoint;
    return true;
};

let _poly = {vertice:[], normals:[]};

const collideEdgeAndPolygon = function(dynamicTree,localManifold, pair){

    if(!localManifold.points) localManifold.points = [];

    let simObjA = dynamicTree.nodes[pair.nodeIndexA].proxy.shape,
        simObjB = dynamicTree.nodes[pair.nodeIndexB].proxy.shape;

    let edgeA = simObjA.type<simObjB.type?simObjA:simObjB,
        polyB = simObjA.type>simObjB.type?simObjA:simObjB;




    let m_xf_B2A = mulT(edgeA.Transform, polyB.Transform);

    let centroidB = mul$1(m_xf_B2A, polyB.MassCenter);




    let edgeDir = sub(edgeA.shape.Vertice[1], edgeA.shape.Vertice[0]);
    //[edgeA.shape.Vertice[2] - edgeA.shape.Vertice[0], edgeA.shape.Vertice[3] - edgeA.shape.Vertice[1]];
    normalize(edgeDir,edgeDir);

    let normal = [edgeDir[1], -edgeDir[0]]; //clockwise 90
    let offset = dot(normal, sub(centroidB, edgeA.shape.Vertice[0]));

    if(offset<0) normal = [-normal[0],-normal[1]];


    // Get polygonB in frameA
    for (let i = 0; i < polyB.shape.Vertice.length; ++i) {
        _poly.shape.Vertice[i] = mul$1(m_xf_B2A, polyB.shape.Vertice[i]);
        _poly.normals[i]  = mul$1(m_xf_B2A.q, polyB.normals[i]);
    }



    //edge separation
    let edgeAxis = {separation:phyEngine.setting.b2_maxFloat, index:offset>0?0:1};
    for (let i = 0; i < _poly.shape.Vertice.length; ++i) {
        let s = dot(normal, sub( _poly.shape.Vertice[i], edgeA.shape.Vertice[0]));
        if(s<edgeAxis.separation)
            edgeAxis.separation = s;
    }
    if(edgeAxis.separation>_totalPoly_PolyRadius)
        return false;


    //poly separation
    let polyAxis = {separation:-phyEngine.setting.b2_maxFloat, index:0};

    [-normal[1], normal[0]]; //counter-clockwise 90
    for(let i in _poly.shape.Vertice){
        let n = [-_poly.normals[i][0],-_poly.normals[i][1]];

        let s1 = dot(n, sub(_poly.shape.Vertice[i],edgeA.shape.Vertice[0]));
        let s2 = dot(n, sub(_poly.shape.Vertice[i],edgeA.shape.Vertice[1]));
        let s = Math.min(s1,s2);

        if(s > _totalPoly_PolyRadius){
            // polyAxis.separation = s; //TODO: unused params
            // polyAxis.index = parseInt(i);
            return false;
        }

        if(s > polyAxis.separation){
            polyAxis.separation = s;
            polyAxis.index = parseInt(i);
        }
    }



    // Use hysteresis for jitter reduction.
    const k_relativeTol = 0.98;
    const k_absoluteTol = 0.001;

    let primaryAxis;
    // if (polygonAxis.type == b2EPAxis::e_unknown)
    // {
    //     primaryAxis = edgeAxis;
    // }
    // else
    if (polyAxis.separation > k_relativeTol * edgeAxis.separation + k_absoluteTol)
        primaryAxis = polyAxis;
    else
        primaryAxis = edgeAxis;

    let incidenceEdge = [];
    let referenceFace = {vertice:[]};

    localManifold.type = phyEngine.setting.ManifoldType.e_face;
    if (primaryAxis == edgeAxis) {

        // Search for the polygon normal that is most anti-parallel to the edge normal.
        let bestIndex = 0;
        let bestValue = dot(normal, _poly.normals[0]);

        for(let i=1; i<_poly.normals.length; i++){
            let value = dot(normal, _poly.normals[i]);
            if (value < bestValue) {
                bestValue = value;
                bestIndex = parseInt(i);
            }
        }

        let i1 = bestIndex,
            i2 = i1 + 1 < _poly.shape.Vertice.length ? i1 + 1 : 0;
        incidenceEdge[0] = _poly.shape.Vertice[i1];
        incidenceEdge[1] = _poly.shape.Vertice[i2];

        let center = [0.5*(edgeA.shape.Vertice[0][0] + edgeA.shape.Vertice[1][0]), 0.5*(edgeA.shape.Vertice[0][1] + edgeA.shape.Vertice[1][1])];
        if (cross(normal, sub(edgeA.shape.Vertice[0], center))>0) {//edgeV0 is on the left side of normal
            referenceFace.shape.Vertice[0] = edgeA.shape.Vertice[0];
            referenceFace.shape.Vertice[1] = edgeA.shape.Vertice[1];
        } else {
            referenceFace.shape.Vertice[0] = edgeA.shape.Vertice[1];
            referenceFace.shape.Vertice[1] = edgeA.shape.Vertice[0];
        }

        referenceFace.normal = normal;
    } else {

        incidenceEdge[0] = edgeA.shape.Vertice[0];
        incidenceEdge[1] = edgeA.shape.Vertice[1];

        let i1 = primaryAxis.index,
            i2 = i1 + 1 < _poly.shape.Vertice.length ? i1 + 1 : 0;
        referenceFace.shape.Vertice[0] = _poly.shape.Vertice[i1];
        referenceFace.shape.Vertice[1] = _poly.shape.Vertice[i2];
        referenceFace.normal = _poly.normals[i1];
    }

    referenceFace.sideNormal1 = [referenceFace.normal[1], -referenceFace.normal[0]]; // clock wise
    referenceFace.sideNormal2 = [-referenceFace.normal[1], referenceFace.normal[0]]; //-sideNormal1,
    referenceFace.sideOffset1 = dot(referenceFace.sideNormal1, referenceFace.shape.Vertice[0]);
    referenceFace.sideOffset2 = dot(referenceFace.sideNormal2, referenceFace.shape.Vertice[1]);

    // Clip incident edge against extruded edge1 side edges.
    let clipPoints1 = [], clipPoints2 = [];
    // let np;

    // Clip to box side 1
    if(!clipSegmentToLine(clipPoints1, incidenceEdge, referenceFace.sideNormal1, referenceFace.sideOffset1))
        return false;


    // Clip to negative box side 1
    if(!clipSegmentToLine(clipPoints2, clipPoints1, referenceFace.sideNormal2, referenceFace.sideOffset2))
        return false;
    // Now clipPoints2 contains the clipped points.


    if (primaryAxis == edgeAxis) {
        localManifold.localNormal = referenceFace.normal;
        // localManifold.localPoint = referenceFace.shape.Vertice[0];

        localManifold.reference = edgeA;
        localManifold.incidence = polyB;
    } else { // primaryAxis == polyAxis
        localManifold.localNormal = polyB.normals[primaryAxis.index];
        // localManifold.localPoint  = polyB.shape.Vertice[primaryAxis.index];

        localManifold.reference = polyB;
        localManifold.incidence = edgeA;
    }

    // let pointCount = 0;
    for (let i = 0; i < phyEngine.setting.b2_maxManifoldPoints; ++i) {
        let separation;

        separation = dot(referenceFace.normal, sub(clipPoints2[i] , referenceFace.shape.Vertice[0]));

        if (separation <= _totalPoly_PolyRadius) {


            let points = localManifold.points;
            if (primaryAxis == edgeAxis)
                points.push({localPoint:mulT(m_xf_B2A, clipPoints2[i])});
            else
                points.push({localPoint :clipPoints2[i]});

        }
    }
    if(localManifold.points.length == 0)
        return false;
    // manifold->pointCount = pointCount;
    return true;

};



//////////////////////////////////////////////
//////////////////////////////////////////////
//////////////////////////////////////////////
//////////////////////////////////////////////
//////////////////////////////////////////////
//////////////////////////////////////////////
//////////////////////////////////////////////
//////////////////////////////////////////////


//https://gamedevelopment.tutsplus.com/tutorials/understanding-sutherland-hodgman-clipping-for-physics-engines--gamedev-11917
// Sutherland-Hodgman clipping.
const clipSegmentToLine = function( vOut,
                                    vIn,
                                    normal,
                                    offset)
{

    // Calculate the distance of end points to the line
    let distance0 = dot(normal, vIn[0]) - offset,
        distance1 = dot(normal, vIn[1]) - offset;


    if(distance0<0&&distance1<0){
        return false; // both points been clipped
    }else {
        vOut[0] = vIn[0];
        vOut[1] = vIn[1];
    }


    // If the points are on different sides of the plane
    if (distance0 * distance1 < 0) {

        // Find intersection point of edge and plane
        let interp = distance0 / (distance0 - distance1); //float32
        let value = add(vIn[0] , mul$1(interp , sub(vIn[1] , vIn[0])));
        if(distance0 <= 0)
            vOut[0] =value;
        else
            vOut[1] = value;

    }
    return true;

};

const findIncidentEdge =  function( incidentEdge, reference, incidence, edgeIndex){
    // const b2PolygonShape* poly1, const b2Transform& xf1, int32 edge1,
    // const b2PolygonShape* poly2, const b2Transform& xf2)

    let count2 = incidence.shape.Vertice.length;
    // let incidenceVertice = incidence.shape.Vertice;
    // let incidenceNormals = incidence.normals;

    // b2Assert(0 <= edge1 && edge1 < poly1->m_count);

    // Get the normal of the reference edge in poly2's frame.
    let normal1 = mulT(incidence.Transform.q, mul$1(reference.Transform.q, reference.normals[edgeIndex]));

    // Find the incident edge on poly2.
    let index = 0;
    let minDot = phyEngine.setting.b2_maxFloat;
    for (let i = 0; i < count2; ++i){
        let d = dot(normal1, incidence.normals[i]);
        if (d < minDot) {
            minDot = d;
            index = i;
        }
    }
    // Build the clip vertices for the incident edge.
    let i1 = index;
    let i2 = i1 + 1 < count2 ? i1 + 1 : 0;

    incidentEdge[0] = mul$1(incidence.Transform, incidence.shape.Vertice[i1]);
    incidentEdge[1] = mul$1(incidence.Transform, incidence.shape.Vertice[i2]);


    // c[0].v = b2Mul(xf2, vertices2[i1]);
    // c[0].id.cf.indexA = (uint8)edge1;
    // c[0].id.cf.indexB = (uint8)i1;
    // c[0].id.cf.typeA = b2ContactFeature::e_face;
    // c[0].id.cf.typeB = b2ContactFeature::e_vertex;
    //
    // c[1].v = b2Mul(xf2, vertices2[i2]);
    // c[1].id.cf.indexA = (uint8)edge1;
    // c[1].id.cf.indexB = (uint8)i2;
    // c[1].id.cf.typeA = b2ContactFeature::e_face;
    // c[1].id.cf.typeB = b2ContactFeature::e_vertex;
};


//TODO: need optimize!
const __findMaxSeparation = function( out,
                                    poly1,
                                    poly2) {
    let count1 = poly1.Vertice.length;
    let count2 = poly2.Vertice.length;
    const  poly1Normals = poly1.normals;
    const  poly1Vertice = poly1.Vertice;
    const  poly2Vertice = poly2.Vertice;
    //Transform everything in frame 2
    let xf = mulT(poly2.Transform, poly1.Transform);

    let bestIndex = 0;
    let maxSeparation = -phyEngine.setting.b2_maxFloat;
    for (let i = 0; i < count1; ++i) {
        // Get poly1 normal in frame2.
        let n1  = mul$1(xf.q,  poly1Normals[i]);
        let v1 = mul$1(xf,    poly1Vertice[i]);

        // Find deepest point for normal i.
        let si = phyEngine.setting.b2_maxFloat;
        for (let j = 0; j < count2; ++j) {
            let sij = dot(n1, sub(poly2Vertice[j] ,  v1));
            if (sij < si)
                si = sij;

            if(si<maxSeparation)
                break;
        }

        if (si > maxSeparation) {
            maxSeparation = si;
            bestIndex = i;
        }
    }    out.maxSeparation = maxSeparation;
    out.edgeIndex = bestIndex;
};


const _totalPoly_PolyRadius = phyEngine.setting.POLYGON_RADIUS + phyEngine.setting.POLYGON_RADIUS;
const  _k_tol = 0.1* phyEngine.setting.LINEAR_SLOP;

//https://stackoverflow.com/questions/563198/how-do-you-detect-where-two-line-segments-intersect/565282#565282
const collideLineSeg = function(a0, a1, b0, b1) {



    let p0_x = a0[0], p0_y = a0[1],
        p1_x = a1[0], p1_y = a1[1],
        p2_x = b0[0], p2_y = b0[1],
        p3_x = b1[0], p3_y = b1[1];

    let s1_x, s1_y, s2_x, s2_y;
    s1_x = p1_x - p0_x;     s1_y = p1_y - p0_y;
    s2_x = p3_x - p2_x;     s2_y = p3_y - p2_y;

    let s, t;
    s = (-s1_y * (p0_x - p2_x) + s1_x * (p0_y - p2_y)) / (-s2_x * s1_y + s1_x * s2_y);
    t = ( s2_x * (p0_y - p2_y) - s2_y * (p0_x - p2_x)) / (-s2_x * s1_y + s1_x * s2_y);

    if (s >= 0 && s <= 1 && t >= 0 && t <= 1) {
        // Collision detected
        return [p0_x + (t * s1_x),p0_y + (t * s1_y)];
    }
    // console.log(s,t);
    return null; // No collision
};

const collidePolygons = function(dynamicTree,localManifold,pair) {

    let polyA = dynamicTree.nodes[pair.nodeIndexA].proxy.shape,
        polyB = dynamicTree.nodes[pair.nodeIndexB].proxy.shape;
    if(!localManifold.points) localManifold.points = [];

    let testSeparationA = {maxSeparation:0, edgeIndex:0};
    __findMaxSeparation(testSeparationA, polyA, polyB);
    if (testSeparationA.maxSeparation > _totalPoly_PolyRadius)
        return false;
    let edgeA = testSeparationA.edgeIndex;


    let testSeparationB = {maxSeparation:0, edgeIndex:0};
    __findMaxSeparation(testSeparationB, polyB, polyA);
    if (testSeparationB.maxSeparation > _totalPoly_PolyRadius)
        return false;
    let edgeB = testSeparationB.edgeIndex;


    // const b2PolygonShape* reference;	// reference polygon
    // const b2PolygonShape* incident;	// incident polygon


    let reference, incidence;

    let edgeIndex;

    localManifold.type = phyEngine.setting.ManifoldType.e_face;
    if (testSeparationB.maxSeparation > testSeparationA.maxSeparation + _k_tol) {
        reference = polyB;
        incidence = polyA;
        edgeIndex = edgeB;
    } else {
        reference = polyA;
        incidence = polyB;
        edgeIndex = edgeA;
    }

    let incidentEdge = [[0,0],[0,0]];
    findIncidentEdge(incidentEdge, reference,  incidence , edgeIndex);

    let count1 = reference.shape.Vertice.length;


    let v11 = reference.shape.Vertice[edgeIndex];
    let v12 = reference.shape.Vertice[edgeIndex + 1 < count1 ? edgeIndex + 1 : 0];

    // let localTangent = sub(v12 , v11);
    // normalize(localTangent);

    let localNormal = reference.normals[edgeIndex];//cross(localTangent, 1);
    let localTangent = [localNormal[1], -localNormal[0]];//cross(localNormal,1); //clockwise
    //TODO:need optimize in worldSpace
    mul$1( 0.5 , add(v11 , v12));


    let tangent0 = mul$1(reference.Transform.q, localTangent),
        tangent1 = [-tangent0[0],-tangent0[1]];

    let normal =  mul$1(reference.Transform.q, localNormal);//cross(tangent0, 1);

    v11 = mul$1(reference.Transform, v11);
    v12 = mul$1(reference.Transform, v12);

    // Face offset.
    let frontOffset = dot(normal, v11);

    // Side offsets, extended by polytope skin thickness.
    let sideOffset1 =  dot(tangent0, v11) + _totalPoly_PolyRadius;
    let sideOffset2 =  dot(tangent1, v12) + _totalPoly_PolyRadius;

    // Clip incident edge against extruded edge1 side edges.
    let clipPoints1 = [[0,0],[0,0]];
    let clipPoints2 = [[0,0],[0,0]];

    // Clip to box side 1

    if (!clipSegmentToLine(clipPoints1, incidentEdge, tangent0, sideOffset1))
        return false;

    // Clip to negative box side 1

    if (!clipSegmentToLine(clipPoints2, clipPoints1,  tangent1, sideOffset2))
        return false;

    // Now clipPoints2 contains the clipped points.
    localManifold.localNormal = localNormal;
    // localManifold.localPoint  = planePoint;
    localManifold.reference = reference;
    localManifold.incidence = incidence;
    let i;
    for (i = 0; i < phyEngine.setting.b2_maxManifoldPoints; ++i)
    {
        let separation = dot(normal, clipPoints2[i]) - frontOffset;

        let points = localManifold.points;
        if (separation <= _totalPoly_PolyRadius) {

            //TODO: need optimize clipPoints are already in world space
            points.push({localPoint:mulT(incidence.Transform, clipPoints2[i])});
        }

    }
    if(localManifold.points.length == 0)//in some extreme case seperation check doesnt work, we got 0 points
        return false;
    else
        return true;

};


var helper$1 = {collideLineSeg,collideEdge,collideEdgeAndCircle,collideCircles,collideEdgeAndPolygon,collideCircleAndPolygon,collidePolygons};

let Buffer$1 = class Buffer {
    constructor(dynamicTree) {
        this.data = {};
        this.dynamicTree = dynamicTree;
    };

    push(nodeIndexA, nodeIndexB) {
        let proxyA = this.dynamicTree.nodes[nodeIndexA].proxy,
            proxyB = this.dynamicTree.nodes[nodeIndexB].proxy;

        if (proxyA.shape.engineIndex > proxyB.shape.engineIndex) {
            let tmp = proxyA;
            proxyA = proxyB;
            proxyB = tmp;
        }

        const keyName = proxyA.shape.name + ':' + proxyA.proxyIndex + '|' + proxyB.shape.name + ':' + proxyB.proxyIndex;

        if (this.data[keyName])
            return;
        let pair = {nodeIndexA: nodeIndexA, nodeIndexB: nodeIndexB, contactStatus: 0};

        // //if one is passive another is static
        // if(checkStatus((proxyA.shape.status + proxyB.shape.status), (common.setting.STATUS.passive | common.setting.STATUS.static))){
        //     return;
        // }
        //
        // if(checkStatus((proxyA.shape.status + proxyB.shape.status), (common.setting.STATUS.passive + common.setting.STATUS.passive))){
        //     return;
        //     // throw new Error('tow Passives colliding');
        // }

        //if one is passive another is static
        if ((checkStatus(proxyA.shape.status, common.setting.STATUS.passive) && checkStatus(proxyB.shape.status, common.setting.STATUS.static)) ||
            checkStatus(proxyB.shape.status, common.setting.STATUS.passive) && checkStatus(proxyA.shape.status, common.setting.STATUS.static))
            return;

        if (checkStatus(proxyA.shape.status, common.setting.STATUS.passive) && checkStatus(proxyB.shape.status, common.setting.STATUS.passive))
            return;


        if (checkStatus(proxyA.shape.status, common.setting.STATUS.passive) || checkStatus(proxyA.shape.status, common.setting.STATUS.static)) {
            let tmp = proxyA;
            proxyA = proxyB;
            proxyB = tmp;
        }

        if ((engine.shouldCollide &&
            engine.shouldCollide(proxyA.shape.name, proxyB.shape.name,proxyA.shape,proxyB.shape))||

            !engine.shouldCollide) {
            pair.type = proxyA.shape.type + proxyB.shape.type;
            this.data[keyName] = pair;

        }
    };

    // function test (obj){
    //     let r = [];
    //     for(let i in obj)
    //         r.push(i);
    //     return r.join(',');
    // }
    delete(input) {

        let find = [];
        if(typeof input =='string'){
            let regex = new RegExp(input);
            for (let i in this.data)
                if (regex.test(i))
                    find.push(i);
        }else if(input instanceof Object)
            find.push(input);


        for(let key of find){
            if(this.data[key].contact)
                contactManager.deleteContact(this.data[key].contact.manifold.incidence,
                                            this.data[key].contact.manifold.reference);
            // else
            //     contactManager.deleteContactBySearch(input);
            delete this.data[key];
        }

    };





    clear() {
        this.data = {};
    };
};

class CollisionManager {
    constructor(dynamicTree) {
        this.dynamicTree = dynamicTree;
        this.proxyCount = 0;
        this.pairCapacity = 16;
        // this.pairCount = 0;
        this.pairBuffer = new Buffer$1(dynamicTree);

        this.moveCapacity = 16;
        // this.moveCount = 0;
        // this.moveBuffer = [];

    };
    delete() {
        this.pairBuffer.delete();
    };




    pick(pos,radius= 1, Transform,SHAPE_TYPE, dummy = {Transform:new Transform(),MassCenter:pos, Type:SHAPE_TYPE.sphere,Radius:radius},){
        const aabb = [pos[0]-radius,pos[1]-radius, pos[0]+radius,pos[1]+radius],
             proxy = {aabb:aabb,shape:dummy},
            dynamicTree = this.dynamicTree,
            dummyId = dynamicTree.addProxy(proxy),
            pickList = [];
        // engine.add(new Sphere(genRandStr(4), {radius:radius,position:pos,status:SIMOBJ_STATUS.static}));
        dynamicTree.query(dummyId, (nodeId,dummyId)=>{

            const   proxyA = dynamicTree.nodes[nodeId].proxy,
                    proxyB = dynamicTree.nodes[dummyId].proxy,
                    pair = {nodeIndexA:nodeId,nodeIndexB:dummyId, contactStatus:0},
                    type = proxyA.shape.Type+proxyB.shape.Type;
            let solveFnc;
            switch (type){
                case SHAPE_TYPE.edge+SHAPE_TYPE.sphere:
                    solveFnc = helper$1.collideEdgeAndCircle;
                    break;
                case SHAPE_TYPE.sphere+SHAPE_TYPE.sphere:
                    solveFnc = helper$1.collideCircles;
                    break;
                case SHAPE_TYPE.sphere+SHAPE_TYPE.poly:
                    solveFnc = helper$1.collideCircleAndPolygon;
                    break;
                default:
                    throw new Error('unknown pair types');
            }

            let localManifold = {};
            if(solveFnc(dynamicTree,localManifold,pair))
                pickList.push({target:dynamicTree.nodes[nodeId].proxy.shape.Parent,manifold:localManifold});



        });
        dynamicTree.delNode(dummyId);

        return pickList;

    }


    //UpdatePairs
    update(moveInfo) {
        // Reset pair buffer
        // this.pairCount = 0;

        // Perform tree queries for all moving proxies.
        for (let i = 0; i < moveInfo.count; ++i) {
            const queryNodeId = moveInfo.buffer[i];
            if (queryNodeId == null)
                continue;

            //in broadphase
            // Query tree, create pairs and add them pair buffer.
            // this.dynamicTree.query(queryNodeId,function queryCallback(nodeId, queryNodeId) {
            //     this.pairBuffer.push(
            //         Math.min(nodeId, queryNodeId),
            //         Math.max(nodeId, queryNodeId)
            //     );
            // });

            this.dynamicTree.query(queryNodeId, this.queryCallback);
        }

        // destroy contacts that cease to overlap in the broad-phase.
        for (const key in this.pairBuffer.data) {
            const pair = this.pairBuffer.data[key];
            if (!pair.solve) {
                const setting = common.setting;
                switch (pair.type) {
                    case setting.SHAPE_TYPE.edge + setting.SHAPE_TYPE.edge:
                        pair.solve = helper$1.collideEdge;
                        break;
                    case setting.SHAPE_TYPE.edge + setting.SHAPE_TYPE.sphere:
                        pair.solve = helper$1.collideEdgeAndCircle;
                        break;
                    case setting.SHAPE_TYPE.edge + setting.SHAPE_TYPE.poly:
                        pair.solve = helper$1.collideEdgeAndPolygon;
                        break;
                    case setting.SHAPE_TYPE.sphere + setting.SHAPE_TYPE.sphere:
                        pair.solve = helper$1.collideCircles;
                        break;
                    case setting.SHAPE_TYPE.sphere + setting.SHAPE_TYPE.poly:
                        pair.solve = helper$1.collideCircleAndPolygon;
                        break;
                    case setting.SHAPE_TYPE.poly + setting.SHAPE_TYPE.poly:
                        pair.solve = helper$1.collidePolygons;
                        break;
                    default:
                        throw new Error('unknown pair types');
                }

            }

            if (!isAABBOverlap(this.dynamicTree.nodes[pair.nodeIndexA].aabb,
                this.dynamicTree.nodes[pair.nodeIndexB].aabb)) {


                const contact = pair.contact;
                if(contact)
                    contactManager.deleteContact(contact.manifold.incidence,
                                                contact.manifold.reference);


                delete  this.pairBuffer.data[key];
            }

        }

        // contactManager.update(this.pairBuffer.data);
        // Try to keep the tree balanced.
        //m_tree.Rebalance(4);
    };

    queryCallback= (nodeId, queryNodeId)=>{
        this.pairBuffer.push(
            Math.min(nodeId, queryNodeId),
            Math.max(nodeId, queryNodeId)
        );

        return true;
    };

    clear() {
        this.pairBuffer.clear();
    };

}

//devide status code into grp of odds
// 12 --> 4+8
const divStatus = function(status){

    let result = [],exp = Math.floor(Math.log2(status));
    while(true){
        let ele = Math.pow(2,exp);
        result.push(ele);
        status -= ele;
        if(status==0)
            break;
        exp = Math.floor(Math.log2(status));
    }
    return result;
};

class ContactSolver {
    constructor() {
        // this.contactList = [];
        this.velocityContraints = [];
        this.collisionCallbackTable = [];
        this.collisionTable = {};
    };
    delete() {

        this.velocityContraints = [];
        this.collisionCallbackTable = [];
        this.collisionTable = {};
    };
    addContactCallback(cbNm,def){

        if(!def){def = cbNm; cbNm = 'unknown';}

        let typeA = def.typeA,
            typeB = def.typeB,
            callback = def.callback;
        if(!$isNumber(typeA)||!$isNumber(typeB))
            throw new Error('typeA or typeB is missing');

        let typeAGrp = divStatus(typeA),
            typeBGrp = divStatus(typeB);
        if(typeAGrp.length==1 && typeBGrp.length==1)
            this.collisionCallbackTable.push({status:phyEngine.CONTACT_STATUS.init,
                collisionTimes:0,name:cbNm, collisionPair:null,
                type:typeA+typeB,function:callback});
        else {
            for(let typeA of typeAGrp){
                for(let typeB of typeBGrp){
                    if(typeA == typeB)
                        continue;
                    this.collisionCallbackTable.push({status:phyEngine.CONTACT_STATUS.init,
                        collisionTimes:0,name:cbNm, collisionPair:null,
                        type:typeA+typeB,function:callback});
                }
            }
        }
    };

    delContactCallback(nameA,nameB){//TODO:need test
        let type=nameA+nameB,name;
        if(!nameB)
            name = nameA;


        this.collisionCallbackTable.filter((entry)=>{
            if(name)
                return entry.name != name;
            else
                return entry.type != type;
        });
    };
    init(pairBuffer) {
        this.velocityContraints = [];
        // this.positionContraints = [];
        for (let i in pairBuffer) {
            //TODO: track localManifold for warm start
            let localManifold = {},contact,worldManifold,
                incidence = null, reference =null,
                contactPair = pairBuffer[i];

            let isCollide = contactPair.solve(localManifold, contactPair);

            incidence = localManifold.incidence?localManifold.incidence:null,
            reference = localManifold.reference?localManifold.reference:null;

            if (isCollide) {//if collide


                engine.listen(CONTACT_EVT.NewCollisionEvt,{incidence:incidence,reference:reference});



                // if(!checkStatus(incidence.status,common.setting.STATUS.dummy) &&
                //     !checkStatus(reference.status,common.setting.STATUS.dummy)){

                worldManifold   = helper$1.genWorldManifold(localManifold);

                if(!contactPair.contact)
                    contactPair.contact = {};
                contact         = genContact(worldManifold, contactPair);

                contact.manifold = worldManifold;


                if(!checkStatus(incidence.status,phyEngine.setting.STATUS.dummy) &&
                    !checkStatus(reference.status,phyEngine.setting.STATUS.dummy)){
                    let velocityConstraint = genVelocityConstraint(contact);
                    velocityConstraint.manifold = worldManifold;
                    this.velocityContraints.push(velocityConstraint);

                }


                contactPair.contactStatus &= ~phyEngine.CONTACT_STATUS.escape;
                contactPair.contactStatus |= phyEngine.CONTACT_STATUS.touching;

                // if(!engine.name2Type[contact.manifold.reference.name]||
                //     !engine.name2Type[contact.manifold.incidence.name]){
                //     debugger;
                //     throw  new Error('FF');
                // }

                let type =  engine.name2Type[reference.name]+
                            engine.name2Type[incidence.name];


                //TODO:need optimize
                let entries = this.collisionCallbackTable.reduce((acc, ele, i)=>{
                    if (ele.type === type)
                        acc.push(ele);
                    return acc;
                }, []);

                //loop through entries,
                // callback 'common.CONTACT_STATUS.touching' case
                for(let entry of entries){
                    let name;

                    if(entry.status != phyEngine.CONTACT_STATUS.touching){
                        if(entry.function(phyEngine.CONTACT_STATUS.touching,entry.status,
                            incidence,reference,contact,[engine.name2Type[reference.name],engine.name2Type[incidence.name]]))
                            entry.status = phyEngine.CONTACT_STATUS.touching;
                    }

                    if(engine.name2Type[reference.name]<
                        engine.name2Type[incidence.name])
                        name = reference.name+'|'+ incidence.name;
                    else
                        name = incidence.name+'|'+ reference.name;
                    this.collisionTable[name] = type;
                }


            } else {//if not collide



                let contact = contactPair.contact;
                if(contact) {
                    engine.listen(CONTACT_EVT.DeleteCollisionEvt, contact);
                    this.deleteContact(contact.manifold.incidence,contact.manifold.reference);
                }
                contactPair.contactStatus &= ~phyEngine.CONTACT_STATUS.touching;
                contactPair.contactStatus |= phyEngine.CONTACT_STATUS.escape;

            }
        }




        //loop through collisionCallbackTable, check collisionTimes,
        // callback 'common.CONTACT_STATUS.escape' situation
        for(let entry of this.collisionCallbackTable){
            let type = entry.type,
                types = divStatus(type);
            if(entry.status == phyEngine.CONTACT_STATUS.init)
                continue;

            let oldCollisionPair = entry.collisionPair;

            let newCollisionPair = [];
            entry.collisionTimes = 0;
            for(let index in this.collisionTable)
                if(this.collisionTable[index] == type){
                    entry.collisionTimes++;
                    newCollisionPair.push(index);
                }



            if(oldCollisionPair!=null&&
                newCollisionPair.length>0&&oldCollisionPair.length>0&&
                oldCollisionPair.length!= newCollisionPair.length){
                //assign renew state when new contact pair coming
                //entry.status = common.CONTACT_STATUS.renew;

                if(entry.function(phyEngine.CONTACT_STATUS.renew,entry.status,null,null,null,types))
                    entry.status = phyEngine.CONTACT_STATUS.renew;

                entry.collisionPair = newCollisionPair;
            }else if(oldCollisionPair==null)
                entry.collisionPair = newCollisionPair;


            if(entry.collisionTimes == phyEngine.CONTACT_STATUS.init &&
                entry.status != phyEngine.CONTACT_STATUS.escape){
                    if(entry.function(phyEngine.CONTACT_STATUS.escape,entry.status,null,null,null,types))
                        entry.status = phyEngine.CONTACT_STATUS.escape;
            }
        }

    };

    deleteContact(incidence,reference){//TODO: called from collisionManage line 74

        let type = engine.name2Type[reference.name]+
                   engine.name2Type[incidence.name];

        if(this.collisionCallbackTable.find(ele=>{
                return ele.type === type;})
            ){

            let name;
            if(engine.name2Type[reference.name]<
                engine.name2Type[incidence.name])
                name = reference.name+'|'+ incidence.name;
            else
                name = incidence.name+'|'+ reference.name;

            delete this.collisionTable[name];
        }
    };


    deleteContactBySearch(name){
        debugger;
        let types = [];

        for(let i in engine.name2Type)
            if(name != i)
                types.push(engine.name2Type[name]+ engine.name2Type[i]);

        for(let type of types){
            if(this.collisionCallbackTable.find(ele=>{
                return ele.type === type;})
            ){

                let name;
                if(engine.name2Type[reference.name]<
                    engine.name2Type[incidence.name])
                    name = reference.name+'|'+ incidence.name;
                else
                    name = incidence.name+'|'+ reference.name;

                delete this.collisionTable[name];
            }
        }
    };

    warmStart() {
        for (let i in this.velocityContraints) {
            warmStartVelocityConstraint(this.velocityContraints[i]);
        }
    };

    solveVelocity() {
        for (let j in this.velocityContraints)
            SolveVelocityConstraint(this.velocityContraints[j]);


    };

    solvePosition() {

    };


}

const moveInfo = {count: 0, buffer: []};

class ImpulseSolver {
    constructor(name='ImpulseSolver') {

        this.name = name;
        this.isWarmStart = false;
        this.forces = createObjList();
        this.joints = createObjList();
        this.objs = createObjList();


        this.active = true;
        this.dynamicTree = new DynamicTree();

        this.collisionManager = new CollisionManager(this.dynamicTree);
        this.contactManager = new ContactSolver();

    };

    pick(...parmas){
        return this.collisionManager.pick(...parmas);
    };

    delete(){
        this.clear();
        this.collisionManager.delete();
        this.contactManager.delete();


    }

    clear(){

        this.dynamicTree.clear();
        this.forces.clear();
        this.joints.clear();
        this.objs.clear();
    }


    createProxy(proxy, status) {
        if (!this.dynamicTree) throw new Error('DynamicTree is missed');

        let nodeIndex = this.dynamicTree.addProxy(proxy);
        if (common.setting.STATUS.awake & status && common.setting.STATUS.dynamic & status) {
            // this.moveBuffer[moveInfo.count] = nodeIndex;
            moveInfo.buffer[moveInfo.count] = nodeIndex;
            ++moveInfo.count;
        }

        proxy.nodeIndex = nodeIndex;
        return nodeIndex;

    };

    deleteProxy(obj) {
        if (checkStatus$1(obj.status, common.setting.STATUS.dynamic))
            //||common.checkStatus(obj.status, common.setting.STATUS.passive))
            this.delMoveInfo(nodeIndex);

        for(let proxy of obj.shape.proxies){
            this.dynamicTree.delNode(proxy.nodeIndex);
        }

        // try {
        //     this.dynamicTree.removeLeaf(nodeIndex);
        //     this.dynamicTree.freeNode(nodeIndex);
        // } catch (e) {
        //     debugger;
        // }
    };

    rebuildProxy(obj) {


        for (let proxy of obj.shape.proxies) {
            //update AABB
            proxy.aabb = multiply(obj.transform, obj.aabb);
            //del proxy
            this.deleteProxy(obj,proxy.nodeIndex);
            //create proxy
            this.createProxy(proxy, obj.status);
        }

    }

    //MoveProxy
    updateProxy(shape, displacement) {
        for (let proxy of shape.proxies) {
            //Enlarge proxy
            let aabb = proxy.aabb;
            multiply(aabb,shape.transform, shape.Boundary);
            aabb[2] += aabb[0] + common.setting.AABBEXTENSION;
            aabb[3] += aabb[1] + common.setting.AABBEXTENSION;
            aabb[0] -= common.setting.AABBEXTENSION;
            aabb[1] -= common.setting.AABBEXTENSION;


            if (displacement) {
                if (displacement[0] < 0.0)
                    aabb[0] += common.setting.AABBMULTIPLIER * displacement[0];
                else
                    aabb[2] += common.setting.AABBMULTIPLIER * displacement[0];

                if (displacement[1] < 0.0)
                    aabb[1] += common.setting.AABBMULTIPLIER * displacement[1];
                else
                    aabb[3] += common.setting.AABBMULTIPLIER * displacement[1];
            }

            let nodeIndex = proxy.nodeIndex;
            if(nodeIndex == null)
                throw new Error('uninitialized shape proxies');
            //write proxy back
            if (this.dynamicTree.updateProxy(nodeIndex, aabb)&&displacement) {
                this.addMoveInfo(nodeIndex);
            }
        }


    };

    addMoveInfo(nodeIndex) {
        moveInfo.buffer[moveInfo.count] = nodeIndex;
        ++moveInfo.count;
    };

    delMoveInfo(nodeIndex) {
        moveInfo.buffer.find((ele, index)=>{
            if (ele === nodeIndex) {
                moveInfo.buffer.splice(index, 1);
                --moveInfo.count;
            }
            return ele === nodeIndex;
        });

    };

    solve(time, activePool) {


        //forces
        for (let i in this.forces.array)
            this.forces.array[i].apply();


        //update vel
        for (let i in activePool) {
            let obj = activePool[i];
            // if(DEBUGNAME == obj.name)
            //     debugger;
            if (!(obj.status & common.setting.STATUS.static ||// not static neither passive nor graphic
                obj.status & common.setting.STATUS.passive ||
                obj.status & common.setting.STATUS.graphic))
                obj.updateVelocity(time);
        }

        //warm start
        if (this.isWarmStart) {
            this.contactManager.warmStart();
            for (let j in this.joints.array)
                if (this.joints.array[j].status & common.JOINT_STATUS.active)
                    this.joints.array[j].warmStart();
        }


        //solve velocity
        for (let i = 0; i < common.simulation.JOINT_VEL_ITERATION; i++)
            for (let j in this.joints.array)
                if (this.joints.array[j].status & common.JOINT_STATUS.active)
                    this.joints.array[j].solveVelocity(time);

        for (let i = 0; i < common.simulation.VEL_ITERATION; i++)
            this.contactManager.solveVelocity();

        //update pos
        for (let i in activePool) {
            let obj = activePool[i];
            // if(DEBUGNAME == obj.name)
            //     debugger;
            if (!(obj.status & common.setting.STATUS.static ||// not static neither passive nor graphic
                obj.status & common.setting.STATUS.passive ||
                obj.status & common.setting.STATUS.graphic))
                obj.updateLayoutPosition(time);
        }
        //solve position
        if (this.joints.length)
            for (let i = 0; i < common.simulation.JOINT_POS_ITERATION; i++)
                for (let j in this.joints.array)
                    if (this.joints.array[j].status & common.JOINT_STATUS.active)
                        this.joints.array[j].solvePosition();

        for (let i = 0; i < common.simulation.POS_ITERATION; i++)
            this.contactManager.solvePosition();

    }

    update(time) {
         if(!this.active)
             return;

        time = 0.0166666675;
        //apply forces
        for (let i in this.forces)
            this.forces[i].apply();


        let activePool = [];

        try{
            //isolate awake dynObjs
            for (let obj of this.objs){
                //common.setting.STATUS.awake and common.setting.STATUS.dynamic
                if (checkStatus$1(obj.status , (common.setting.STATUS.awake | common.setting.STATUS.dynamic))
                    || obj.status & common.setting.STATUS.passive)
                    activePool.push(obj);
            }
        }catch (e) {
            debugger;
        }
        //query dynamic tree and prepare pairBuffer
        this.collisionManager.update(moveInfo);


        // Reset move buffer
        moveInfo.count = 0;


        // //Test
        // let r = '';
        // for(let i in collisionManager.pairBuffer.data)
        //     r += i;
        //
        // if(window.Test && /0_sphere0/.test(r))
        //     debugger;


        //gen constraints
        this.contactManager.init(this.collisionManager.pairBuffer.data);


        this.solve(time, activePool);


        //update proxy
        for (let i in activePool) {
            let shape = activePool[i],
                displacement = multiply(time, shape.linearVelocity);
            this.updateProxy(shape, displacement);
        }

        // //delete forces
        // for(let i in this.engine.particles)
        //     for(var j =0; j<DIM;j++)
        //         this.engine.particles[i].forceAccumulator[j] = 0;

    };
}

class PaintSolver{
    solver = null;
    shapes = {};
    constructor() {
        this.solver = new ImpulseSolver();
    }

    init(boundaries){
        for(const bound of boundaries){
            this.solver.dynamicTree.addProxy(boundary2AABB(bound));
        }
    }

    pick(boundary){
        const checkerId = this.solver.dynamicTree.addAABB(boundary2AABB(boundary));
        console.log('pick add', checkerId);
        const   collideIdArr = [],
                dynamicTree = this.solver.dynamicTree;
        dynamicTree.query(checkerId, nodeId=>{
            collideIdArr.push(nodeId);
        });

        const shapesArr = Object.entries(this.shapes);

        const collidedBoundaryKeys = collideIdArr.map(nodeId=>{
            const [key, id] = shapesArr.find(([key,value])=>value === nodeId);
            return key;
        });




        // console.log('pick erase', checkerId);
        // const {nodes, nodeCount} = this.solver.dynamicTree;
        // console.log('dynamicTree after',
        //     nodes
        //         .filter(({aabb})=>aabb),
        //     'root',  this.solver.dynamicTree.root);



        dynamicTree.delNode(checkerId);




        // console.log('dynamicTree after',
        //     nodes
        //         .filter(({aabb})=>aabb),
        //     'root',  this.solver.dynamicTree.root);


        return collidedBoundaryKeys
            .map(key=> key.split(',')
                            .map(ele=>Number(ele)));
    }


    addBoundary(boundary){
        const    checkerId = this.solver.dynamicTree.addAABB(boundary2AABB(boundary));



        const   collideIdArr = [],
                dynamicTree = this.solver.dynamicTree;
        dynamicTree.query(checkerId, nodeId=>{
            collideIdArr.push(nodeId);
        });




        const shapesArr = Object.entries(this.shapes);
        const collidedBoundaryKeys = collideIdArr.map(nodeId=>{
            const [key, id] = shapesArr.find(([key,value])=>value === nodeId);
            return key;
        });



        if(collideIdArr.length)
            for(const nodeId of collideIdArr)//del collision
                dynamicTree.delNode(nodeId);


        //del old
        for(const delKey of collidedBoundaryKeys)
            delete this.shapes[delKey];

        //replace new boundary
        this.shapes[boundary.join(',')] = checkerId;


        return collidedBoundaryKeys
            .map(key=> {
                if(!key.split) debugger;

                return key.split(',')
                    .map(ele=>Number(ele))
            });
    }

    removeBoundary(boundary){
        const checkerId = this.solver.dynamicTree.addAABB(boundary2AABB(boundary));

        const   collideIdArr = [],
            dynamicTree = this.solver.dynamicTree;
        dynamicTree.query(checkerId, nodeId=>{
            collideIdArr.push(nodeId);
        });

        const shapesArr = Object.entries(this.shapes);

        const collidedBoundaryKeys = collideIdArr.map(nodeId=>{
            const finder = shapesArr.find(([key,value])=>value === nodeId);
            $assert(finder);
            const [key, id] = finder;
            return key;
        });

        dynamicTree.delNode(checkerId);
        //del old
        for(const delKey of collidedBoundaryKeys)
            delete this.shapes[delKey];

        for(const delID of collideIdArr)
            dynamicTree.delNode(delID);


        return collidedBoundaryKeys
            .map(key=> key.split(',')
                .map(ele=>Number(ele)));

    }




    clear(){
        this.solver.dynamicTree.clear();
    }

}

function catcher$1(job, params) {
    return new Promise(async (res,rej) => {
        let time;
        try {
            time = Date.now();

            let response = await job(...params);
            if(response.result == 'success')
                return res(response.data);
            else
                return rej(response);
        } catch (err) {
            debugger;
            $assert(false, common$1.error.ERR_TYPE.serverErr);

            rej(null);
        } finally {
            // console.log(`${job.name}========================= ${Date.now() - time}`);
        }
    });
}
const
    PREFIX = '/engine',
    FOCUS_SSE_CHANNEL = `${PREFIX}/focusCheckerSSE`,
    GET_CURRENT_STACK = `${PREFIX}/RDhistory`,
    PUSH_TO_CURRENT_STACK = `${PREFIX}/history`,
    SERIALIZE = `${PREFIX}/serialize`,
    SAVE = `${PREFIX}/save`,
    HISTORY_SSE = `${PREFIX}/historySSE`;


// Current Stack API
function _setFocusCheckerSSE(fullPath,onSuccess, onWait, onWaitFinish){
        const url = new URL(FOCUS_SSE_CHANNEL,window.location.href );
        url.searchParams.set('path', fullPath);
        url.searchParams.set('project', window.config['project']);
        url.searchParams.set('deviceID', window.config['deviceID']);

        const evtSource = new EventSource(url);
        // evtSource.onopen = function() {
        //     console.log("Connection to server opened.");
        // };

        evtSource.onmessage = e=>{
            const {result,locker,err} = JSON.parse(e.data);
            if(result == 'fail') {
                $assert(false, {errorType:common$1.error.ERR_TYPE.serverErr});
                evtSource.close();
                debugger;
            }else if(result == 'success'){
                onSuccess();
            }else if(result == 'wait'){
                onWait(locker);
            } else if(result == 'finishWait'){
                evtSource.close();
                onWaitFinish();
            }
        };

        evtSource.onerror = e=>{
            $assert(false,{errorType:common$1.error.ERR_TYPE.serverErr});
        };
        return evtSource;
}




function _getSerializedInfo(projPath = window.config['project']) {

    const url = new URL(SERIALIZE,window.location.href );
    url.searchParams.set('project', projPath);
    return new Promise(async (resolve, reject) => {
        fetch(url, {
            credentials: "same-origin",
            method: "GET",
        })
            .then((response) => response.json())
            .then((data) => resolve(data))
            .catch((err) => reject(err));
    });
}

function _getCurrentStack(startIndex,length,
                         project = window.config['project'],

                         usrName = window.config['usrName'],
                         deviceID = window.config['deviceID']) {

    $assert(project);


    const url = new URL(GET_CURRENT_STACK,window.location.href );
    url.searchParams.set('startIndex', startIndex);
    url.searchParams.set('project', project);
    url.searchParams.set('usrName', usrName);
    url.searchParams.set('deviceID', deviceID);
    if(length)
        url.searchParams.set('length', length);
    return new Promise(async (resolve, reject) => {
        fetch(url, {
            credentials: "same-origin",
            method: "PUT",
        })
            .then((response) => response.json())
            .then((data) => resolve(data))
            .catch((err) => {
                reject(err);
            });
    });
}

function _save(projPath = window.config['project']) {

    $assert(projPath);


    const url = new URL(SAVE,window.location.href );
    url.searchParams.set('project', projPath);
    return new Promise(async (resolve, reject) => {
        fetch(url, {
            credentials: "same-origin",
            method: "PUT",
        })
            .then((response) => response.json())
            .then((data) => resolve(data))
            .catch((err) => {
                reject(err);
            });
    });
}

function _push2CurrentStack(index,cmd,{
                        project = window.config['project'],
                        usrName = window.config['usrName'],
                        deviceID = window.config['deviceID'],
                    }) {
    $assert(cmd);

    const url = new URL(PUSH_TO_CURRENT_STACK,window.location.href );
    url.searchParams.set('project', project);
    url.searchParams.set('usrName', usrName);
    url.searchParams.set('deviceID', deviceID);

    return new Promise((resolve, reject) => {
        fetch(url, {
            credentials: "same-origin",
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
            },
            body: JSON.stringify({cmd,index}),
        })
            .then((response) => response.json())
            .then((data) => resolve(data))
            .catch((err) => reject(err));
    });
}



const    URLS = {FOCUS_SSE_CHANNEL,GET_CURRENT_STACK,PUSH_TO_CURRENT_STACK,SERIALIZE,HISTORY_SSE},
                getCurrentStack = (...params) => catcher$1(_getCurrentStack, params),
                push2CurrentStack =  (...params) => catcher$1(_push2CurrentStack, params),
                getSerializedInfo =  (...params) => catcher$1(_getSerializedInfo, params),
                save =  (...params) => catcher$1(_save, params),
                setFocusCheckerSSE = _setFocusCheckerSSE;

var stack = {getCurrentStack,push2CurrentStack,getSerializedInfo,save,setFocusCheckerSSE};

function getImportPath(url){
    const ref = $parseURL(url);
    let path = '.', file = ref.file;
    if(__root.path !== ref.path){
        path = correctPath(__root.path,ref.path);
    }
    return  `${path}/${file}`;
}

function correctPath(refA,refB){
    const commonPaths = [], paths=[];
    let pathArrayA = refA.split('/'),
        pathArrayB = refB.split('/');
    pathArrayA = pathArrayA.slice(1,pathArrayA.length-1);
    pathArrayB = pathArrayB.slice(1,pathArrayB.length-1);
    for(let i=0;i<pathArrayA.length>pathArrayB.length?pathArrayA.length:pathArrayB.length;i++)
        if(pathArrayA[i]!=pathArrayB[i])
            break;
        else
            commonPaths.push(pathArrayA[i]);

    const diffIndex = commonPaths.length;
    for(let i=pathArrayA.length;i>diffIndex;i--)
        paths.push('..');
    for(let i=diffIndex;i<pathArrayB.length;i++)
        paths.push(pathArrayB[i]);
    return paths.join('/');

}



function unique(arr, condition = (ele, item)=>ele.toString()==item.toString()){

    return arr.filter((item, i, ar) => ar.findIndex(ele=>condition(ele,item)) === i);

}
const
    __src$1 = [], //{url,src,klass, row, col, parentClass:name, interfaces:['',]};
    __src_hierarchy = {};//{parents:['',], interfaces:['',]}

const gWindow = typeof window === "undefined"?global:window;

gWindow.__src = __src$1;
gWindow.__src_hierarchy = __src_hierarchy;
gWindow.getSource = klass =>{
    // for(const [,value] of Object.entries(__src)){
    //     if(value.klass == klass)
    //         return value;
    // }
    return __src$1.filter(ele=>ele.klass == klass);
};
gWindow.getSourceHierarchy = klass =>{
    // for(const [,value] of Object.entries(__src)){
    //     if(value.klass == klass)
    //         return value;
    // }
    return __src_hierarchy[klass];
};
gWindow.getSourceByURL = url =>{

    return __src$1.filter(ele=>ele.url == url);

};

gWindow.getByInterface = _interface=>{
    const infos = Object.entries(__src_hierarchy)
        .filter(([,ele])=>{
            if(typeof _interface === 'string')
                return ele.interfaces.includes(_interface)
            else
                return ele.interfaces.includes(_interface.prototype.constructor.name)

    });
    return infos.map(([klass,])=>klass);
};

gWindow.checkingSrcInterfaces = checkingSrcInterfaces;






function isEmptyFunc(str){
    return !/\{(.|\s)*\S(.|\s)*\}/.test(str);
}




function checkClsName(data, lineNum,colNum){
    const lines = data.split('\n');
    let src = '';

    for(let col = 0; col < colNum; col++) {
        src = lines[lineNum][col];
        if(/implement/.test(src))
            break;
    }

    for(let row = lineNum; row >= 0; row--) {
        let line = '';
        for (let col = row == lineNum?colNum: lines[row].length-1; col >= 0; col--) {
            line = lines[row][col] + line;
            if (/class/.test(line))
                break;
        }
        src = line + ' ' + src;
        if (/class/.test(line))
            break;
    }

    // $assert(/class(.+)extends/.test(src));

    let regRes = /class((.(?!class))+)extends/.exec(src);
    $assert$1(regRes&&regRes[1]);
    if(/(\S)+/.exec(regRes[1])){
        const clsName = /(\S)+/.exec(regRes[1])[0];
        $assert$1(clsName);
        return clsName;
    }

    // else{
    //     const clsName = /var (.+) = class/.exec(lines[lineNum2])[1];
    //
    //     return clsName;
    // }
}








function checkInstanceFncImplement(instance, interfaces){
    $assert$1(getProtoPropertiesFromInstance(instance));
    for(const _interface of interfaces)
        for(let propertyName of Object.getOwnPropertyNames(_interface.prototype)){
            if(propertyName == 'constructor') continue;

            let descriptor = getDescriptor(instance, propertyName);
            let isEmpty = false;
            if(typeof descriptor.value == 'function')
                isEmpty ||= isEmptyFunc(descriptor.value.toString());

            if(descriptor.get)
                isEmpty ||= isEmptyFunc(descriptor.get.toString());


            if(descriptor.set)
                isEmpty ||= isEmptyFunc(descriptor.set.toString());

            if(isEmpty){
                let index = interfaces.findIndex(ele=>new RegExp(propertyName).test(ele.toString()));
                if(index!=-1){
                    console.warn(instance.constructor.name, 'has empty function', propertyName, 'inherited from', interfaces[index].name);
                }
            }

        }
}


const serializeInterface = _=>{
    Object.entries(__src_hierarchy)
        .forEach(([,{interfaces}])=> {
            interfaces.forEach((ele, index) => interfaces[index] = ele.prototype.constructor.name);
        });
};

async function checkingSrcInterfaces(){
    return new Promise(async res=>{

        for (const {url,row,col,interfaces} of __src$1)
            await __fetchAndCheck(url,row,col,interfaces);

        genSrcHierarchy(__src_hierarchy, __src$1);
        serializeInterface();
        res();
    })

}


function genSrcHierarchy(result, src){
    result['Null'] = {parents:[],interfaces:[]};
    Object.entries(src).forEach(([,{klass, parentClass,interfaces}])=>{
        //debugger;
        result[klass] = {parents:[parentClass], interfaces:interfaces.slice()};
    });


    //push 2 parents
    Object.entries(src).forEach(([, {klass,parentClass}])=>{
        Object.entries(result).forEach(([,{parents=[],interfaces}])=>{
            const index = parents.findIndex(ele=>ele == klass);
            if(index == -1) return false; //break;
            parents.splice(index+1, 0 , parentClass);
            if(parentClass == 'Null') return false; //break;
        });


    });
    Object.entries(result).forEach(([klass, {parents, interfaces}])=>{
        for(const parent of parents)
            if(result[parent]&&result[parent].interfaces.length)
                interfaces.push(...result[parent].interfaces.slice());

        //interfaces = interfaces.filter((item, i, ar) => ar.findIndex(ele=>ele.toString()==item.toString()) === i);

        interfaces = unique(interfaces, (ele, item)=>ele.toString()==item.toString());
    });

}
async function __fetchAndCheck(url,row,col,interfaces){

    return new Promise(res=>{

        fetch(url)
            .then(response => response.text())
            .then(src => {
                const klass = checkClsName(src,row,col),
                    srcEle = __src$1.find(ele=>ele.url== url && ele.row == row && ele.col ==col);
                $assert$1(srcEle);
                srcEle['src'] = src;
                srcEle['klass'] = klass;
                const modulePath = getImportPath(url);
                import(modulePath).then( module=>{
                    const cls = module.default&&module.default.prototype.constructor.name == klass?
                        module.default:module[klass];

                    // if(cls.name == 'UIPalette'){
                    //     debugger;
                    //     new cls();
                    // }
                    // if(cls.name == 'UIWindow'){
                    //     debugger;
                    //     new cls();
                    // }


                    try{
                        checkInstanceFncImplement(new cls(), interfaces);
                    }catch (err){
                        //debugger;
                        console.warn(`cannot do checkInstanceFncImplement for ${klass}`,err);
                    }
                    return res();
                });

            }).catch(e=>{debugger});
    })
}
async function download(klass, url){
    const modulePath = getImportPath(url);
    return new Promise((res,rej)=>{
        import(modulePath).then( module=> {
            const cls = module.default&&module.default.prototype.constructor.name == klass?
                module.default:module[klass];
            try{
                return res(cls);
            }catch (err){
                return rej(err);
            }
        });
    });
}

async function classNames2Classes(infos=[]){//[{url,klass}]


    const results = await Promise.all(infos.map(klass=>{
        const result = getSource(klass);
        $assert$1(result.length ==1);
        try{
            return  Promise.resolve(eval(result[0].klass));
        }catch (err){

            return download(klass,result[0].url);
        }
    }));
    return results;
}

function wrtClassInfo(base,interfaces){
    const {url,lineNum, colNum}= $getStackLocationByIndex(-2);

    const info = {url,row:parseInt(lineNum)-1, col:parseInt(colNum)-2, parentClass:base.name, interfaces:interfaces};

    __src$1.push(info);
}

function cpyFromInterface(cls,_interface){
    let clashedProperty = [], clashedStatic = [];

    //static field
    for(let propertyName of Object.getOwnPropertyNames(_interface)) {
        if(propertyName == 'length' || propertyName == 'prototype' || propertyName == 'name') continue;
        const clashed = getDescriptor(cls, propertyName);
        if(clashed)
            clashedStatic.push(propertyName);
    }
    //getters setters and funcs field
    try{
        for(let propertyName of Object.getOwnPropertyNames(_interface.prototype)) {
            if(propertyName == 'constructor') continue;
            const clashed = getDescriptor(cls.prototype, propertyName);
            if(clashed)
                clashedProperty.push(propertyName);
        }}catch (e){debugger;}



    if(clashedProperty.length || clashedStatic.length){
        const stacks = $getStackLocationByIndex(-2);
        if(clashedProperty.length)
            console.warn(stacks,'has clashedProperty:',clashedProperty, 'with interface:', _interface);
        if(clashedStatic.length){
            console.warn(stacks,'has clashedProperty:',clashedStatic, 'with interface:', _interface);
        }
    }


    //static field
    for(let propertyName of Object.getOwnPropertyNames(_interface)) {
        if(propertyName == 'length' || propertyName == 'prototype' || propertyName == 'name') continue;
        try{

            const descriptor = Object.getOwnPropertyDescriptor(_interface,propertyName);
            if(cls[propertyName] && typeof cls[propertyName] == 'object' && typeof descriptor.value == 'object')
                descriptor.value = { ...cls[propertyName], ...descriptor.value};
            Object.defineProperty(cls , propertyName, descriptor);
        }catch (e){debugger;}
    }

    //property
    const properties = Object.getOwnPropertyNames(_interface.prototype);
    for(let propertyName of properties) {
        if(propertyName == 'constructor') continue;
        try{
            if(clashedProperty.includes(propertyName))
                continue;
            const descriptor = Object.getOwnPropertyDescriptor(_interface.prototype,propertyName);
            Object.defineProperty(cls.prototype , propertyName, descriptor);
        }catch (e){debugger;}
    }
    // else
    //     cls = _interface(cls);
    return cls;
}


function Null(){
    return class Null{};
}
const __cpy__ =_=> class extends _{
    constructor(...args) {
        super(...args);
    }
};
function implement(base,...interfaces){
    $assert$1(base);

    for(const val of interfaces)
        $assert$1(val);

    if(base.name.startsWith('I')){ // if cls is interface
        interfaces.unshift(base);
        base = Null();
    }
    // if(!isImplement(base, _interface))
    //     interfaces.unshift(_interface);

    let cls = __cpy__(base);
    Object.defineProperty(cls,'name',{writable:true});
    cls.name = base.name+'|'+interfaces.map(e=>e.name).toString(); //cpy constructor.name, since __cpy__.constructor.name is empty
    Object.defineProperty(cls,'name',{writable:false});

    for(const _interface of interfaces)
        cls = cpyFromInterface(cls,_interface);


    wrtClassInfo(base,interfaces);
    return cls;
}

function getProtoPropertiesFromInstance(proto){
    if(proto == null)
        return null;

    let parentNames = getProtoPropertiesFromInstance(Object.getPrototypeOf(proto));

    let names = parentNames?Object.getOwnPropertyNames(proto):[];
    names = names.concat(parentNames?parentNames.filter(ele=>names.indexOf(ele)==-1):[]);
    return names;
}
function getDescriptor(proto, propertyName){
    const names = Object.getOwnPropertyNames(proto);
    if( names.indexOf(propertyName)!= -1)
        return  {...Object.getOwnPropertyDescriptor(proto, propertyName),
            klass:typeof proto == 'function'?proto.name:proto.constructor.name};

    let parent = Object.getPrototypeOf(proto);
    if(parent == null)
        return null;
    return getDescriptor(parent,propertyName);
}
function getAllDescriptors(out, proto, propertyName){
    const names = Object.getOwnPropertyNames(proto);
    if( names.indexOf(propertyName)!= -1)
        out.push(  {...Object.getOwnPropertyDescriptor(proto, propertyName),
            klass:typeof proto == 'function'?proto.name:proto.constructor.name});

    let parent = Object.getPrototypeOf(proto);
    if(parent == null)
        return null;
    return getAllDescriptors(out, parent,propertyName);
}
function getAllProtos(out,proto){

    let parent = Object.getPrototypeOf(proto);
    if(parent == null)
        return;

    out[parent.constructor.name] = proto;
    getAllProtos(out,parent);

}



function convertTo(instance,classNameStr){
    const result = {};
    getAllProtos(result,instance);
    return result[classNameStr];
}


function isImplement(cls, customInterface) {

    $assert$1(customInterface);
    //isInstance typeof cls == 'object'
    const klass = typeof cls == 'object'?cls.constructor.name:cls.name;
    const src = getSourceHierarchy(klass);
    if(!src)
        return _isImplementing(cls,customInterface);


    return getSourceHierarchy(klass).interfaces.includes(customInterface.prototype.constructor.name);

}


//check on the fly
function _isImplementing(instance,proto){
    let result = true;
    for (let propertyName of Object.getOwnPropertyNames(proto)) {

        if(["constructor"].includes(propertyName))//cls.prototype  dynamic
            continue;

        if(["length", "prototype", "name"].includes(propertyName))//static cls
            continue;

        const interfaceDescriptor = Object.getOwnPropertyDescriptor(proto, propertyName),
            instanceDescriptor =  getDescriptor(instance, propertyName);

        if(instanceDescriptor == null)
            result = false;
        else {
            let isIdentical = true;
            for (let propertyName of Object.getOwnPropertyNames(interfaceDescriptor))
                isIdentical &&=  typeof instanceDescriptor[propertyName] == typeof interfaceDescriptor[propertyName];

            result &&=  isIdentical;
        }

        if(!result)
            break;
    }
    return result
}


function isImplementing(cls, customInterface) {
    $assert$1(cls&&customInterface);

    let isInstance =
            //typeof cls.prototype === 'undefined',
            //typeof cls != 'function'
            // cls.prototype  ==> typeof cls == 'function'
        typeof cls == 'object',
        interfaceStaticCls = customInterface,
        interfaceProto = interfaceStaticCls.prototype, instance;

    if (isInstance)
        instance = cls, cls = Object.getPrototypeOf(instance).constructor;
    else
        instance = new cls();

    return _isImplementing(instance, interfaceProto) && // for dynamic field
        _isImplementing(cls, interfaceStaticCls);//for static field;
}

var interfaces = /*#__PURE__*/Object.freeze({
    __proto__: null,
    Null: Null,
    checkingSrcInterfaces: checkingSrcInterfaces,
    classNames2Classes: classNames2Classes,
    convertTo: convertTo,
    getAllDescriptors: getAllDescriptors,
    getAllProtos: getAllProtos,
    getDescriptor: getDescriptor,
    getImportPath: getImportPath,
    getProtoPropertiesFromInstance: getProtoPropertiesFromInstance,
    implement: implement,
    isImplement: isImplement,
    isImplementing: isImplementing
});

const     _histories = [];

let EventDispatcher$1 = class EventDispatcher{

    static _publishers = [];
    static _subscribers = {};
    static get Publishers (){return EventDispatcher._publishers;}
    static  clear(){
         EventDispatcher._publishers.length = 0;
        // const parmas = Event.Instance.jobs.shift();
        // if(parmas){
        //     await Event.Instance.emit(...parmas);
        // }
    }
    static get Subscribers(){return EventDispatcher._subscribers;}

    static get Histories(){return _histories;}



    static getSubscriberResult(evt, params = {index:0,fnc:null}){
        const
            results = evt.results,
            type = evt.type;
        $assert(type);
        const     evtType =  $match(/^([@]*)(.+)/g,type)[2],
                Subscribers = EventDispatcher.Subscribers[evtType];

        const subs =Subscribers.normalArray;
        $assert(subs);

        const index = params.index?? subs.findIndex(ele=>ele.fnc === params.fnc);

        $assert(index!==-1, `cannot find function of ${params.toString()}`);
        return results[index];
    }


    static async dispatch (evt, type,cmdIndex,publisher,params, timestamp){

        // evt.stillPropagate = true;
        // const cmdIndex = EventDispatcher.Publishers.findIndex(ele=>
        //     ele.type == type &&
        //     ele.timestamp == timestamp&&
        //     ele.params == params
        // );
        $assert(cmdIndex!=-1);
        EventDispatcher.Publishers[cmdIndex];


        const evtType = $match(/^([@]*)(.+)/g,type)[2];
        EventDispatcher.Publishers[cmdIndex].results = [];

        const fncParams = params.slice(),
            emitPub =  EventDispatcher.Publishers[cmdIndex].evt;
        emitPub.results = EventDispatcher.Publishers[cmdIndex].results;
        fncParams.unshift(emitPub);

        $assert(EventDispatcher.Subscribers[evtType]);
        for (let subscriberEntry of EventDispatcher.Subscribers[evtType].normalArray) {

            const   cbFunc = subscriberEntry.fnc,
                    //isDynFnc = isArrowFn(cbFunc),
                    //emitPub = evt,
                    subscriberHashName = subscriberEntry.subscriber?subscriberEntry.subscriber.hashName:null,
                    emitTargetHashName = publisher&&publisher.hashName?publisher.hashName:'',
                    isHashMatching =  subscriberHashName == emitTargetHashName,
            onSubEvtClass = subscriberEntry.evtClass;

            //isDynFnc&&
            if(emitTargetHashName&&subscriberHashName &&!isHashMatching)
                continue;

            if (new onSubEvtClass() instanceof evt.constructor ||
                (onSubEvtClass.name === 'HistoryEvent' && type === common$1.setting.EVT_TYPES.onHistoryStackAdd)) {//if emitPub is base class of subscriber
                $assert(typeof cbFunc === 'function');
                emitPub.subscriber = subscriberEntry.subscriber??null;


                if(isAsyncFn(cbFunc))
                    EventDispatcher.Publishers[cmdIndex].results.push(await cbFunc(...fncParams));
                else {
                    //console.warn(cbFunc, 'is not async function');
                    EventDispatcher.Publishers[cmdIndex].results.push(
                        emitPub.subscriber?
                            cbFunc.call(emitPub.subscriber,...fncParams):cbFunc(...fncParams));
                }
            }
            if (!emitPub.stillPropagate)
                break;
        }
        // EventDispatcher.Publishers.splice(cmdIndex,1);
        if(EventDispatcher.Publishers[cmdIndex].type == common$1.setting.EVT_TYPES.undo){
            if(!(Event.Instance.Mode & Event.MODE.recalling))
                EventDispatcher.Publishers[cmdIndex].status = 'finish';
        }else
            EventDispatcher.Publishers[cmdIndex].status = 'finish';

        // if(!/^[@](.+)/.test(type)) //not start with @



        // const results = EventDispatcher.Publishers[cmdIndex].results;

        if(EventDispatcher.Publishers.reduce((acc,curCMD)=> acc &= curCMD.status == 'finish',true)){
            _histories.push(EventDispatcher.Publishers.slice());

            // evt.Mode &= ~Event.MODE.emitting;

            EventDispatcher.clear();

        }
        return emitPub;
    }
};
if(typeof window !== 'undefined')
window.EventDispatcher = EventDispatcher$1;

// import GUI from "../ui/canvasUI/component/gui.js";
let _instances = {}, _localHistoryStack = new Map(),
     _initIndex = 0,_mode = 0;

const   publishers$1 = EventDispatcher$1.Publishers,
        subscribers = EventDispatcher$1.Subscribers,
     LOCKER_EMIT = `emit.lock`,
     LOCKER_SYNC_FETCH = `sync.lock`;


class EmitPubEvt{
    type = null;
    stillPropagate=null;
    options = null;
    publisher = null;
    subscriber = null;

    get InitIndex(){return _initIndex;}
    constructor(type, options) {
        this.type = type;
        this.options = JSON.parse(JSON.stringify(options));
    }
    stopPropagating(){
        this.stillPropagate =false;
    }

    static clone(type, options){
        return new EmitPubEvt(type, options);
    }
}

let Event$1 = class Event {

    static MODE = {
        // syncing:1,
        subscribing:2,
        uploading:4,
        error:8,
        // emitting:16,
        batchEmitting:32,
        recalling:128,
        replay:256,
    }

    get EventDispatcher(){return EventDispatcher$1;}
    //$fileBlob2Base64 wrt blob into history
    async serialize(data = this.History){
        const result = [];
        for(const cmd of data){
            const cpyCMD = {};
            cpyCMD.type = cmd.type;
            cpyCMD.params = cmd.params;
            cpyCMD.index = cmd.index;
            cpyCMD.timestamp = cmd.timestamp;

            // if(cpyCMD.type == common.setting.EVT_TYPES.createFile){
            //     const uint8 = cpyCMD.params[1];
            //     // $assert(uint8 instanceof Uint8Array);
            //     if(uint8)
            //         cpyCMD.params[1] = await $fileBlob2Base64(uint8);
            // }
            result.push(cpyCMD);
        }
        return result;
    }


    //$base64ToFileBlob rd blob from history
    desearialize(history){
        const result = [];

        for(const cmd of history){
            const cpyCMD = {};
            cpyCMD.type = cmd.type;
            cpyCMD.params = cmd.params;
            cpyCMD.index = cmd.index;
            cpyCMD.timestamp = cmd.timestamp;

            // if(cpyCMD.type == common.setting.EVT_TYPES.createFile){
            //     const base64 = cpyCMD.params[1],
            //             isBase64 = typeof base64 != 'object' ;
            //     if(isBase64)
            //         cpyCMD.params[1] = await $base64ToFileBlob(base64);
            // }
            result.push(cpyCMD);
        }
        return result;
    }

    async save(mode = 'history', fileName='unnamed'){

        if(mode === 'history')
            return downloadURL(JSON.stringify({history:Array.from(_localHistoryStack.values())}),`${fileName}.keanu`);

        else if(mode ==='files')
            return downloadURL(JSON.stringify({files:$wrtFiles()}), `${fileName}.keanu`);

    }

    get Mode() {
        return _mode;
    }

    async startRecalling(){
        const emitPubEvt = await this.emit(common$1.setting.EVT_TYPES.onRecallingStart,{timestamp:this.options.timestamp});
        return emitPubEvt.stillPropagate;
    }
    async endRecalling(){
        $assert(publishers$1.length);

        const cmdList = publishers$1.slice().reverse(),
            lastRecallIndex = cmdList.findIndex(ele=>
                ele.type.match(/^[@]*(.+)/)[1]  == common$1.setting.EVT_TYPES.undo||
                ele.type.match(/^[@]*(.+)/)[1]  == common$1.setting.EVT_TYPES.redo);
        $assert(lastRecallIndex!=-1);
        const currentIndex = cmdList[lastRecallIndex].results[0];
        console.log(currentIndex,cmdList[lastRecallIndex],lastRecallIndex);
        $assert($isNumber$1(currentIndex));
        const {results} = await this.emit(common$1.setting.EVT_TYPES.onRecallingEnd,[currentIndex], {timestamp:this.options.timestamp});


        const arr =  Array.from(_localHistoryStack,  entry=> {return { key: entry[0], value: entry[1] }}),
                filteredArr =  arr.filter(ele=>ele.key<results[0]);

        _localHistoryStack = new Map(filteredArr.map((key,value) => [key,value]));

        this.Mode &= ~Event.MODE.recalling;


        EventDispatcher$1.clear();
        return true;
    }

    set Mode(value){


        // if(value & Event.MODE.emitting){
        //      //freeze
        //     if(KeyBoardHanlder.instance.Mode & KeyBoardHanlder.MODE.listening)
        //         KeyBoardHanlder.instance.Mode &= ~KeyBoardHanlder.MODE.listening;
        //
        //     // for(const editor of Keanu.editors.array)
        //     //     editor.Controller.Status &= ~Controller.STATUS.active;
        //
        // }else if(_mode & Event.MODE.emitting && !(value & Event.MODE.emitting)){
        //
        //     //unfreeze
        //     if(!(KeyBoardHanlder.instance.Mode & KeyBoardHanlder.MODE.listening))
        //         KeyBoardHanlder.instance.Mode |= KeyBoardHanlder.MODE.listening;
        //
        //     // for(const editor of Keanu.editors.array)
        //     //     editor.Controller.Status |= Controller.STATUS.active;
        //
        // }

        _mode = value;
    }
    static get Instance(){
        const klass = this.prototype.constructor.name;
        if(!_instances[klass])
            _instances[klass] = new this.prototype.constructor();
        return _instances[klass];
    };


    get History (){
        return _localHistoryStack;
    }

    get HistoryIndex(){

        const arr = Array.from(_localHistoryStack.values()),
            lastIndex = arr.length?arr.length-1:this.InitIndex-1;
        return lastIndex;

    }

    set InitIndex(value){
        _initIndex=value;
    }
    get InitIndex(){return _initIndex;}

    clear(){
        _localHistoryStack = new Map();
         _initIndex = 0;_mode = 0;
        return cancel(LOCKER_EMIT);
    }
    async initialize(historyStack,offsetIndex = _initIndex){
        this.options = {writeHistory:null,upload:null};
       await $refreshAllBegin();
        await $batchEmit(historyStack,{
            writeHistory: false,
            upload: false,
            internal:true,
        });
        await  $refreshAllEnd();
        _initIndex += historyStack.length;
    }


    async recall(){
        //TODO: check MD5 of CS, localStack compares serverStack

        //TODO: check if can be recalled, render gray in History Editor



        return this.delIndice;

    }


    //timer = {current:, index:}
    replayHistory(timer, stackHistory, params= {writeHistory:true, upload:false,internal:false}) {




        return new Promise(async (resolve,reject)=>{

            const jobs = this.desearialize(stackHistory);
            const writeHistory = params.writeHistory??true,
                upload = params.upload??false,
                internal = params.internal??false;



            const startJobTime = parseInt(jobs[0].timestamp,16),
                    elapseTime = timer.current*1000;
            for(let i= timer.index; i<jobs.length;i++){
                const cmd = jobs[i];
                $assert(cmd&&$isNumber$1(cmd.index));
                const curJobTime = parseInt(cmd.timestamp,16),
                    elapseJobTime = curJobTime- startJobTime;

                if(elapseJobTime<=elapseTime){

                    timer.index++;
                    await this.emit(
                        internal?'@'+cmd.type:cmd.type,

                        cmd.params, {
                            writeHistory,//cmd.usrName == window.config.usrName?false:true,
                            index:cmd.index,
                            upload: upload,
                            timestamp: cmd.timestamp
                        });
                }

            }

            return resolve();
        })

    }




    subscribeSSE(){
        if(this.Mode & Event.MODE.subscribing)
            return;

        const

            url = new URL(URLS.HISTORY_SSE,window.location.href );
        url.searchParams.set('project', window.config['project']);
        url.searchParams.set('usrName', window.config['usrName']);
        url.searchParams.set('deviceID', window.config['deviceID']);

        const evtSource = new EventSource(url);

        this.Mode |= Event.MODE.subscribing;

        evtSource.onmessage = async e=>{
            if(window.testMsg == true) return;
            const {result,cmd,index, device} = JSON.parse(e.data);

            $assert(result != 'fail', {path:null,errorType:common$1.error.ERR_TYPE.serverErr});

            const nextIndex  = this.HistoryIndex+1,
                isNext = nextIndex == index,
                needsSync = nextIndex<index;

            if(!checkValid(LOCKER_SYNC_FETCH) ||
                !checkValid(LOCKER_EMIT) ||
                !checkValid(ROOT_LOCKER_EMIT)) return;


            if(isNext){
                await this.emit(cmd.type, cmd.params,{writeHistory:true,upload:false,timestamp:cmd.timestamp,index,device});
            }else if(needsSync){
                await this.sync();
            }

        };

        evtSource.onerror = e=>{
            //  this.Mode &= ~Event.MODE.subscribing;
            $assert(false, {msg:'SSE error',path:null,errorType:common$1.error.ERR_TYPE.serverErr});
        };
    }



    delete(){



    }



    exist(evtType){
        if(!(subscribers[evtType]&&subscribers[evtType].normalArray.length))
            return false;

        for(let sub of subscribers[evtType].normalArray)
            if(sub.evtClass.name == this.constructor.name)
                return true;

        return false;
    }
    on(type, fnc, params = {subscriber:{hashName:'',index:-1}}, _uniqueSkip = false){
        let index = null;
        if($isNumber$1(params))
            index = Number(params);
        else if($isNumber$1(params.index))
            index = Number(params.index);

        $assert(type);
        const subscriber = params.subscriber?? null;

        // const subscriberHashName =  subscriber? subscriber.hashName:null;

        let evtType = $match(/^@(.+)/g,type)[1]??type;

        if(!subscribers[evtType])
            subscribers[evtType] = new NegArray();

        // const {url,lineNum,colNum} = $getStackLocationByIndex(-1),
        //     row = lineNum,col = colNum,
        const fncName = fnc.name,
            subscriberEntry = {evtClass:this.constructor, fncName,fnc,subscriber};//url,row,col
        if(_uniqueSkip){//check redundant
            $assert(subscriber == null,{
                errorType:common$1.error.ERR_TYPE.internalErr,
                msg:`subscriber has to be null`,
            });
            if(subscribers[evtType].exist(
                ({evtClass, fncName, fnc, })=> //url,row, col
                    subscriberEntry.evtClass.name === this.constructor.name &&
                    subscriberEntry.fncName === fncName&&
                    subscriberEntry.fnc.toString() === fnc.toString()
                    // &&
                    // subscriberEntry.url == url&&
                    // subscriberEntry.row == row&&
                    // subscriberEntry.col == col
            ))
                return;
        }else {//static function

            $assert(subscriber,{
                errorType:common$1.error.ERR_TYPE.internalErr,
                msg:`subscriber is missing`,
            });
            $assert(typeof subscriber.hashName == 'string');
            $assert(!( subscriber.Status & common$1.setting.STATUS.deleting));
        }


        if($isNumber$1(index)){
            subscribers[evtType].insert(index, subscriberEntry);
        }else
            subscribers[evtType].push(subscriberEntry);
    }
    
    //can be called multiple times, but  only regist&execute  once
    onUnicon(type, fnc, params = {}){
        // $assert(!isArrowFn(fnc), {
        //     errorType:common.error.ERR_TYPE.internalErr,
        //     msg:`fnc cannot be arrow function`,
        // });
        this.on(type, fnc, params, true);
    }

    onOnce(type, fnc, params = {}){


        this.on(type, fnc, params, true);
        this.remove(type,fnc,params);
    }

    remove(evtType, fnc = null, params = null){
        if(typeof evtType == 'function'){
            fnc = evtType;
            for(const [evtType, {normalArray}] of Object.entries(subscribers)){
                if(normalArray.find(ele=>ele.fnc == fnc)){
                    // subscribers[evtType] = normalArray.filter(ele=>!(ele.fnc  == fnc));

                    subscribers[evtType].remove(ele=>ele.fnc  == fnc);
                }
            }
        }else if(typeof evtType == 'object'){
            params = evtType;
            for(const [evtType, {normalArray}] of Object.entries(subscribers)){
                if(!(normalArray))
                    debugger;
                if(normalArray.find(ele=>ele.subscriberHashName == params.subscriber.hashName)){

                    subscribers[evtType].remove(ele=>ele.subscriberHashName == params.subscriber.hashName);
                }
            }
        }else if(subscribers[evtType]){

            subscribers[evtType] =

                subscribers[evtType].remove(ele=>{
                    if( fnc && params && params.subscriber && params.subscriber.hashName)
                        return ele.fnc == fnc && params.subscriber.hashName == ele.subscriberHashName;
                    else if(fnc)
                        return ele.fnc == fnc;
                    else if(params && params.subscriber && params.subscriber.hashName)
                        return params.subscriber.hashName == ele.subscriberHashName;
                });

        }else
            $assert(false,{errorType:common$1.error.ERR_TYPE.internalErr, msg:'invalid function params'});

    }

    async add(cmd, index){

        _localHistoryStack.set(index,cmd);
        cmd.index = index;
        await this.emit(common$1.setting.EVT_TYPES.onHistoryStackAdd, [index,cmd]);
    }

    exist(index){
        return _localHistoryStack[index]?true:false;
    }

    prepareRecall(){

        //usr
        //_localHistoryStack
        const recallableIndice = [];
                window.config.usrName;
                const stack = _localHistoryStack;

        for(let i = stack.length-1;i>=0;i--)
            recallableIndice.push(i);
        return recallableIndice;

    }
    async write(cmd, upload,options){
        let index = null;

        if (upload) {


            $assert(!cmd.type.startsWith('@'));

            const data = await window.setting.Stack.push2CurrentStack(this.HistoryIndex,cmd,options)
                .catch(err => {
                    //this.Mode |= Event.MODE.error;
                    // new Error(err);
                    $assert(false,{msg:'network err'});
                });
            index = data.index;
            const history = data.history;
            if(history&&history.length)
                return history;
        }else
            index = this.HistoryIndex+1;


        await this.add(cmd,index);
        return [];

    }
    async sync(){
        console.log('=============================SYNC start');

        const startIndex = this.HistoryIndex+1,
            release = await lock$1(LOCKER_SYNC_FETCH);
            // LOCKER_SYNC_FETCH protecting following getCurrentStack  run repeatedly


        const {history}= await window.setting.Stack.getCurrentStack(startIndex).catch(err => $assert(false,{msg:'network err'}));



        await $batchEmit(history,{
            writeHistory: true,
            upload: false,
            internal:false,
            fastRewind: false
        });  console.log('=============================SYNC end');

        return release();

    }

    //The Async Await Episode I Promised
    // https://www.youtube.com/watch?v=vn3tm0quoqE
    async emit(type,publisher , paramArr, opt){

        $assert(type);
        if(publisher === undefined)
            publisher = null;
        if(paramArr === undefined)
            paramArr = [];
        if(opt === undefined)
            opt = {};


        if(Array.isArray(publisher))//no publisher
            opt = paramArr, paramArr = publisher, publisher = null;
        else if(!Array.isArray(paramArr))//no paramArr
            opt = paramArr, paramArr = [];
        else if(publisher&&publisher.hashName === undefined)
            opt = publisher, publisher = null;




        if(publisher){
            $assert(publisher.hashName);
            $assert(publisher instanceof Base || isImplement(publisher, IWindow) ,
                {errorType:common$1.error.ERR_TYPE.internalErr,
                    msg:`${this.name} event publisher must be valid component`
                });
        }






        //^@(.+)  internal
        //^#(.+)  menu
        //^%(.+)  GUI
        let isInternalCMD = /^@(.+)/.test(type),
                isGUICMD = /^%(.+)/.test(type);


        let  release =_=>{};


        if(checkValid(ROOT_LOCKER_EMIT) === false&&!(this.Mode & Event.MODE.batchEmitting)){ //when NOT run by batch
            debugger;
            return console.warn('==========batchEmitting escape',paramArr, checkValid(ROOT_LOCKER_EMIT) === false, !(this.Mode & Event.MODE.batchEmitting));
        }

        const isOnSync = $isNumber$1(opt.index),
                escapeOldCMD = isOnSync && opt.index<this.HistoryIndex;
        if(escapeOldCMD)
            return console.log('==========escapeOldCMD');

        // if(!isInternalCMD || type ==='@onInitialized')
        if((!isInternalCMD || type ==='@onInitialized') && !isGUICMD)
            release = await lock$1(LOCKER_EMIT, JSON.stringify(paramArr));

        let evtType = type;
        if(isInternalCMD){
            evtType = $match(/^@(.+)/g,type)[1]??type;
        }else {

            const alreadyExternal =  publishers$1.reduce((acc,curCMD)=>{
                    const isExternalCMD = !(/^@(.+)/.test(curCMD.type)) && !(/^#(.+)/.test(curCMD.type));
                    return acc |= isExternalCMD;
                },false),

                keepUndo = type == common$1.setting.EVT_TYPES.undo &&
                    publishers$1.findIndex(ele=>ele.type == common$1.setting.EVT_TYPES.undo) != -1,

                finishUndo = this.Mode & Event.MODE.recalling && !isInternalCMD;


            if(keepUndo) {
                type = '@'+common$1.setting.EVT_TYPES.undo;//`@${type}`;
            }else  if(finishUndo){
                await this.endRecalling();
            }
            else if(alreadyExternal && !isInternalCMD) {

                if(isGUICMD)
                    isInternalCMD = true;
                else if(publishers$1[0].type == 'onInitialized'){
                    release();
                    return;
                }else  //GANGAN
                    debugger;

            }

        }


        let options = {
            sync: opt.sync??false,
            writeHistory: opt.writeHistory??true,
            upload: opt.upload??window.config.stack?true:false,
            timestamp:opt.timestamp ?? Date.now().toString(16),
            index:opt.index??null,
            device:opt.device??`${window.config['usrName']}-${window.config['deviceID']}`,
            project:opt.project??window.config['project'],
            usrName:opt.usrName??window.config['usrName'],
            deviceID:opt.usrName??window.config['deviceID'],
        };

        $assert(options.device);

        if (!subscribers[evtType]) {
            //console.warn(evtType + ' no such a evt handler exist');
            release();
            return;
        }

        if(isInternalCMD)
            options['writeHistory'] = false;

        if(isGUICMD){
            if(window.config['record'])
                options['writeHistory'] = true;
            else
                options['writeHistory'] = false;
        }

        this.options = {...options};
        const {timestamp, sync, writeHistory, upload, index} = this.options;





        if(evtType == common$1.setting.EVT_TYPES.undo&& !(this.Mode & Event.MODE.recalling))
            if(await this.startRecalling())
                this.Mode |= Event.MODE.recalling;
            else {
                console.warn('onRecallingStart failed, cannot start undo');

                // this.Mode &= ~Event.MODE.emitting;
                release();
                return;
            }


        if(evtType == common$1.setting.EVT_TYPES.redo&& !(this.Mode & Event.MODE.recalling)){
            // this.Mode &= ~Event.MODE.emitting;
            release();
            return;
        }


        const emitEvt = EmitPubEvt.clone(type,this.options);
        emitEvt.stillPropagate = true;
        emitEvt.type = type;
        emitEvt.publisher = publisher;



        const cmdIndex = publishers$1.length,
             curCMD= {type, params:paramArr, timestamp};//sync:sync,


        if (writeHistory) {


            if($isNumber$1(options.index) && options.index <= this.HistoryIndex)
                return release();


            const history = await this.write(curCMD,upload, options);

            if(history.length) {
                release();
                console.log('=============================CATHCUP start');

                await $batchEmit(
                    history,
                    {writeHistory:true, upload:false,internal:false,fastRewind: false});
                return console.log('=============================CATHCUP end');
            }
        }


        publishers$1.push({type,evt:emitEvt,params:paramArr, timestamp, status : 'pending'});


        const catcher = err=>{
            const
                path = err.path??null,
                msg = err.msg??'event.js dispatch internal error';
            if(!path){
                $assert(false, {path,errorType:common$1.error.ERR_TYPE.internalErr,
                    msg,data:{publisher:publishers$1,stack:err.stack}});
                return Promise.reject(err);
            }
        };
        // this.Mode |= Event.MODE.emitting;
        // https://www.youtube.com/watch?v=vn3tm0quoqE
        if(sync) {//
            const res = await EventDispatcher$1.dispatch(this,type,cmdIndex,publisher, paramArr,timestamp).catch(e=>catcher(e));
            release();
            return res;
        }
        else//queueMicrotask
            return Promise.resolve().then(_=>EventDispatcher$1.dispatch(this,type,cmdIndex,publisher,paramArr,timestamp))
                                .then(res=>{
                                    release();
                                    return res;
                                })
                                .catch(e=>catcher(e));


    }


    // jobs = [];
    // emitNext(...params){
    //     this.jobs.push(params);
    // }

};
if(typeof window !== 'undefined')
window.Event = Event$1;

const __isNode$1 = typeof process != 'undefined';
const MODE$2 = {
    development: 1, hosting: 2, react: 4, keanuEngine: 8,
    s3: 16, cos: 32, awsRedis: 64, localStack: 128, localRedis: 256, testing: 512,
    backend: 1024,
    frontend:2048,
    swagger:4096
};


const getDevMode = function (mode, modeENum = __mode) {
    return !!(modeENum & mode);
};



let __store ;
let __mode = MODE$2.s3;

const __init_s3 = async function(){
    let Storage;
    if(getDevMode(MODE$2.s3)){
        if(__isNode$1){
            Storage = (await import(process.env.S3SINGLETON_PATH)).default;
            __store = (new Storage({mode:Storage.MODE.backend }));//mode:Storage.MODE.frontend|Storage.MODE.test
        }else {

            if(!S3Singleton) throw new Error('s3-browser is missing');
            Storage = S3Singleton;
            __store = (new Storage({url:'/api/sts'}));
        }



    }
};

__init_s3();




const __data = new Map();
__data.project = null;


let __files =  null;

const $projID2Path = (project)=>{
    const [usr,projNm] = project.split('-');
    return `${usr}/${projNm}/${projNm}.keanu`;
};

function __initHeadlessFiles( files, updateTime){
    $assert(__data.project);
    const projFile = files.find(({path}) => path === $projID2Path(__data.project));
    projFile.id = '{root}';
    Object.entries(projFile.data['.files'])
        .forEach(([path, id])=> files.find(ele=>ele.path===path).id=id);


    const data = __data.get(__data.project);
    data.files = new Map(files
        .map(ele=>[ele.id, ele]));


    return Promise.resolve();
}

function $loadProcess(){

    const data = __data.get(__data.project);
    data.files.forEach(({path,data})=>$processFiles(path));

}
function _loadPalette(palettePath){
    const data = $getAttr$1(palettePath);
    for(const [key, {boundary}] of Object.entries(data['.contents'])){
        const [col, row] = key.split(',').map(ele=>parseInt(ele));
        addByPaintSolver($path2ID(palettePath), [col,row,boundary[2],boundary[2]]);
    }
}
function _loadTBr(nakedPath){
    const tileBrData = $updateAttr(nakedPath);

    if(!tileBrData) return;

    $assert(tileBrData &&
        (FileExt2Meta[$readPath(nakedPath).fileExt] & FILE_TYPES.tileBrush));


    // const imgEntry = $getFile(tileBrData['source']);
    if(!$isPathID(tileBrData['source']))return ;

    const imgData =  $getAttr$1(tileBrData['source']),//imgEntry.EntryData;
        cellSize = $readFileDataValue(`${nakedPath}|cellSize`),
        offset = $readFileDataValue(`${nakedPath}|offset`),
        padding = $readFileDataValue(`${nakedPath}|padding`);



    const rawImg = document.createElement("canvas");

    const params = [];
    let maxX = 0, maxY = 0;
    // for(const {index} of group){

    for (let col = 0; col < Math.floor(imgData.width/cellSize); col++) {

        for(let row =0; row<Math.floor(imgData.height/cellSize); row++){
            let x = offset[0] + col * cellSize, y = offset[1] + row * cellSize;
            if (col > 0)
                x += col * padding[0];

            if (row > 0)
                y += row * padding[1];
            const param = [x, y, cellSize, cellSize, col * cellSize, row * cellSize, cellSize, cellSize];
            maxX = Math.max(param[4] + cellSize);
            maxY = Math.max(param[5] + cellSize);
            params.push(param);
        }
    }
    rawImg.width = maxX;
    rawImg.height = maxY;
    for(const param of params)
        $imgCropBlend(rawImg, imgData, ...param);
    tileBrData['~rawImg'] = rawImg;
}
function $processFiles(nakedPath){
    switch (FileExt2Meta[$readPath(nakedPath).fileExt]){
        case FILE_TYPES.tileBrush:
            _loadTBr(nakedPath);
            break;
        case FILE_TYPES.palette:
            _loadPalette(nakedPath);
            break;

    }


}
function $createFileID() {
    if (isNode$1)
        return `{${$genID()}}`;

    const generatedIds = $getAttr$1(`${$getKeanuPath()}|.assets`);
    return `{${$genID(generatedIds)}}`;
}
function $wrtFiles(){
    const result = [],
        files = Array.from(__files??[], ([,value])=>value);
    for(let {id,path,data} of files){
        if( data.constructor.name === 'HTMLCanvasElement')
            data = data.toDataURL();
        else if(data.constructor.name === 'HTMLImageElement')
            data = $img2Base64(data);
        else  if(data.constructor.name === 'Object')
            data = JSON.parse(JSON.stringify(data));
        result.push({id,path,data});
    }
    return result;
}

function __init_data(projID, files, updateTime){
    __initHeadlessFiles(files);
    __files = __data.get(__data.project).files;
}

const _parseDataFrontend = async (path,fileBlob)=> {
    let fileData;
    const type = FileExt2Meta[$readPath(path).fileExt];
    switch (type) {
        case FILE_TYPES.image:

            fileData = await file2Img(fileBlob);
            break;

        case FILE_TYPES.js:

            fileData = await readAsText(fileBlob);
            break;
        default:
            fileData = JSON.parse(await readAsText(fileBlob));
            $assert(fileData);
            break;
    }
    return Promise.resolve(fileData);
};


const _parseDataBackend = (path,buffer)=> {
    let fileData;
    const type = FileExt2Meta[$readPath(path).fileExt];
    switch (type) {
        case FILE_TYPES.image:

            fileData = buffer;
            break;

        // case FILE_TYPES.js:
        //
        //     fileData = await readAsText(fileBlob);
        //     break;
        default:
            fileData = JSON.parse(buffer);
            break;
    }
    return Promise.resolve(fileData);
};

function $download(files){
    const jobDownload = [];
    files.forEach(({path,version})=>jobDownload.push([path, version]));
    //jobDownload.push(downloadFile(editor,path, version)));//
    return $exeSequential(jobDownload,
        (path,version)=>
            __store.downloadFile(__data.project, {path, version}, (url,{percent,loaded,speed,total} )=>console.log(url,percent))
                .then((fileBlob)=>{
                    if(__isNode$1)
                        return _parseDataBackend(path, fileBlob);
                    else
                        return _parseDataFrontend(path,fileBlob);

                })
                .then(data=>files.find(file=>file.path === path).data = data));
}

function base64ToCanvas(base64){
    return $base64ToFileBlob(base64).then(file=>file2Img(file))
}

function $projBegin(projectID, files = [], updateTime = Date.now()) {

    __data.project = projectID;
    __data.set(projectID, {updateTime, state:HEADLESS_FILE_STATE.init, files:null});
    return lock$1(`${projectID}-lock`)
        .then(async release=>{
            __data.get(projectID).state |= HEADLESS_FILE_STATE.lock;
            __data.get(projectID).locker  = {release};

            for(const file of files.filter(({data})=>typeof data === 'string'))
                file.data = await base64ToCanvas(file.data);

            return Promise.resolve();

        })
        .then(_=> __init_data(projectID, files))
}
function $getKeanuPath() {
    if (isNode$1) {
        const [usrName, projName] = __data.project.split('-');
        return `${usrName}/${projName}/${projName}.keanu`;
    } else
        return window.config['projPath'];
}
function $projEnd(projectID = __data.project){


    if(__data.project === null) return;


    const projFile = Array.from(__files.values()).find(({path}) => path === $projID2Path(__data.project));
    projFile.data['.files'] = {};
    Array.from(__files.values()).filter(({id})=>id!=='{root}')
        .forEach(({path,id})=>projFile.data['.files'][path] = id);

    __data.project = null;
    __files = null;

    $assert(__data.get(projectID));
    const release = __data.get(projectID).locker.release;
    $assert(release);
    release();
    __data.get(projectID).state &= ~HEADLESS_FILE_STATE.lock;
}


function $projAddFile(id,path, data, version) {
    $assert(path);

    __files.set(id, {id,path,data,version});
    return $setKeanuFileAssets(id);
}

function $projDelFile(input){

    const sourceIsNullList = [];
    const delList = $getFiles$1(input);
    //check subFolder
    for (const {path} of delList) {

        const nullList = _cleanProjAssetRefers(path)
            .filter(id => !delList.find(ele =>{
                $assert($readPath(id));
                return  $readPath(id).nakedPath === ele.path;
            }));
        sourceIsNullList.push(...nullList); //filter out deleted item
    }
    for (const fullPath of sourceIsNullList)
        _cleanAttr(fullPath);

    for (const {path} of delList)
        __files.delete($path2ID(path));

    return sourceIsNullList;
}

function $projRenameFile(id,path){
    const file = __files.get(id);
    file.path = path;
}
let __paintSolvers = {};
function clearPaintSolver(){
    __paintSolvers = {};
}

queueMicrotask(_=>Event$1.Instance.onUnicon(common$1.setting.EVT_TYPES.onClear,clearPaintSolver));

function __getSolver(path){
    if(__paintSolvers[path] === undefined)
        __paintSolvers[path] = new PaintSolver();
    return __paintSolvers[path];
}

function addByPaintSolver(path, boundary){
    return __getSolver(path).addBoundary(boundary);
}

function removeByPaintSolver(path, boundary){
    return __getSolver(path).removeBoundary(boundary);

}


function $pickByPaintSolver(path,boundary){
    return __getSolver(path).pick(boundary);
}





const _getFileEntryByPath = function (path) {
    $assert(typeof path === 'string' || path === null);
    const root = window.Keanu.editors.objs['Outline'] ? window.Keanu.editors.objs['Outline'].Content : window.Keanu.editors.objs['Resource'].Content;

    if (path === null)
        return null;

    $assert(path.split);
    path = path.split('|')[0];
    $assert(root);

    let stack = $match(/[^\/]+/gm, path),
        curName, curEle = root;
    while (curName = stack.shift()) {
        const children = curEle.getConnection(ConnectionType.outputs, 'children');
        curEle = children.find(ele => ele.EntryFileName === curName);
        if (!curEle)
            return null;
    }
    return curEle;
};

const $getFileEntry = (input) => {
    $assert(typeof input === 'string' || input === null);
    return $isPath(input) ? _getFileEntryByPath(input) : _getFileEntryByPath($readPath(input).nakedPath);
};

const $isOulineExist=_=>{
    return window.config.outline || window.config.resource;
};









// export function $setFileData(path, value) {
//
//     if (!path) path = $getKeanuPath();
//     const
//         {nakedPath, attrKeys} = $readPath(path),
//         [file] = $getFiles(nakedPath);
//     $assert(file);
//
//     const data = file.data;
//     $assert(data);
//
//     if (attrKeys.length == 0)
//         return data;
//
//
//     return $setJSONData(data, attrKeys, value);
//
// }







// function _updateProjAssets( oldPath, newPath){
//     const updatedAssets = [];
//     const projData = $checkoutFile($getKeanuPath());
//
//     for(const dataIndex in projData['.assets']){
//
//         const
//             asset = projData['.assets'][dataIndex],
//             newData = JSON.parse(JSON.stringify(asset)),
//             isFolder = $readPath(oldPath).fileExt == null;
//         let isAssetPathNeedsUpdate = oldPath == asset['.path'];
//
//         if(isFolder)
//             isAssetPathNeedsUpdate |= new RegExp(oldPath+'/').test( asset['.path']);
//
//
//         if(isAssetPathNeedsUpdate){
//             if(oldPath == asset['.path'])//file path
//                 newData['.path']= newPath;
//             else{//folder path
//                 const mixedPath = newPath + asset['.path'].substring(oldPath.length, asset['.path'].length);
//                 newData['.path'] = mixedPath;
//             }
//
//             for(const refPath of newData['.refers'] )
//                 _setFileEntryData(refPath, newData['.path']);
//
//         }
//
//         for(const refIndex in newData['.refers'] ){
//             const oldRef = newData['.refers'][refIndex],
//                 {nakedPath,attrKeys} = $readPath(oldRef);
//
//             if(oldPath == nakedPath) // whole file  path
//                 newData['.refers'][refIndex] =    `${newPath}|${attrKeys.join('|')}`;
//             else if(new RegExp(oldPath+'/').test(nakedPath)){ // partly file path
//                 const mixedPath =  newPath + nakedPath.substring(oldPath.length , nakedPath.length);
//                 newData['.refers'][refIndex] = `${mixedPath}|${attrKeys.join('|')}`;
//             }
//         }
//
//         updatedAssets.push(newData);
//     }
//
//     _setFileEntryData(`${$getKeanuPath()}|.assets`, updatedAssets);
// }

// export function $isNode() {
//     let isNode = false;
//     if (typeof process === 'object') {
//         if (typeof process.versions === 'object') {
//             if (typeof process.versions.node !== 'undefined') {
//                 isNode = true;
//             }
//         }
//     }
//     return isNode;
// }

// export function $searchAssetRefers(refereePath){
//     const   projData = $checkoutFile( $getKeanuPath()),
//         assets = projData['.assets'],
//         {nakedPath} = $readPath(refereePath);
//     $assert(assets);
//     const finder = assets.find(ele=>ele['.path'] == nakedPath);
//     return finder?finder['.refers']:[];
// }









function _getRelatedDataTypes(headerResult, key, dataEntry) {
    const dataTypes = dataEntry['.dataTypes'];

    //parent constraint
    for (const [fullKey, value] of Object.entries(dataTypes)) {
        if (!new RegExp(`^${key}\\|`).test(fullKey))
            continue;
        const strippedKey = fullKey.match(new RegExp(`^${key}\\|(.+)`))[1];
        headerResult[strippedKey] = value;
    }
    headerResult['.'] = dataTypes[key];
    const data = dataEntry[key];


    //empty constraint
    $mapObj(data).forEach(([dataName, val]) => {//.filter(([key,value])=>headerResult[key] != undefined)

        let type = headerResult['.'] & ~DATA_TYPES.object & ~DATA_TYPES.array;
        if (headerResult[dataName])
            type = headerResult[dataName];
        else if (type == 0) {
            if (data[dataName] === null)
                type = DATA_TYPES.null;

            else if (typeof data[dataName] === 'string')
                type = DATA_TYPES.string;

            else if (typeof data[dataName] === 'object')
                type = DATA_TYPES.object;

            else if (typeof data[dataName] === 'number')
                type = DATA_TYPES.number;
        }

        headerResult[dataName] = type;
    });

}


function _genJSONObj(dataEntry, key) {
    const

        data = JSON.parse(JSON.stringify(dataEntry[key])),
        subData = {
            '.name': key,
            '.path': `${dataEntry['.path']}|${key}`,
            ...data,
            '.value': data,
        },
        header = {
            ...data['.dataTypes']
        };
    // if(!subData['.dataTypes']['.'])
    //     subData['.dataTypes']['.'] = DATA_TYPES.object;

    _getRelatedDataTypes(header, key, dataEntry);
    subData['.dataTypes'] = header;
    return subData;
}

function _genValueObj(dataEntry, key) {
    return {
        '.name': key,
        '.path': `${dataEntry['.path']}|${key}`,
        '.dataTypes': {'.': dataEntry['.dataTypes'][key]},
        '.value': dataEntry[key]
    };
}


const __checkKey = function (out, obj, checkKey = (keyList) => {
        return keyList[keyList.length - 1].startsWith('~')
    }) {
        for (const key in obj) {
            out.push(key);
            if (checkKey(out))
                return true;
            else if (typeof obj[key] === 'object') {
                __checkKey(out, obj[key], checkKey);
            }
            out.pop();
        }
    },

    __getKey = function (obj, attrs) {
        let data = obj;
        for (const key of attrs)
            data = obj[key];

        return data;
    }, __delKey = function (obj, attrs) {
        let data = obj;
        const key = attrs.pop();
        for (const key of attrs)
            data = obj[key];

        if (data[key]) {
            delete data[key];
            return true;
        }
        return false;
    }, __setKey = function (obj, attrs, value) {
        let data = obj;
        const key = attrs.pop();
        for (const key of attrs)
            data = obj[key];


        obj[key] = value;
        return data;
    };

function $deepCpyEntryData(obj) {
    $assert(obj);
    const dataEntry = JSON.parse(JSON.stringify(obj)),
        attrList = [];

    if (__checkKey(attrList, dataEntry)) {
        const value = __getKey(obj, attrList.slice());

        __setKey(dataEntry, attrList.slice(), value);
    }
    return dataEntry;
}



function $pruneData(obj, delKeyFullPath, deepCpy = true) {

    const dataEntry = deepCpy ?
            $deepCpyEntryData(obj) :
            JSON.parse(JSON.stringify(obj)),
        attrList = [];

    __checkKey(attrList, dataEntry, (keyList) => keyList.toString() === delKeyFullPath.split('|').toString());
    __delKey(dataEntry, attrList);

    return dataEntry;

}

function $initData(entryPath, deepCpy = false) {
    const dataEntry = deepCpy ?
        $deepCpyEntryData($getAttr$1(entryPath)) :
        JSON.parse(JSON.stringify($getAttr$1(entryPath)));

    dataEntry['.path'] = $path2ID(entryPath) ?? entryPath;
    _initTypeData(dataEntry);
    return dataEntry;
}

function $searchData(path, type, deepCpy) {
    const data = $initData($readPath(path).nakedPath, deepCpy),
        result = [];
    _search(result, data, type);
    return result;

}

function _search(out, data, type) {
    $assert(data);
    for (const [key, val] of $mapObj(data['.dataTypes'])) {
        if (val & type)
            out.push(`${data['.path']}|${key}`);
        if (val & DATA_TYPES.object)
            _search(out, data[key], type);
    }
}

function _initTypeData(data) {
    $mapObj(data).forEach(([key, val]) => {

        if (data['.dataTypes'][key] === undefined) {
            if (data[key] === null)
                data['.dataTypes'][key] = DATA_TYPES.null;
            else if (typeof data[key] === 'number')
                data['.dataTypes'][key] = DATA_TYPES.number;
            else if (typeof data[key] === 'string')
                data['.dataTypes'][key] = DATA_TYPES.string;
            else if (typeof data[key] === 'object')
                data['.dataTypes'][key] = DATA_TYPES.object;
            else $assert(false, {msg: 'unknow type'});
        }


        const type = data['.dataTypes'][key];

        const isObject = !!(type & DATA_TYPES.object),
            isArr = !!(type & DATA_TYPES.array);
        if (isObject || isArr) {
            data[key] = _genJSONObj(data, key);
            _initTypeData(data[key]);
        } else
            data[key] = _genValueObj(data, key);
    });
}

async function __addPaint2Contents(indexKey, palettePath,paletteData,srcPath, boundary,setAttr){
    const content = paletteData['.contents'];

    let srcIndex = __checkContent(palettePath, paletteData, srcPath);

    if(srcIndex === false)
        srcIndex = await  __addContentSources(palettePath, paletteData, srcPath, setAttr);
    if (boundary)
        content[indexKey] = {boundary, srcIndex};
    else//is autoTile
        content[indexKey] = {srcIndex};

    $assert(paletteData['sources'][srcIndex]);
    if (!paletteData['sources'][srcIndex]['.contents'].find(ele => ele === indexKey))
        paletteData['sources'][srcIndex]['.contents'].push(indexKey);
}

async function _addContent2([col,row], palettePath, paletteData, srcPath, boundary = null, setAttr) {//boundary = null when adding autobr
    const
        srcPathUUID = $path2ID(srcPath),

        size =   $getNumber(paletteData.mode) === IUICanvas.MODE.isometric?
            [ ...$isoMap2Size(boundary)]:[boundary[2],boundary[3]];

    const replacedBoundaries =
        addByPaintSolver(palettePath, [col,row,...size]);


    // for(const [_col, _row] of replacedBoundaries)
    if(replacedBoundaries.length)
        await _eraseContent(palettePath, paletteData, replacedBoundaries, srcPathUUID, setAttr);

    await __addPaint2Contents([col,row].toString(),palettePath,paletteData,srcPath,boundary,setAttr);
}


function __checkContent(palettePath, paletteData, srcPath){
    const srcPathUUID = $path2ID(srcPath),
        finder = Object.entries(paletteData['sources'])
            .filter(([key, value]) => value)
            .find(([index, {source}]) => source === srcPathUUID);
    if (finder) return finder[0];
    return false;

}

async function __addContentSources(palettePath, paletteData, srcPath, setAttr){
    const
        type = FileExt2Meta[$readPath(srcPath).fileExt] | DATA_TYPES.path,
        length = $getObjIncrId(paletteData['sources']);

    await setAttr(`${palettePath}|sources|${length}`, {
        source: $path2ID(srcPath),
        '.contents': [],
        '.dataTypes': {'.': DATA_TYPES.object, source: type},
    });
    return Promise.resolve(length);
}

async function _importContent(index, palettePath, paletteData, srcPath, boundary, setAttr) {
    if(!__checkContent(palettePath, paletteData, srcPath))
        await  __addContentSources(palettePath, paletteData, srcPath, setAttr);
    await _addContent2(index, palettePath, paletteData, $path2ID(srcPath), boundary, setAttr);
}


function $genIsometricSliceBoundary(index, slices){
    const result = [],
        originIndex = index.slice();
    let maxY = 0;
    for (const _i in slices) {
        const   i = parseInt(_i),
            slice =  slices[i];

        let {boundary} = slice;
        boundary = $genBoundary(boundary);
        const   prev = slices[i-1],
            hasPrev = !!prev;

        if(hasPrev){
            const   prevBoundary = $genBoundary(prev.boundary),
                offsetY =(prevBoundary[1]+prevBoundary[3]) - (boundary[1]+boundary[3]);
            if(offsetY === 0){
                maxY = Math.max(maxY , boundary[2]);
                index[0] += boundary[0] - prevBoundary[0];
            }else {
                index[0] = originIndex[0];
                index[1] += maxY;
                maxY = boundary[2];
            }
        }else
            maxY = boundary[2];

        result.push({index:index.slice(), boundary});
    }

    return result;
}




function __cleanContents(paletteData, srcIndex, key){

    $assert($isNumber$1(srcIndex));



    delete paletteData['.contents'][key];
}

async function  __updateSourceBySetAttr(sourceInfo, key,paletteUUID,srcIndex,setAttr){
    const delIndex = sourceInfo['.contents'].findIndex(ele => ele === key);
    sourceInfo['.contents'].splice(delIndex, 1);

    const srcPathUUID = sourceInfo['source'];
    if (sourceInfo['.contents'].length === 0) {
        if (srcPathUUID) {
            const asset = $assetsFind(srcPathUUID, 'write');
            asset['.refers'] = asset['.refers']
                .filter(ele => ele !== `${paletteUUID}|sources|${srcIndex}`);
        }
        await setAttr(`${paletteUUID}|sources|${srcIndex}`, null);
    }
}

async function _eraseContent(paletteUUID, paletteData, delIndice, comingSrcPathUUID = null, setAttr) {

    // const delIndice = removeByPaintSolver(palettePath, dstIndex);

    for(const [col,row] of delIndice) {


        let key = [col,row].toString();
        // if(!paletteData['.contents'][key]){
        //     const delBoundaryArr = removeByPaintSolver(palettePath, [col,row]);
        //     if(delBoundaryArr.length === 0) continue;
        //     key = delBoundaryArr[0].slice(0,2).toString();
        // }

        $assert(paletteData['.contents'][key]);
        const {srcIndex} = paletteData['.contents'][key];

        __cleanContents(paletteData, srcIndex, key);

        const sourceInfo = paletteData['sources'][srcIndex];
        $assert(sourceInfo);
        //if erasing same uuid
        const needUpdateSources = !!(comingSrcPathUUID && sourceInfo['source'] === comingSrcPathUUID) === false;

        if (needUpdateSources)
            await __updateSourceBySetAttr(sourceInfo, key,paletteUUID,srcIndex,setAttr);

    }
}











function $updateKeanuFileAssets() {
    const assets = $updateAttr(`${$getKeanuPath()}|.assets`);
    Object.entries(assets)
        .forEach(([, value]) => {
            const refers = [];
            for (const fullPath of value['.refers']) {
                const {nakedPath, attrKeys} = $readPath(fullPath),
                    id = $path2ID(nakedPath),
                    refer = [`${id}`, ...attrKeys];
                refers.push(refer.join('|'));
            }

            value['.refers'] = refers;
        });

    const files = $getFiles$1();
    for (const {path,data} of files) {
        const
            fileEntry = $getFileEntry(path);
        fileEntry.ID = $path2ID(path);
        if (data['source'])
            data['source'] = `${$path2ID(data['source'])}`;
        if (data['sources'])
            for (const [index, source] of Object.entries(data['sources']))
                data['sources'][index] = `${$path2ID(source)}`;

        // if (data['source'])
        //     console.log(data['source']);
        // if (data['sources'])
        //     console.log(data['sources']);
    }
}


async function $checkPaletteSrc(pathID, dstIndex, srcIndice, eraseCallback, paintCallback) {

    const contents = $getAttr$1(`${pathID}|.contents`);

    for (const boundary of srcIndice) {
        const
            srcPicker = $pickByPaintSolver(pathID, boundary),
            isEmpty = srcPicker.length === 0;


        if (isEmpty)//erase
            await eraseCallback(boundary);
        else {
            $assert(srcPicker.length);
            for (const srcBoundary of srcPicker) {
                const
                    [col, row] = srcBoundary,
                    originData = contents [[col, row].toString()];
                if(!originData) continue;

                const
                    offsetX = boundary[0] - srcBoundary[0],
                    offsetY = boundary[1] - srcBoundary[1],
                    dstX = dstIndex[0] - offsetX,
                    dstY = dstIndex[1] - offsetY;

                $assert(originData);
                if (paintCallback)
                    await paintCallback([dstX, dstY], originData, srcBoundary);
            }
        }
    }
}

async function __palette2Palette(srcPath, dstPath, srcIndice, dstIndice, setAttr = $setAttr, mode = 'bulk') {

    const dstData = $updateAttr(dstPath),
        srcData = $getAttr$1(srcPath);
        dstData['.contents'];
        srcData['.contents'];

    for (const dstIndex of dstIndice) {

        await $checkPaletteSrc(srcPath, dstIndex, srcIndice,
            _=> {
                const delBoundaryArr = removeByPaintSolver(dstPath,dstIndex);
                if(delBoundaryArr.length === 0) return;
                const [col,row] = delBoundaryArr[0];
                return _eraseContent(dstPath, dstData, [[col,row]], null, setAttr);
            },
            async (targetIndex,originData)=>{
                $assert(originData);
                const
                    {srcIndex, boundary = null} = originData,
                    srcPathUUID = srcData['sources'][srcIndex]['source'];

                return await _addContent2(targetIndex, dstPath, dstData, srcPathUUID, boundary, setAttr);
            });

        if(srcIndice.length>1 && dstIndice.length>1)
            break;
    }
}
async function __tileBr2PaletteAll(srcPath, palettePath, dstIndex, setAttr){
    const paletteData = $updateAttr(palettePath),
        sourceData = $getAttr$1(srcPath);

    const index = dstIndex.slice();
    const slices = sourceData['slices'].slice();
        $getAttr$1(`${palettePath}|mode`);

    slices.sort((s1, s2) => {
        const s1bottomY = s1.boundary[1] + (s1.boundary[3] ?? 1),
            s2bottomY = s2.boundary[1] + (s2.boundary[3] ?? 1);
        if (s1bottomY === s2bottomY)
            return s1.boundary[0] - s2.boundary[0];
        else
            return s1bottomY - s2bottomY;
    });
    // debugger;if(mode & common.setting.CANVAS_MODE.isometric) {

    const sortedSliceBoundaries = $genIsometricSliceBoundary(index,slices);
    for(const {index, boundary} of sortedSliceBoundaries)
        await _addContent2(index, palettePath, paletteData, srcPath, boundary, setAttr);
}
async function $paint2(srcPath, dstPath, srcIndice, dstIndice, setAttr=$setAttr) {

    $assert(dstIndice);

    dstIndice = dstIndice.slice();
    if(srcIndice)
        srcIndice = srcIndice.slice();
    const srcType = FileExt2Meta[$readPath(srcPath).fileExt];
        FileExt2Meta[$readPath(dstPath).fileExt];

    const paletteData = $getAttr$1(dstPath);


    switch (srcType) {
        case FILE_TYPES.tileBrush:
            if(srcIndice === null)
                await __tileBr2PaletteAll(srcPath, dstPath, dstIndice[0], setAttr);
            break;

        case FILE_TYPES.palette:
            await __palette2Palette(srcPath, dstPath, srcIndice, dstIndice, setAttr);
            break;

        case FILE_TYPES.autoBrush:
            await _importContent(dstIndice[0], dstPath, paletteData, $path2ID(srcPath), [0,0,1,1], setAttr);
            break;
    }




}





const HEADLESS_FILE_STATE = {init:0,process:1, lock:2, ready:64, update:128};

const $getFiles$1 = function (searchPath) {


    if(__files === null) return [];
    const files = Array.from(__files, ([,value])=>value);
    $assert(files);
    if (!searchPath) return files;

    if (typeof searchPath == 'string') {

        if ($isPath(searchPath)) {
            const isFolder = $readPath(searchPath).fileExt ? false : true;
            //const     regex = isFolder ? new RegExp(searchPath + '/') : new RegExp(searchPath);
            //
            // return files.filter(({path}) => new RegExp(regex).test(path));
            return files.filter(({path}) =>isFolder?
                new RegExp(searchPath + '/') .test(path):
                searchPath === path
            );

        } else {//{xxx} id
            const searchId = searchPath;
            return files.filter(({id}) => id === searchId);

        }
    } else if (searchPath instanceof RegExp) {
        return files.filter(({path}) => searchPath.test(path));

    }
};


const $getAttr$1= (path)=> $checkoutFile(path,'read');
const $updateAttr= (path)=> $checkoutFile(path,'write');
function $checkoutFile(path, operation = 'read') {
    if (!path) path = $getKeanuPath();
    if (!$readPath(path)) return undefined;


    const
        {nakedPath, attrKeys} = $readPath(path),
        [file] = $getFiles$1(nakedPath);

    if (!file) return undefined;



    const data = file.data;

    $assert(data);

    if(operation === 'write'){
        file.version = '';
        file.state |= HEADLESS_FILE_STATE.update;
    }


    const    res = attrKeys.length === 0 ?data: _getJSON(data, attrKeys);

    if(!res)
        return res;
    return  operation === 'read'&&  res.constructor.name === 'Object'? Object.freeze($deepCopyObj(res)):res;
}function $deepCopyObj(obj){
    const res = Array.isArray(obj)?[]:{};
    for(const key in obj){
        if(obj[key] === null || obj[key] === undefined)
            res[key] = null;
        else if(typeof obj[key] !== 'object')
            res[key] = obj[key];
        else if(obj[key].constructor.name === 'Object')
            res[key] = $deepCopyObj(obj[key]);

        else if(obj[key].constructor.name === 'Array')
            res[key] = $deepCopyObj(obj[key]);
        else
            res[key] = obj[key]; //Canvas, Image
    }
    return res;

}


function _setAttr(fullPath, value) {

    if ($isEditable(fullPath) === false)
        return false;

    if ($getFileDataType(fullPath) & DATA_TYPES.path) {

        //TODO: clean up ['.assets'] ['.refers']
        $readPath(fullPath);
            const pathValue = $readLockerValue(value).text;


        _cleanAssetReferences(fullPath);

        if (pathValue !== 'null')
            _addNewAsset2Ref(fullPath, pathValue);
    }

    // _setFileEntryData(fullPath, value);//setAttr
    const {nakedPath, attrKeys} = $readPath(fullPath),
        jsonData = $updateAttr(nakedPath);
    _setJSONData(jsonData, attrKeys, value);

    return true;
}
function _addNewAsset2Ref(fullPath, pathValue) {

    const srcRef = $assetsFind(pathValue, 'write');
    if (!srcRef['.refers'].find(ele => ele === fullPath))
        srcRef['.refers'].push($path2ID(fullPath));
}

function _cleanAssetReferences(fullPath) {
    const projData = $getAttr$1($getKeanuPath()),
        assets = Object.entries(projData['.assets']);
    assets.forEach(([index, ele]) => {
        const references = ele['.refers'],
            referPath = $path2ID(fullPath),
            delIndex = references.findIndex(refFullPath => refFullPath === referPath);
        if (delIndex >= 0)
            references.splice(delIndex, 1);
        if (references.length === 0)
            console.log();//TODO:IsolatedAssets
    });

}
function $isEditable(fullPath) {
    if($readPath(fullPath)  === undefined) debugger;
    //isEditable is value is usr editable data NOT hidden data
    const {nakedPath, attrKeys} = $readPath(fullPath);
        attrKeys.reduce((acc, key) => {
            const isHidden = $isHiddenAttr(key);
            return acc = acc || !isHidden;
        }, false);
    const jsonData = $getAttr$1(nakedPath);
    $assert(jsonData);

    const value = _getJSON(jsonData, attrKeys);
    return $readLockerValue(value).locker === false;
}

function $getFileDataType(path) {
    const {nakedPath, attrKeys} = $readPath(path);
    const data = $initData(nakedPath);
    if (attrKeys.length === 0)
        attrKeys.push('.');
    return _getJSON(data, attrKeys, true);
}
function _delJSON(json, keyBuf, delKeys) {
    delKeys = Array.isArray(delKeys) ? delKeys : [delKeys];
    json = _getJSON(json, keyBuf);
    if (Array.isArray(json)) {
        for (let i = json.length - 1; i >= 0; i--)
            if (delKeys.includes(i))
                json.splice(i, 1);
    } else
        for (const key of delKeys)
            delete json[key];
}


function _getJSON(json, keyBuf, isDataType = false) {
    keyBuf = keyBuf.slice();
    if (keyBuf.length > 0) {
        let key;
        $assert(keyBuf.shift);
        while (key = keyBuf.shift()) {
            if (isDataType && keyBuf.length == 0)
                if (json['.dataTypes'] && json['.dataTypes'][key])
                    json = json['.dataTypes'][key];
                else if (json['.dataTypes'] && json['.dataTypes'][key] == undefined)
                    json = json['.dataTypes']['.'] & (~DATA_TYPES.object);
                else
                    json = null;
            else {
                $assert(json);
                json = json[key];
            }
            if (json === undefined)
                return null;
        }
    }

    return json;
}

function _setJSONData(json, keyBuf, params) {
    $assert(json);
    const isValueMode = params == null || typeof params != 'object';

    let key;
    keyBuf = keyBuf.slice();
    if (keyBuf.length > 0) {
        while (key = keyBuf.shift()) {
            const isLastKey = keyBuf.length == 0;
            if (isLastKey) //Array.isArray(json) //typeof json[key] != 'array' || //(typeof json[key] != 'object' || json[key] == null)
                break;
            else {


                if (json[key] == undefined) {
                    try{
                        if ($isNumber$1(keyBuf[0]))//next key is number
                            json[key] = [];
                        else
                            json[key] = {};
                    }catch (e){
                        $assert(false,`cannot wrt ${JSON.stringify(json)}`);
                    }
                }


                json = json[key];
                $assert(json);

            }
        }
    }
    if (isValueMode) {
        $assert(key && json);
        json[key] = params;
    } else
        json[key] = JSON.parse(JSON.stringify(params));

    // for(const [attr,value] of Object.entries(params))
    //     json[attr] = value;


// else if(Array.isArray(json)){
//
//
//     }
}



const $checkFiles =path=>!!$getFiles$1(path).length;




function _cleanProjAssetRefers(path) {
    const
        delKeyID = $path2ID(path),
        assetsPath = `${$getKeanuPath()}|.assets`,
        assets = $updateAttr(assetsPath),
        sourceIsNullList = [];

    sourceIsNullList.push(...assets[delKeyID]['.refers']);
    $delAttr(assetsPath, delKeyID);


    const delRefIndice = [];
    for (const [assetId, asset] of Object.entries(assets)) {
        for (let refIndex = asset['.refers'].length - 1; refIndex >= 0; refIndex--) {

            const [refId, ...attrs] = asset['.refers'][refIndex].split('|');
            // if(delFiles.find(({id})=>id === refId)){
            if (delKeyID === refId) {
                let delInfo = delRefIndice.find(ele => ele.id === refId);
                if (!delInfo) {
                    delInfo = {id: assetId, referIndice: [refIndex]};
                    delRefIndice.push(delInfo);
                } else
                    delInfo.referIndice.push(refIndex);
            }
        }
    }
    for (const {id, referIndice} of delRefIndice)
        $delAttr(`${assetsPath}|${id}|.refers`, referIndice);


    return sourceIsNullList;
}

async function $deleteFile(sel, onCheckCallback = null) {
    const sourceIsNullList =  sel.reduce((acc,cur)=>acc=[...acc, ...$projDelFile(cur)],[]);

    for (const fullPath of sourceIsNullList) {
        if (onCheckCallback)
            await onCheckCallback(fullPath);
    }

    // const t = $projDelFile($path2ID(sel[0]));
    // debugger;
    // const sourceIsNullList = [];
    // for (const entryPath of sel) {
    //     const delList = $getFiles(entryPath);
    //     //check subFolder
    //     for (const {path} of delList) {
    //
    //         const nullList = _cleanProjAssetRefers(path)
    //             .filter(id => !delList.find(ele => $readPath(id).nakedPath === ele.path));
    //         sourceIsNullList.push(...nullList); //filter out deleted item
    //     }
    // }
    // for (const fullPath of sourceIsNullList) {
    //     _cleanAttr(fullPath);
    //     if (onCheckCallback)
    //         await onCheckCallback(fullPath);
    // }
}


function _cleanAttr(fullPath) {
    if (!$readPath(fullPath)) debugger;

    const {nakedPath, attrKeys} = $readPath(fullPath),
        jsonData = $getAttr$1(nakedPath),
        type = $getFileDataType(fullPath);

    if (type & DATA_TYPES.path)
        $setAttr(fullPath, null);
    else if (type & DATA_TYPES.object) //palette sources {}
        $setAttr(`${fullPath}|source`, null);

    return jsonData;
}

function $canDel(path){
    const proj = $getKeanuPath();
    if(Array.isArray(path))
        return path.reduce((acc,cur)=>acc&&(new RegExp(cur).test(proj)), true)
    else
        return (new RegExp(path).test(proj))
}
function $setKeanuFileAssets(id, path, referFullPath = null) {
    const jsonData = { '.refers': []};
    if (referFullPath) jsonData['.refers'].push(referFullPath);
    $setAttr(`${$getKeanuPath()}|.assets|${id}`, jsonData);
}

function $assetsFind(input, mode = 'read') {
    $assert(input);
    const
        assetsCpy = $checkoutFile('{root}|.assets',mode);

    if(!assetsCpy) return undefined;


    return assetsCpy[$path2ID($readPath(input).nakedPath)];
}

function $delAttr(fullPath, delKeys) {


    const {nakedPath, attrKeys} = $readPath(fullPath);
    let jsonData = $updateAttr(nakedPath);
    $assert(jsonData);
    _delJSON(jsonData, attrKeys, delKeys);
    return jsonData;
}function $setAttr(fullPath, params) {
    // if($pathError(fullPath)) return;
    const isObj = value => typeof value == 'object'
        && value != null; //source:null
    if (isObj(params)) {//multiple values
        if (JSON.stringify(params) === '{}' ||
            JSON.stringify(params) === '[]')

            return _setAttr(fullPath, params);
        else {
            const list = [];
            for (const key in params) {
                const
                    newPath = `${fullPath}|${key}`,
                    value = params[key];
                if (isObj(value))
                    $setAttr(newPath, value);
                else {
                    if ($isEditable(newPath))
                        list.push({path: newPath, value});
                    else
                        return false; //error cannot edit newPath
                }
            }
            for (const {path, value} of list)
                _setAttr(path, value);
            return true;
        }
    } else
        return _setAttr(fullPath, params);
}

const isNode$1 = typeof process != 'undefined';
function $assert$1(condition, info = {
    errorType: 1, //internel err
    msg: `assertion failed`,
    path: null
}) {
    if (!condition) {
        debugger;
        let {msg, errorType, path} = info;

        msg = msg || info;
        if (msg)
            console.error(msg);
        throw new Error(msg);
    }
}function $isNumber$1(input) {
    return input != null && (Number(input) || Number(input) == 0) ? true : false;
}function checkStatus$1(data, status) {
    return (data & status);
}


const objListHandler = {
    get(target, prop, receiver){
        const objListFuncs = Object.getPrototypeOf(target);

        if(Object.getOwnPropertyDescriptor(target, prop)||Object.getOwnPropertyDescriptor(objListFuncs, prop))
            return Reflect.get(...arguments);
        else {
            const arr = target.toArray(),
                arrFuncs = Object.getPrototypeOf(arr),
                descriptor = Object.getOwnPropertyDescriptor(arr, prop) || Object.getOwnPropertyDescriptor(arrFuncs, prop);
            if(descriptor){
                if(typeof descriptor.value === 'function')
                    return (...args)=>descriptor.value.call(arr, ...args);//Reflect.apply(descriptor.value, arr, ...args);
                else
                    return Reflect.get(arr, prop, receiver);
            }else {
                if(Object.getOwnPropertyDescriptor(target.toObject(), prop))
                    return Reflect.get(target.toObject(), prop, receiver);
                else
                    // return console.error('undefined property of ObjList');
                    return undefined;
            }
        }
    },
    set(target, prop, value){
        const objListFuncs = Object.getPrototypeOf(target);

        if(Object.getOwnPropertyDescriptor(target, prop)||Object.getOwnPropertyDescriptor(objListFuncs, prop))
            return Reflect.set(...arguments);
        else {
            const descriptor = Object.getOwnPropertyDescriptor(target.toArray(), prop);
            if(descriptor && descriptor.writable)
                return Reflect.set(target.toArray(), prop, value);
            else {
                // return console.error('undefined property of ObjList');
                if(value.name !== undefined){
                    target.push(value);
                    return true;
                }else
                    return console.error(`set ObjList failed ${value}`);
            }
        }
    }
};
const createObjList = function(){
    return new Proxy(new ObjList(), objListHandler);
};
class ObjList {
    array = [];
    objs = {};

    set values(values){
        if(Array.isArray(values)){
            this.array = values.filter(ele=>ele);
            this.array.forEach((ele)=>this.objs[ele.name] = ele );
        }else {
            for(const [key,value] of Object.entries(values))
                this.push(value);

        }
    }

    get length(){
        return this.array.length
    }
    set length(value){
        this.array.length = value;
        this.array = this.array.filter(ele=>ele);
        this.objs={};
        this.array.forEach((ele)=>this.objs[ele.name] = ele );
    }

    toArray(){return this.array;}
    toObject(){return this.objs;}

    constructor(){
        this[Symbol.iterator] = function* () {
            yield* this.array;
        };
    }

    sort(sorter = (a,b)=>{

        if($isNumber$1(b.objIndex)&&$isNumber$1(a.objIndex)){
            return a.objIndex-b.objIndex;
        }else if($isNumber$1(b.objIndex))
            return 1;
        else if($isNumber$1(a.objIndex))
            return -1;
        else {
            if(a.name<b.name)  return -1;
            if(a.name>b.name)  return 1;
        }
    }){

        this.array.sort(sorter);
    }

    insert(index,ele){
        let key = ele.name;

        $assert$1(!this.objs[key]);

        this.array.splice(index, 0, ele);


        this.objs[key] = ele;
    }
    push(ele){


        let key = ele.name;

        $assert$1(!this.objs[key]);

        this.array.push(ele);


        this.objs[key] = ele;
    }
    rename(ele, newNm){
        const oldName = ele.name;
        $assert$1(this.objs[oldName]&&!this.objs[newNm]);
        delete this.objs[oldName];
        this.objs[newNm] = ele;
        ele.Name = newNm;
    }
    exist(name){
        return this.objs[name]?true:false;
    }
    delete(input){
        let name;
        $assert$1(input);
        if(typeof input === 'string'){
            name = input;
        }else if(this.objs[input.name]){
            name = input.name;
        }else {
            $assert$1(false,{path:null,errorType:common$1.error.ERR_TYPE.internalErr,
                msg:'Objs delete failed'});
        }

        delete this.objs[name];

        let ele = this.array.find((ele, index)=>{
            if(ele.name == name)
                this.array.splice(index,1);
            return ele.name == name;
        });

        $assert$1(ele);



    }
    clear(){
        for(let key in this)
            this.objs[key] = null;
        this.array.length = 0;
    }
}
const $exeSequential = (tasks, fnc) => {

    const result = [];
    return tasks.reduce((prev, curTask, i) => {
        return prev
            .then(_ => {
                if (Array.isArray(curTask))
                    return fnc(...curTask, i);
                return fnc(curTask, i);
            })
            .then(res => {
                result[i] = res;
                return Promise.resolve(result);
            })
    }, Promise.resolve());
};

function $getStackLocationByIndex(level = -1) { // -1 is parent, -2 parent's parent
    const stackTrace = new Error().stack,
        isChrome = stackTrace.startsWith("Error"),
        isSafari = /(.+)@(.+)[\n]*/.test(stackTrace);
    $assert$1(isChrome || isSafari);
    let stack;
    if (isSafari)
        stack = stackTrace.split('\n');
    else
        stack = stackTrace.match(/at(.+)/g);
    stack.shift();

    while (level++ < 0) {
        stack.shift();
    }


    const source = stack[0];//isSafari?stack[1]:stack[0];
    $assert$1(source);
    //stack[0] = asyncFunctionResume@[native code]
    let data;

    if (/(file:\/\/[^ ]*\.js):(\d+):(\d+)/.test(source))
        data = source.match(/(file:\/\/[^ ]*\.js):(\d+):(\d+)/);

    if (/(https?:\/\/[^ ]*\.js):(\d+):(\d+)/.test(stack[0]))
        data = source.match(/(https?:\/\/[^ ]*\.js):(\d+):(\d+)/);

    const
        [, url, lineNum, colNum] = data;
    return {url, lineNum, colNum};
}


const throttleStore = {};

async function $throttle(fnc, delay) {
    // let stack = $getStackLocationByIndex();
    const fncLocale = JSON.stringify($getStackLocationByIndex(-1));
    if (throttleStore[fncLocale]) {
        if (Date.now() - throttleStore[fncLocale] > delay) {
            delete throttleStore[fncLocale];
            return await fnc();
        }
    } else {
        throttleStore[fncLocale] = Date.now();
    }
}


let aniStore = {};

function $animate(fnc, interval, steps, onDelete) {
    // let stack = $getStackLocationByIndex();
    const fncLocale = JSON.stringify($getStackLocationByIndex(-1));

    if (aniStore[fncLocale]) {
        clearInterval(aniStore[fncLocale].interval);
    }
    aniStore[fncLocale] = {steps: 0};
    aniStore[fncLocale].interval = setInterval(async _ => {
        aniStore[fncLocale].steps++;

        if (steps && aniStore[fncLocale].steps == steps) {
            clearInterval(aniStore[fncLocale].interval);
            delete aniStore[fncLocale];
            if (onDelete) onDelete();
        } else if (await fnc(aniStore[fncLocale].steps)) {
            clearInterval(aniStore[fncLocale].interval);
            delete aniStore[fncLocale];
            if (onDelete) onDelete();
        }
    }, interval);

    return aniStore[fncLocale].interval;

}


let debounceStore = {};

function $debounce(fnc, delay) {


    const fncLocale = JSON.stringify($getStackLocationByIndex(-1));
    let job = () => {
        fnc();
        delete debounceStore[fncLocale];
    };

    if (debounceStore[fncLocale]) {
        const curJob = debounceStore[fncLocale],
            now = Date.now(),
            timeDiff = now - curJob.time;
        clearTimeout(curJob.interval);

        if (timeDiff < delay) {
            curJob.interval = setTimeout(job, delay - timeDiff);
            curJob.time = now;
        } else {
            job();
        }
    } else {
        debounceStore[fncLocale] = {time: Date.now(), interval: setTimeout(job, delay)};
    }
}


function $match(regex, str) {
    let m, result = [];
    while ((m = regex.exec(str)) !== null) {
        // This is necessary to avoid infinite loops with zero-width matches
        if (m.index === regex.lastIndex) {
            regex.lastIndex++;
        }

        // The result can be accessed through the `m`-variable.
        m.forEach((match, groupIndex) => {
            // console.log(`Found match, group ${groupIndex}: ${match}`);
            result.push(match);
        });
    }
    return result;
}

//TODO: new URL
//https://developer.mozilla.org/en-US/docs/Web/API/URL
//https://stackoverflow.com/questions/27745/getting-parts-of-a-url-regex
function $parseURL(url = '/test/test.jpg') {


    let regex = /^((http[s]?|ftp):\/)?\/?([^:\/\s]+)(:(\d+))?((\/\w+)*\/)([\w\-\.]+[^#?\s]+)(.*)?(#[\w\-]+)?$/gm;

    let info = $match(regex, url);
    let baseURL = {};
    baseURL['protocol'] = info[2];
    baseURL['host'] = info[3];
    baseURL['port'] = info[5];
    baseURL['path'] = info[6];
    baseURL['file'] = info[8];
    baseURL['params'] = {};

    regex = /(\?|\&)([^=]+)\=([^&]+)/gm;
    info = $match(regex, url);

    for (let i = 2; i < info.length; i += 2)
        baseURL['params'][info[i]] = info[i + 1];
    return baseURL;
}

function downloadURL(data, fileName, mimeType = 'text/plain') {
    const a = document.createElement('a'),
        file = new Blob(Array.isArray(data) ? data : [data], {type: mimeType});
    a.href = URL.createObjectURL(file);
    a.download = fileName;
    document.body.appendChild(a);
    a.style = 'display: none';
    a.click();
    a.remove();
    URL.revokeObjectURL(a.href);
    // setTimeout(() => URL.revokeObjectURL(a.href), 1000);

}function $readPath(path) {
    try{
        $assert$1(path && path.startsWith);
        // if(!path.startsWith('/'))
        //     path = '/'+path;
        const buf = path.split('|'),
            attrKeys = buf.slice(1);
        let nakedPath = buf[0];
        if ($isPathID(nakedPath)) {//is id like {23eafwef}
            const file = $getFiles$1(nakedPath);
            if (file.length === 0) return undefined;
            nakedPath = file[0]['path'];
        }


        const

            paths = nakedPath.split('/'),
            file = paths.pop(),
            [, fileNm, fileExt] = file.match(/(.+)\.([^.]*)$/) ?? [, file, null];
        return {folder: paths.join('/'), fileNm, attrKeys, fileExt, nakedPath, file};
    }catch (err){
        console.log(path);
        debugger;
    }
}



function $genID(generatedUIDs={}) {
    while (true) {
        const uid = ("0000" + ((Math.random() * Math.pow(36, 4)) | 0).toString(36)).slice(-4);
        if (!generatedUIDs.hasOwnProperty(uid))
            return uid;
    }



    // const uint32 = window.crypto.getRandomValues(new Uint32Array(1))[0];
    // return uint32.toString(16);
    // return crypto.randomUUID();


    // if (generatedUIDs === undefined) {
    //     // // I generate the UID from two parts here
    //     // // to ensure the random number provide enough bits.
    //     // let firstPart = (Math.random() * 46656) | 0,
    //     //         secondPart = (Math.random() * 46656) | 0;
    //     // firstPart = ("000" + firstPart.toString(36)).slice(-3);
    //     // secondPart = ("000" + secondPart.toString(36)).slice(-3);
    //     // return firstPart + secondPart;
    //     return '$root';
    // } else {
    //     while (true) {
    //         const uid = ("0000" + ((Math.random() * Math.pow(36, 4)) | 0).toString(36)).slice(-4);
    //         if (!generatedUIDs.hasOwnProperty(uid))
    //             return uid;
    //     }
    // }
}



function $path2ID(path) {
    const pathObj = $readPath(path);
    $assert$1(pathObj);
    const {nakedPath, attrKeys} = pathObj;
    const finder = $getFiles$1(nakedPath);
    if (!finder) return null;
    if(!finder[0]) return null;

    const pathID = finder[0].id;
    if (attrKeys.length)
        return `${pathID}|${attrKeys.join('|')}`;
    else
        return pathID;
}

function $compareID(a, b) {
    const buffA = a.match(/{(.+)}/),
        buffB = b.match(/{(.+)}/);
    $assert$1(buffA[1] && buffB[1]);
    return buffA[1] === buffB[1];
}




function $getObjIncrId(obj) {
    let id = -1;
    for (const key in obj)
        if ($isNumber$1(key) && parseInt(key) > id)
            id = parseInt(key);

    id++;
    return id;
}


function $isReadOnlyAttr(key) {

    const specialChar = key[0];
    if (specialChar == READONLY_CHAR)
        return true;

    return false;
}

function $readLockerValue(value) {
    const {specialChar, keyName} = $parseAttrValue(value);

    return {text: keyName, locker: specialChar == LOCKER_CHAR};
}



function $findRefers(out, path) {

    for (const referFullPath of $assetsFind(path)['.refers']) {
        const nakedPath = referFullPath.split('|')[0];
        out.push(nakedPath);
        $findRefers(out, nakedPath);
    }
}
function $parseAttrValue(key) {
    let [, specialChar, keyName] = $match(/^([!|+|.|~]?)(.+)/g, key);///^([^a-zA-z])?(.+)/g
    return {specialChar, keyName};
}


function $isHiddenAttr(key) {
    const specialChar = key[0];
    if (specialChar == TEMP_CHAR)
        return true;
    if (specialChar == HIDDEN_CHAR)
        return true;

    return false;
}
function boundary2AABB(boundary, transform = null){
    let result = boundary.slice();
    result[2] = result[2]??1,result[3] = result[3]??1;

    result[2] += result[0],result[3] += result[1];

    if(transform)
        multiply(result, transform.globalMatrix, result, 'aabb');

    return result;
}

function $getDataValue(data,dataType = data['.dataTypes']){

    let value = data;
    if(dataType & DATA_TYPES.number){
        if(dataType & DATA_TYPES.object){
            value = [];

            $mapObj(data).forEach(([key,val])=>{
                const arrayValue = val;
                if(typeof  arrayValue == 'number')
                    value.push(arrayValue);
                else {
                    const res = arrayValue.match(new RegExp(`^${LOCKER_CHAR}(.+)`));
                    value.push(parseFloat(res?res[1]:arrayValue));
                }
            });


        }else {
            if(typeof  data == 'number')
                value = data;
            else {
                if(!data.match) debugger;
                const res = data.match(new RegExp(`^${LOCKER_CHAR}(.+)`));
                value = parseFloat(res?res[1]:data);
            }
        }
    }
    return value;
}

function $genBoundary(boundary) {

    const res = Array.isArray(boundary) ?
        boundary.slice() :
        $mapObj(boundary).map(([key, value]) => value['.value']);
    res[2] = res[2] ?? 1;
    res[3] = res[3] ?? 1;
    return res;
}

function $isInsideBoundary(index, boundary) {
    boundary = $genBoundary(boundary);
    $assert$1(boundary.length === 4);
    return index[0] >= boundary[0] && index[0] < boundary[0] + boundary[2]
        && index[1] >= boundary[1] && index[1] < boundary[1] + boundary[3]
}

function $isoMap2Bottom(boundary) {
    const result = boundary.slice();
    result[3] = result[2];
    return result;
}
function $isoMap2Size(boundary){
    return [boundary[2], boundary[2]];
}

function $isPath(input) {
    // const isFolder = /^([A-Za-z0-9]+[\/])+/.test(input),
    //         isFile = /[A-Za-z0-9]+\.+[A-Za-z0-9]+/.test(input);
    //
    // if(isFolder || isFile) return true;

    const isID = /^\{(.+)\}$/.test(input);
    return !isID;
}

function $isPathID(path) {

    return /{(.+)}/.test(path);
}

function $PROJ_PATH(id) {
    return id.split('-').join('/');
}

function $boundary2Indice(boundary){
    const
        result = [],
        [c,r,width,height] = boundary;
    for (let col = c; col < c+width; col ++)
        for (let row = r; row < r+height; row ++)
            result.push([col,row]);

    return result;
}



function $mapObj(obj) {
    if (Array.isArray(obj)) return obj.map((ele, index) => [index, ele]);

    const result = [];
    for (const key in obj) {
        if (!$isHiddenAttr(key))
            result.push([key, obj[key]]);
    }
    return result;
}

function _getNumber(input) {
    if (new RegExp(LOCKER_CHAR).test(input))
        return $isNumber$1(input.slice(1)) ? Number(input.slice(1)) : 0;
    else
        return $isNumber$1(input) ? Number(input) : 0;
}

function $getNumber(input) {
    if (typeof input == 'object')
        return $mapObj(input).map(([key, value]) => _getNumber(value));
    else if (Array.isArray(input))
        return input.map(ele => _getNumber(ele));
    else
        return _getNumber(input);
}

function mul_mat3d_mat3d(out, a, b) {
   return multiply$3(out, a, b);
}

function mul_mat3d_4vec(out, mat, _4vec, mode = 'boundary'){

    let x = _4vec[0], y = _4vec[1];
    //upLeft
    let m0 = mat[0] * x, m2 = mat[2] * y, m4 = mat[4],
        m1 = mat[1] * x, m3 = mat[3] * y, m5 = mat[5];
    let out0x = m0 + m2 + m4,//lower x
        out0y = m1 + m3 + m5;//lower y


    //bottomLeft
    if (mode === 'boundary')//[lowerx, lowery, with, height]
        x = _4vec[0], y = _4vec[1] + _4vec[3];
    else if (mode === 'aabb')
        x = _4vec[0], y = _4vec[3];
    m0 = mat[0] * x, m2 = mat[2] * y, m4 = mat[4],
        m1 = mat[1] * x, m3 = mat[3] * y, m5 = mat[5];
    let out1x = m0 + m2 + m4,//
        out1y = m1 + m3 + m5;//


    //bottomRight
    if (mode === 'boundary')
        x = _4vec[0] + _4vec[2], y = _4vec[1] + _4vec[3];
    else if (mode === 'aabb')
        x = _4vec[2], y = _4vec[3];
    m0 = mat[0] * x, m2 = mat[2] * y, m4 = mat[4],
        m1 = mat[1] * x, m3 = mat[3] * y, m5 = mat[5];
    let out2x = m0 + m2 + m4,//
        out2y = m1 + m3 + m5;//

    //upRight
    if (mode === 'boundary')
        x = _4vec[0] + _4vec[2], y = _4vec[1];
    else if (mode === 'aabb')
        x = _4vec[2], y = _4vec[1];
    m0 = mat[0] * x, m2 = mat[2] * y, m4 = mat[4],
        m1 = mat[1] * x, m3 = mat[3] * y, m5 = mat[5];
    let out3x = m0 + m2 + m4,////upper x
        out3y = m1 + m3 + m5;////upper y

    out[0] = Math.min(out0x, out1x, out2x, out3x);
    out[1] = Math.min(out0y, out1y, out2y, out3y);
    out[2] = Math.max(out0x, out1x, out2x, out3x);
    out[3] = Math.max(out0y, out1y, out2y, out3y);

    if (mode === 'boundary')
        out[2] -= out[0], out[3] -= out[1];

}


function multiply(out, a, b, mode = 'boundary') {



    $assert$1(a);
    const matA = a.Matrix ? a.Matrix : a;
            b.Matrix ? b.Matrix : b;
    $assert$1(matA.length === 6 && b && (b.length === 2 || b.length === 4 || b.length === 6));
    $assert$1(mode === 'boundary' || mode === 'aabb');

    let x = b[0], y = b[1];

    if (b.length === 2)
        out[0] = matA[0] * x + matA[2] * y + matA[4],
        out[1] = matA[1] * x + matA[3] * y + matA[5];
    else if (b.length === 4) {//if b is aabb [lowerx, lowery, upperx, uppery]
        mul_mat3d_4vec(out, matA, b);
    } else if (b.length === 6) {
        $assert$1(out.length === 6);
        mul_mat3d_mat3d(out, a.Matrix ? a.Matrix : a, b);
    }



}

function inverse(mat, a){
    $assert$1(mat && a);
    const cos = a.q.cos, sin = a.q.sin,
        tx = a.position[0], ty = a.position[1],
        sx = a.scale[0], sy = a.scale[1],
        px = a.pivot[0], py = a.pivot[1];

    //([T]*[+p]*[RS]*[-p])T = [p] ([RS]T) [-p] [-T]

    //[RS]T = [ST]*[RT]
    mat[0] = cos/sx;    mat[2] = sin/sx;
    mat[1] = -sin/sy;    mat[3] = cos/sy;

    //[-p] [-T]
    const ptInvx = -tx-px,
        ptInvy = -ty-py;

    //[p] ([RS]T) [-p] [-T]
    mat[4] = mat[0] * ptInvx + mat[2] * ptInvy + px;
    mat[5] = mat[1] * ptInvx + mat[3] * ptInvy + py;
}

function multiplyInv(out, a,b, mode = 'boundary'){
    $assert$1(a.constructor.name === 'Transform2D');

    const mat = [0,0, 0,0, 0,0];
    inverse(mat,a);

    $assert$1(mat instanceof Array && mat.length === 6);
    $assert$1(mode === 'boundary' || mode === 'aabb');
    multiply(out, mat, b, mode);
}

Math.maxInt = 65535,Math.minInt = -65535;
class UserAgent{
    system = '';
    sysVersion = '';
    browser  =  '';
    browserFlag  = 0;
    sysFlag  = 0;
    constructor() {
        this.initialize();
    }

    initialize(ua= navigator.userAgent,
               SYSFLAG = common$1.system.SYS_FLAG,
               SYS = common$1.system.SYS_INFO,
               BROWSERFLAG = common$1.system.BROWSER_FLAG){

        this.system = '';
        this.sysVersion = '';
        this.browser  =  '';
        // this.browserFlag  = 0;
        this.sysFlag  = 0;





        const buffer = $match(/\(([^)]+)\)/g,ua);

        $assert(buffer[1]);
        const core = buffer[1];


        //$match sys
        for(var key in SYS){
            if(new RegExp(key).test(core)){
                this.system = key;
                this.sysFlag = SYS[key];
                break;
            }
        }

        //$match sysVersion
        const [sysVersion] = $match(/((\d+[_.]*)+)/g, core);
        this.sysVersion = sysVersion.replace(/_/g,'.');


        if(/Build/.test(core)) //Linux; Android 9; SM-G973U Build/PPR1.180610.011
            //deviceInfo: SM-G973U
            this.deviceInfo = $match(/([^;\s]+)[\s]+Build/g,core)[1];
        else //if(/iPhone/.test(core))
            this.deviceInfo = core.split(';')[0];


        //sysStr = buffer[0] = '(Macintosh; Intel Mac OS X 10_15_7)'
        const sysStr = buffer[0],
            browserStr = ua.split(sysStr)[1],
            info = $match(/([A-Za-z]+)\/([\d|\.]+)/gm,browserStr);

        this.browserVersion     = info.pop();
        this.browser            = info.pop();


        const browserInfo = Object.entries(BROWSERFLAG).find(([key,value])=>key == this.browser);
        $assert(browserInfo);
        this.browserFlag |= browserInfo[1];

        // //$match browser flag
        // for(const key in BROWSERFLAG){
        //     if(key == 'Safari'){
        //         if(/Mobile Safari/.test(browserStr) ||   (this.browserFlag & BROWSERFLAG.Chrome))//(this.sysFlag&SYSFLAG.Desktop) ||
        //             continue;
        //
        //     }else{
        //         if(!new RegExp(key).test(browserStr))
        //             continue;
        //     }
        //     debugger;
        //     this.browserFlag |= BROWSERFLAG[key];
        //     this.browser = key;
        // }

        //$match browserVersion
        // const _re = new RegExp(this.browser + '\\/(([\\d_.]*)+)','g');
        // this.browserVersion = $match(_re, ua)[1];
        // debugger;
        // this.browserVersion = this.browserVersion.replace(/_/g,'.');

    }
}const $resizeWorkspace=_=>{
    const root = document.getElementById('root');

    const bound = [Math.maxInt,Math.maxInt, 0,0];
    for(const editor of root.children){
        const size = editor.getBoundingClientRect();
        bound[0] = Math.min(bound[0], size.x);
        bound[1] = Math.min(bound[1], size.y);
        bound[2] = Math.max(bound[2], size.x+size.width);
        bound[3] = Math.max(bound[3], size.y+size.height);
    }
    root.style['width'] = `${bound[2]-bound[0]}px`;
    root.style['height'] = `${bound[3]-bound[1]}px`;

};
const $infinityDesktop$1=(root=document.getElementById('root'))=>{
    window.addEventListener('wheel', evt => {
        if(!_infinityDesktopIsOn) return;
        evt.preventDefault();
        const { ctrlKey } = evt;
        if (ctrlKey) {
            _oriX =evt.clientX;
            _oriY =evt.clientY;
            _scale *= $wheelDelta2Scale(evt.deltaY);
        }else {
            _x -= evt.deltaX;
            _y -= evt.deltaY;
        }
        root.style['transform'] = `scale(${_scale}) translate(${_x}px, ${_y}px)`;
        root.style['transform-origin'] = `${_oriX}px ${_oriY}px`;

    },{passive:false});
};

const $infinityDesktopGetScale$1=_=>{
    return _scale;
};
const $infinityDesktopSet =isOn=>_infinityDesktopIsOn=!!isOn;

const __isNode = typeof process != 'undefined';
if(!__isNode){

    if(!window.__ua)
        window.__ua = new UserAgent();

    const {url,lineNum, colNum} = $getStackLocationByIndex(0);

    if(!window.__root)
        window.__root = $parseURL(url);



    window.usrWindows = [];
    window.compileUsrCode = compileUsrCode;


    window.findByFullName = $findByFullName;
    window.getFiles = $getFiles$1;
    window.wrtFiles = $wrtFiles;
    // window.getFileData = $checkoutFile;
    window.$resizeWorkspace = $resizeWorkspace;

    window.$infinityDesktop = $infinityDesktop$1;
    window.$infinityDesktopGetScale = $infinityDesktopGetScale$1;
    window.$infinityDesktopSet = $infinityDesktopSet;

}




function compileUsrCode(srcList){

    return new Promise(async res=>{
        usrWindows.length = 0;
        const usrCode = {};

        for(let path of srcList)
            usrCode[path] = await import(path);



        for (let [path, classObject] of Object.entries(usrCode)) {

            let Class = classObject.default;
            let test = new Class();

            if(test instanceof Class)
                usrWindows.push(test);

            test.initGUI();
        }



    })
}


let backupCanvas;
function getBackupCanvas(){
    if(backupCanvas) {

        backupCanvas.getContext('2d').clearRect(0, 0, backupCanvas.width, backupCanvas.height);
        return backupCanvas;

    }
    backupCanvas = document.createElement('canvas');

    backupCanvas.style['image-rendering']= 'pixelated';
    return backupCanvas;//document.createElement('canvas');
}








// let _customElements = {};
//
// const elements = {
//     define:export function(tagName, classObj){
//
//         if(_customElements[tagName])
//             return;
//
//         _customElements[tagName] = classObj;
//         customElements.define(tagName,classObj);
//     }
// };


function readLocalStorage(key){
//https://medium.com/nmc-techblog/introducing-the-async-cookie-store-api-89cbecf401f
    // return document.cookie.$match('(^|;)\\s*' + key + '\\s*=\\s*([^;]+)')?.pop();


    return JSON.parse(localStorage.getItem(key));


}







function $setGhostImg(canvas, controller = null){
    //TODO: temp canvas for cropping drag ghost image
    //https://stackoverflow.com/questions/43790022/html5-draggable-setdragimage-doesnt-work-with-canvas-on-chrome


    $assert(typeof canvas.toDataURL === 'function');

    let base64 = canvas.toDataURL();
    const isImg = canvas instanceof Image || canvas instanceof HTMLCanvasElement;
    if(!isImg){//
        const
            element = canvas,
            rootWin = $findRoot(element),
            boundary = [0,0,0,0];
        $assert(rootWin);

        multiply(boundary, element.transform, element.boundary);
        const canvas = document.createElement('canvas');
        const width = 100, ratio = boundary[2]/boundary[3];
        canvas.width = width;
        canvas.height = width/ratio;
        const ctx = canvas.getContext('2d');

        ctx.drawImage(rootWin.childNodes[0], ...boundary, 0,0, canvas.width, canvas.height);
        base64 = canvas.toDataURL();
    }


    if(controller == null ||
        (controller && !(controller.Mode & common$1.setting.CONTROLLER_MODE.emulating))) {

        __cursorCSS = `url(${base64}), pointer`;
        document.body.style.cursor = __cursorCSS;
    } else {
        window.__emulatingGhostImg = canvas;
    }
}

function $clearGhostImg(controller) {

    //TODO: temp canvas for cropping drag ghost image
    //https://stackoverflow.com/questions/43790022/html5-draggable-setdragimage-doesnt-work-with-canvas-on-chrome
    if (controller == null ||
        (controller && !(controller.Mode & common$1.setting.CONTROLLER_MODE.emulating))){
        __cursorCSS = 'default';
        document.body.style.cursor = __cursorCSS;
    }else {
        delete window.__emulatingGhostImg;
    }

}

let __cursorCSS = 'default';
function $resumeGhostImg(){

    document.body.style.cursor = __cursorCSS;

}
function $cancelGhostImg(){

    document.body.style.cursor = 'default';
}
let _reader;

if(typeof FileReader !== 'undefined')
    _reader = new FileReader();
const FILE_READER_LOCKER = 'common-file-reader-locker';

//https://developer.mozilla.org/en-US/docs/Web/API/FileReader/readyState
function readAsText(blob) {
    return lock$1(FILE_READER_LOCKER)
        .then(release=>  new Promise(async  (resolve, reject)=>{

        try{
            _reader.onload = function() {
                release();
                resolve(_reader.result);
            };

            _reader.readAsText(blob);
        }catch (e) {
            $assert(false,{msg:`readAsText error`});
            reject(e);
        }
    }));

}
function file2Img(file){
    return lock$1(FILE_READER_LOCKER)
        .then(release=>  new Promise( async (resolve, reject)=> {

        _reader.onload = evt => {
            let image = new Image();


            image.src = evt.target.result;
            image.onload = _=>{
                release();
                resolve(image);
            };
        };
        _reader.readAsDataURL(file);
    }));
}


function readFile(fileBlob){
    return lock$1(FILE_READER_LOCKER)
        .then(release=> new Promise( async res=>{

            _reader.onload =evt=>{
                release();
                return res(evt.target.result);
            };
            _reader.readAsArrayBuffer(fileBlob);
        }))



}

function getSourceClassNm(){
    // const stacks = $getStackLocationByIndex();
    const fileName =$getStackLocationByIndex(-2).match(/([^\/]+)\.js/g)[0];

    let klass = fileName.split('.')[0];
    klass = klass.charAt(0).toUpperCase() + klass.slice(1);
    return klass;
}
function delay(time){
    return new Promise(res=>{

        setTimeout(_=>{res();},time);
    })
}


let queueStore = {};
function queueChecker(fnc,interval){
    // let stack = $getStackLocationByIndex();
    const fncLocale = JSON.stringify($getStackLocationByIndex(-1));

    if(fnc())
        return;

    if(!queueStore[fncLocale])
        queueStore[fncLocale] = [];

    let job = {index:queueStore[fncLocale].length,status:'pending'};
    job.interval = setInterval(()=>{

        if(fnc()){
            job.status = 'done';
            clearInterval(job.interval);
            queueStore[fncLocale].splice(job.index,1);
        }
    }, interval);

    queueStore[fncLocale].push(job);

}

function $sleep(time = 100){
    return new Promise(resolve=>setTimeout(_=>resolve(), time));
}

function intervalChecker(conditionFnc,delayTime=30){
    return new Promise(async resolve=>{

        queueChecker(_=>{
            if(conditionFnc()){
                resolve();
                return true;
            }else {
                debugger;
                console.log("{intervalChecker} $assert delayed");
            }
        },delayTime);
    });
}

Number.prototype.clamp = function(min, max) {
    if(max<min)
        max = min;
    return Math.min(Math.max(this, min), max);
};
Number.prototype.lerp = function(t,min, max) {
    return min + (max-min)*(t.clamp(0,1));
};


function array2Color(array,alpha){


    if(array.length==3)
        if($isNumber$1(alpha))
            return 'rgba('+array[0]+','+array[1]+','+array[2]+','+alpha+')';
        else
            return 'rgb('+array[0]+','+array[1]+','+array[2]+')';
    else
        return 'rgba('+array[0]+','+array[1]+','+array[2]+','+array[3]+')';
}
//https://stackoverflow.com/questions/17977220/can-css3-translatez-be-used-instead-of-z-index
function setPosition(div,position,rotation=0) {
    div.style['transform'] = 'translate3d('+position[0]+'px,'+position[1]+'px,'+position[2]+'px) rotate('+rotation+'rad)';



    $resizeWorkspace();
}

function setGrayScale(div,value) {
    div.style['filter'] = `grayscale(${value*100}%)`;
}

function isEmptyObj(obj){
    return Object.entries(obj).length === 0 && obj.constructor === Object;
}

function degree2Rad(deg){
    return deg/180*Math.PI;
}

function rad2Degree(rad){
    return rad/Math.PI*180;
}

function getOffset(el,ref) {
    let rect = el.getBoundingClientRect(),
        refRect = ref.getBoundingClientRect();
    return {
        left: rect.left -  refRect.left,
        top: rect.top -  refRect.top,
        width: rect.width || el.offsetWidth,
        height: rect.height || el.offsetHeight
    };
}




let color = {};

function genColor(){
    let r = Math.round(Math.random()*255),
        g =  Math.round(Math.random()*240),
        b = Math.round(Math.random()*250);

    if(!color[[r,g,b].join('|')]){
        color[[r,g,b].join('|')] = true;
        return [r,g,b];
    }else
        return genColor();
}
function loadImg(url){
    return new Promise( (resolve, reject)=> {
        const img = new Image();
        img.src = url;
        img.onload =_=>resolve(img);
    });
}

function blob2Img(blob){
    return new Promise(resolve=>{
        const result = new Image();
        result.src = URL.createObjectURL(blob);
        result.onload =_=> {
            URL.revokeObjectURL(result.src);
            resolve(result);
        };
    });
}


function $base64ToFileBlob (base64,type = 'image/gif') {
    return new Promise(resolve => {
        const req = new XMLHttpRequest();
        base64 = base64.split(',').length===2?base64:`data:application/octet;base64,${base64}`;
        req.open('GET', base64);
        req.responseType = 'arraybuffer';
        req.onload = e => resolve(new Blob([new Uint8Array(e.target.response)],{type}));
        req.send();
    });
}

function $img2Base64(image){

    const backupCanvas = document.createElement('canvas');
    backupCanvas.width = image.width;
    backupCanvas.height = image.height;

    const ctx = backupCanvas.getContext('2d');
    ctx.drawImage(image,0,0);
    return backupCanvas.toDataURL();
}

async function $fileBlob2Base64(uint8) {
    // Use a FileReader to generate a base64 data URI
    const base64url = await new Promise(resolve => {
        const reader = new FileReader();
        reader.onload =_=> resolve(reader.result);
        reader.readAsDataURL(new Blob([uint8]));
    });

    /*
    The result looks like
    "data:application/octet-stream;base64,<your base64 data>",
    so we split off the beginning:
    */
    return base64url.split(",", 2)[1]
}




function img2File(img, fileName = 'unnamed'){

    return new Promise(resolve=> {
        fetch(img.src)
            .then(res => res.blob())
            .then(blob => {
                resolve(new File([blob], fileName, blob));

            });
    });
}

function $JSON2File(json,fileName= 'unnamed'){
    const blob = new Blob([JSON.stringify(json)], { type : 'plain/text' });
    return Promise.resolve(new File([blob], fileName));
}

// export function fileUpload(img, file) {
//     const xhr = new XMLHttpRequest();
//     this.xhr = xhr;
//
//     this.xhr.upload.addEventListener("progress",  evt=>{
//         if (evt.lengthComputable) {
//             const percentage = Math.round((evt.loaded * 100) / evt.total);
//         }
//     }, false);
//
//     xhr.upload.addEventListener("load", evt=>{
//         //self.ctrl.update(100);
//     }, false);
//     xhr.open("POST", "http://demos.hacks.mozilla.org/paul/demos/resources/webservices/devnull.php");
//     xhr.overrideMimeType('text/plain; charset=x-user-defined-binary');
//     getReader().onload = evt=> {
//         xhr.send(evt.target.result);
//     };
//     getReader().readAsBinaryString(file);
// }
function b64toUint8(b64Data){
    const byteCharacters = atob(b64Data);
    const result = new Uint8Array(byteCharacters.length);
    for (let i = 0; i < byteCharacters.length; i++)
        result[i] = byteCharacters.charCodeAt(i);

    return result;
}
function b64toBlob(b64Data, contentType='image/png', sliceSize=512){
    const byteCharacters = atob(b64Data);
    const byteArrays = [];

    for (let offset = 0; offset < byteCharacters.length; offset += sliceSize) {
        const slice = byteCharacters.slice(offset, offset + sliceSize);

        const byteNumbers = new Array(slice.length);
        for (let i = 0; i < slice.length; i++) {
            byteNumbers[i] = slice.charCodeAt(i);
        }

        const byteArray = new Uint8Array(byteNumbers);
        byteArrays.push(byteArray);
    }

    const blob = new Blob(byteArrays, {type: contentType});
    return blob;
}



const tick = Date.now();




function log (_){
    console.log(`${_} \n elapsed: ${Date.now()-tick}`);
}

function $findRoot(obj){
    $assert(obj);
    const result = obj.Parent?$findRoot(obj.Parent):obj;
    return result;
}

function refreshWindow(comp){
    const window = $findRoot(comp);
    window.refresh();
}

function objList2FullNameList(list){
    let result = [];
    for(let obj of list)
        result.push(obj.FullName);
    return result;
}

const $OUTLINE_RENAME_CHECKER =
    (parent, name)=>
        parent.getConnection(ConnectionType.outputs,'children')
        .map(ele=>$readPath(ele.EntryFileName).fileNm)
        .includes($readPath(name).fileNm);




function $getValidName(parent,name,
          checker=(curEle,name)=>curEle.Children.map(ele=>ele.name).includes(name),
          ref={ext:'', baseName:name, appendix:''}){


    if(ref.baseName == name){
        const {fileNm,fileExt} = $readPath(name);
        ref.baseName = fileNm, ref.ext = fileExt;

        const [,baseName, appendix] = $match(/(\D+)?(\d+)?$/g, ref.baseName);
        ref.appendix = appendix??0;
        ref.baseName = baseName;
    }


    if(checker(parent, name)){//__OUTLINE_RENAME_RULE_FILE_CHECK(getChildren, name)
        const ext = ref.ext?`.${ref.ext}`:'';
        return $getValidName(parent,`${ref.baseName??''}${++ref.appendix}${ext}`, checker, ref)
    }else
        return name;
}

function findParentElementByType(curObj, type){

    if(curObj instanceof type)
        return curObj;
    else if(curObj.parentElement instanceof type)
        return curObj.parentElement;
    else if(curObj.parentElement)
        return findParentElementByType(curObj.parentElement, type);
    else
        return null;
}


function $findParentByType(curObj, type){

    if(curObj instanceof type)
        return curObj;
    else if(curObj.Parent instanceof type)
        return curObj.Parent;
    else if(curObj.Parent)
        return $findParentByType(curObj.Parent, type);
    else
        return null;
}

function findParentsOf(out,ele,condition=ele=>true,getParent=ele=>ele.Parent){
    $assert(typeof condition == 'function');


    // if(condition(ele))
    //     out.push(ele);
    // debugger;
    const parent = getParent(ele);
    $assert(parent != ele, {msg:'circular data reference'});
    if(!parent)
        return;


    if(condition(parent))
        out.push(parent);

    findParentsOf(out, parent, condition,getParent);

}

function getParentsOf(ele,condition,getParent){
    const result = [];
    findParentsOf(result, ele,condition,getParent);
    return result;
}






function $readFileDataValue(path){
    const data = $getAttr$1(path),
        dataType = $getFileDataType(path);
    return $getDataValue(data,dataType);
}function getPaddingNum(name){
    const buf = name.match(/(.+)(\d+)/);
    if(!buf)
        return null;
    const result =  Number(buf[2]);
    $assert($isNumber$1(result));
    return result;
}

function setCSSData(component, key, val){
    component[key] = {left:0,right:0,top:0,bottom:0};
    if(Array.isArray(val))
        component[key].left =      $getNumber(val[0]),
            component[key].right =     $getNumber(val[1]),
            component[key].top =       $getNumber(val[2]),
            component[key].bottom =    $getNumber(val[3]);
    else if($isNumber$1(val)){
        const num = $getNumber(val);
        component[key] = {left:num,right:num,top:num,bottom:num};
    } else if($isNumber$1(val.left) &&$isNumber$1(val.right) &&$isNumber$1(val.top) &&$isNumber$1(val.bottom)){

        component[key] = {left:$getNumber(val.left),
            right:$getNumber(val.right),
            top:$getNumber(val.top),
            bottom:$getNumber(val.bottom)};
    }
}
function $findByFullName(fullName){

    $assert(fullName);

    if(!/\//.test(fullName)){
        $assert(Keanu.editors.objs[fullName]);
        return Keanu.editors.objs[fullName];
    }
    let names = fullName.split('/');
    const editor = Keanu.editors.objs[names[0]];
    $assert(editor);

    $assert(editor.Controller);
    if(fullName == editor.Controller.FullName)
        return editor.Controller;

    //clipping "Outline/controller" from 'Outline/controller/layout/a/b'
    names =   names.slice(2, names.length);
    names.unshift('');
    return _getElement(editor.Controller, names.join('/'));

}

// export function getChildrenOf(ele,condition=_=>true,getChildren){
//     // if(!condition) //only one param
//     //     condition = ele,
//     //         ele = window.Keanu.editors.objs['Outline']?window.Keanu.editors.objs['Outline'].Content:window.Keanu.editors.objs['History'].Content;
//
//     $assert(ele);
//
//     let result= [];
//     findChildrenOf(result, ele, condition,getChildren);
//     result.shift();
//     return result;
// }
// export function findAllByName(out, ele,name){
//     $assert(ele&&ele.Children);
//
//     if(ele.Children[name])
//         out.push(ele.Children[name]);
//     else
//         for(let child of ele.Children)
//             findAllByName(out,child, name);
// }

function _getElement(ele,name){
    if(ele.name == name) return ele;

    $assert(/\//.test(name));
    let stack = $match(/[^\/]+/gm, name),
        curName,curEle = ele;

    while(curName = stack.shift()){
        if(curEle&&curEle.Children.toObject()[curName])
            curEle = curEle.Children.toObject()[curName];
    }
    return curEle;
}




function findChildrenOf(out,ele,condition,getChildren=ele=>ele.Children.toArray()){
    const children = getChildren(ele);

    if(condition(ele))
        out.push(ele);

    for(let child of children)
        findChildrenOf(out,child, condition,getChildren);
}


function checkIfInsideObj (pos, obj) { //method = 'global'
    $assert(obj);
    if (!obj.transform) //obj instanceof Controller
        return true;

    const transform = obj.transform,
        boundary = obj.Boundary;
    $assert(transform);
    $assert(boundary);
    // if(method == 'global'){
    //     Transform.multiplyInv(pos, this.transform.globalMatrix, pos);
    //     return  pos[0]>=boundary[0] &&
    //             pos[1]>=boundary[1]&&
    //             pos[0]<boundary[0]+boundary[2]&&
    //             pos[1]<boundary[1]+boundary[3];
    // }else if(method == 'local'){
    //
    //     Transform.multiplyInv(pos, this.transform.localMatrix, pos);
    //     return  pos[0]>=boundary[0]&&
    //             pos[1]>=boundary[1]&&
    //             pos[0]<boundary[0]+boundary[2]&&
    //             pos[1]<boundary[1]+boundary[3];
    // }

    multiplyInv(pos, transform, pos);
    return $isInsideBoundary(pos, boundary);
}





function $activeWin(evt){

}
function $activateWindow(win){
    const
        UIWindow = win.constructor,
        windows = UIWindow.windows,
        index = windows.findIndex(ele=>{return ele == win});

    windows.splice(index,1);
    for(const win of windows){
        win.Controller.Status &=~ common$1.setting.CTRL_STATUS.active;
        win.style['box-shadow'] = 'none';
        win.Status &= ~UIWindow.STATUS.focus;
    }
    UIWindow.windows.unshift(win);
    win.style['box-shadow'] = win.boxShadow;
    win.status |= UIWindow.STATUS.focus;
    win.status |= UIWindow.STATUS.rendering;

    win.Controller.Status |= common$1.setting.CTRL_STATUS.active;

    //https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/focus
    //HTMLEle focus()
    win.focus();

    $assert(document.activeElement === win);


    for(let i in UIWindow.windows)
        UIWindow.windows[i].style['z-index'] = -parseInt(i)+common$1.setting.MAX_WINDOWS;

}


function $wheelDelta2Scale(dy){

    const WHEEL_SCALE_SPEEDUP = 2;
    return dy <= 0 ?
        1 - (WHEEL_SCALE_SPEEDUP * dy) / 100 :
        1 / (1 + (WHEEL_SCALE_SPEEDUP * dy) / 100);
}
function $wheelDelta2Move(deltaValue){
    const WHEEL_TRANSLATION_SPEEDUP = 2;
    return WHEEL_TRANSLATION_SPEEDUP * deltaValue;
}

let
    _infinityDesktopIsOn = true,
    _scale = 1, _x = 0, _y= 0, _oriX,_oriY;


function $traditionEvt4Focus(){
    const root = document.getElementById('root');
    const  __active = evt =>{
        const
            editorName = evt.target.getAttribute('editorName'),
            editor = Keanu.editors.objs[editorName];
        if(editorName && evt.target instanceof HTMLCanvasElement)
            editor.active();

    };
    root.addEventListener("pointerdown",__active,{capture:false});
    root.addEventListener("pointerover",evt=>{
        if(evt.buttons)
            __active(evt);
    },{capture:true});



    // editor.addEventListener("wheel",active,{capture:true});

}

function getArrayLabel(length){

    //x0  y0  z0
    //x1  y1  z1
    //x2  y2  z2
    if(length == 9 || length>4)
        return ['X0', 'X1', 'X2', 'Y0', 'Y1', 'Y2', 'Z0', 'Z1', 'Z2'];



        //x0  y0
    //x1  y1
    else if(length == 4)
        return ['X0', 'X1', 'Y0', 'Y1'];


    else
        return ['X','Y','Z'];



}
function onStatusDoing(MODEs, target){
    const result = [];
    for(const MODE_KEY in MODEs){
        const MODE = MODEs[MODE_KEY];
        if(target.Mode & MODE && /ing/.test(MODE_KEY))
            result.push(MODE_KEY);
    }
    return result;
}

function $guiCatcher(fnc) {
    return function (dataEntry) {
        try{

            const path = dataEntry['.path'];
            return fnc(dataEntry)
                .then(comp=>{//could be layout or comp
                    $assert(comp);
                    comp.Path = $path2ID(path);
                    return Promise.resolve();
                });
        }catch (err){
            console.log(err);
        }
    }
}
function $getProjFolder() {
    return `${window.config['owner']}/${window.config['projName']}`;

}



async function $assert(condition,info={
    errorType:common$1.error.ERR_TYPE.internalErr,
    msg:`assertion failed`,
    path:null
}){
    if(!condition) {
        const {msg, errorType, pathID, data} = info;
        if(pathID){
            console.warn(msg);
        }else {
            console.error(msg);
            debugger;
        }
        if(KError)
            await KError.generate(errorType, {msg,pathID,data});
        else
            throw new Error(msg);

    }
}const
    __checkOpen = async _=>{
        if(!window.config.palette) return null;

        const
            __palettePathRegex = new RegExp(`${window.config['palette']}.palette$`),
            file = $getFiles$1(__palettePathRegex);
        if(file.length == 0) return null;

        const palette = Keanu.editors.objs['Palette'];
        const isOpen = __palettePathRegex.test(palette.path);
        if(!isOpen)
            await Event.Instance.emit(INTERNAL(common$1.setting.EVT_TYPES.openFile), undefined, [file[0].path]);
    },

    __refreshBegin = async _=>{
        // if(!refreshGUI) return Promise.resolve();
        for(const [name, win] of Object.entries(Keanu.editors.objs)){
            if(!isImplement(win, IWindow))
                continue;

            win.Status |= common$1.setting.STATUS.loading;
            await GUI.$REFRESH_LOCK_BEGIN(win);
        }},
    __refreshEnd = async  _=>{
        // if(!refreshGUI) return Promise.resolve();
        for(const [name, win] of Object.entries(Keanu.editors.objs)){
            if(!isImplement(win, IWindow))
                continue;

            await __checkOpen();
            win.Status &= ~common$1.setting.STATUS.loading;
            await GUI.$REFRESH_LOCK_END(win);
        }
    };

const $refreshAllBegin = __refreshBegin,
    $refreshAllEnd = __refreshEnd;

function $batchEmit(jobs, params= {
        writeHistory:true,
        upload:false,
        internal:false,
        sleepingInProgress:parseInt(window.config['sleep']??"0"),
        fastRewind:false,
        // refreshGUI:false,
}) {
    return new Promise(async (resolve,reject)=>{
        let sleepingInProgress = params.sleepingInProgress??parseInt(window.config['sleep']??"0");

        const evt = Event.Instance,
            release = await lock$1(ROOT_LOCKER_EMIT);

        evt.Mode |= Event.MODE.batchEmitting;


        const
            fastRewind =  params.fastRewind ?? sleepingInProgress === 0,
            writeHistory = params.writeHistory??true,
            upload = params.upload??false,
            internal = params.internal??false;

        const // following these are relating to rerender other window,
            // and slowing down render process.
            setAttr = common$1.setting.EVT_TYPES.setAttr,
            select = common$1.setting.EVT_TYPES.select,
            openFile = common$1.setting.EVT_TYPES.openFile,
            onRender = common$1.setting.EVT_TYPES.onPaletteRenderChange.match(/@(.+)/)[1];

        const   setAttrSubs = EventDispatcher.Subscribers[setAttr]??[].slice(),
            selSubs =  EventDispatcher.Subscribers[select]??[].slice(),
            openSubs = EventDispatcher.Subscribers[openFile]??[].slice(),
            renderSubs =EventDispatcher.Subscribers[onRender]??[].slice(),
            sysSub = setAttrSubs.normalArray[0];

            //$readFileDataValue(`${window.config['projPath']}|sleepingInProgress`);

        if(sleepingInProgress && (evt.Mode & Event.MODE.recalling))
            sleepingInProgress = 0;



        if(fastRewind){
            EventDispatcher.Subscribers[setAttr] = new NegArray([sysSub]);
            EventDispatcher.Subscribers[select] = new NegArray();
            EventDispatcher.Subscribers[openFile] = new NegArray();
            EventDispatcher.Subscribers[onRender] = new NegArray();

        }

        for(const cmd of jobs){
            $assert(cmd&&$isNumber$1(cmd.index));

            if(!fastRewind && sleepingInProgress)
                await __refreshBegin();

            console.log(cmd.index, cmd);

            await evt.emit(
                internal?'@'+cmd.type:cmd.type,

                cmd.params, {
                    writeHistory: writeHistory,//cmd.usrName == window.config.usrName?false:true,
                    index:cmd.index,
                    upload: upload,
                    timestamp: cmd.timestamp,
                    device:cmd.device
                });
            if(!fastRewind && sleepingInProgress){
                await __refreshEnd();
                await $sleep(sleepingInProgress);
            }
        }
        if(fastRewind){
            const wrapper = subs=> subs.length?subs:undefined;
            EventDispatcher.Subscribers[setAttr] = wrapper(setAttrSubs);
            EventDispatcher.Subscribers[select] =  wrapper(selSubs);
            EventDispatcher.Subscribers[openFile] = wrapper(openSubs);
            EventDispatcher.Subscribers[onRender] = wrapper(renderSubs);
        }

        release();

        evt.Mode &= ~Event.MODE.batchEmitting;
        return resolve();
    })

}

//https://stackoverflow.com/questions/7616461/generate-a-hash-from-string-in-javascript/22429679
//https://werxltd.com/wp/2010/05/13/javascript-implementation-of-javas-string-hashcode-method/
function hashStr(uint8){
    let result = '';
    for(let i in uint8){
        let hex = uint8[i].toString(16);
        result += hex;
    }
    return result;
}function hashCode(input) {
    let hash = 0, i, chr;
    if (input.length === 0) return hash;
    for (i = 0; i < input.length; i++) {
        chr   = input.charCodeAt(i);
        hash  = ((hash << 5) - hash) + chr;
        hash |= 0; // Convert to 32bit integer
    }
    hash = hash >>>0;
    if(hash.toString(16).length>8)//4*8/2
        throw new Error('hash code exceed maxium space');

    const
        timestamp  =     Math.floor(Date.now()/1000),
        result = new Uint8Array(8);//4*8 + 4*8
    result[0] = hash & 0xFF;
    result[1] = (hash>>>8) & 0xFF;
    result[2] = (hash>>>16)  & 0xFF;
    result[3] = (hash>>>24)  & 0xFF;


    result[4] = timestamp & 0xFF;
    result[5] = (timestamp>>>8)  & 0xFF;
    result[6] = (timestamp>>>16)  & 0xFF;
    result[7] = (timestamp>>>24)  & 0xFF;


    return result;
}
function findSubAvailableIndex(ref, subArr){
    if(subArr[ref.index]){
        ref.index>=0?ref.index++:ref.index--;
        findSubAvailableIndex(ref, subArr);
    }else
        return;
}


//https://stackoverflow.com/questions/68860255/how-to-match-the-closest-opening-and-closing-brackets
function isArrowFn (fn) {
    // (fn) =>
    if(typeof fn != 'function')
        return false;

    const regex = /function([^()]*)([(][^()\[\]]*?[)])\s*{(.*)}/gm,
        result = $match(regex,fn.toString().split('\n').join());

    return result.length?false:true;
}

//SAFARI is pain in the ass
//https://stackoverflow.com/questions/38508420/how-to-know-if-a-function-is-async
function isAsyncFn(fn){
    if(__ua.browser == 'Safari'){
        const string = fn.toString().trim();

        return !!(
            // native
            string.match(/^async /) ||
            // babel (this may change, but hey...)
            string.match(/return _ref[^\.]*\.apply/)
            // insert your other dirty transpiler check

            // there are other more complex situations that maybe require you to check the return line for a *promise*
        );
    }else

        return fn.constructor.name == 'AsyncFunction';
}


class NegArray{
    array;
    normalArray = [];
    constructor(array) {
        this.array = array??[];
        this.normalArray = this.normalize();
    }
    length =_=>this.array.length;
    exist = ele=> this.normalArray.find(ele)?true:false;
    insert(index, ele){
        if($isNumber$1(index)){
            const refIndex = {index};
            findSubAvailableIndex( refIndex, this.array);
            this.array[refIndex.index] = ele;
            this.normalArray = this.normalize();
        }
    }
    push= ele=> {
        this.array.push(ele);
        this.normalArray = this.normalize();
    };

    clear(){
        this.array.length = 0;
        this.normalArray.length = 0;
    }

    slice(){
        return new NegArray(this.array);
    }
    remove(pre){
        // debugger;
        // let a = [1,23,4,5,2,522,212]; a['-1'] = 0;
        // for(const [key, val] of Object.entries(a))
        //     debugger;

        this.array = this.array.filter(ele=>!pre(ele));
        this.normalArray = this.normalArray.filter(ele=>!pre(ele));
    }


    normalize(){
        const result = [], negArr = [];
        // {
        //     '-1':{value:-1},'-4':{value:-2},'-5':{value:-3},
        //     '3':{value:3},  '2':{value:2},  '1':{value:1},
        // }
        for(const [key, value] of Object.entries(this.array)){//
            if(!$isNumber$1(key))
                continue;
            const index = parseInt(key);
            if(index>=0)
                result.push({index, value});
            else
                negArr.push({index, value});
        }

        result.sort((a,b)=>a.index - b.index);
        negArr.sort((a,b)=>a.index - b.index);

        // const length = result.length + negArr.length;
        // for(const {index,value} of negArr)
        //     result.splice(result.length + index + 1,0, {index,value});
        // return result.map(ele=>ele.value);

        return [...negArr.map(({value})=>value),...result.map(({value})=>value)]
    }



}

function invertStatus(data, mask){
    // let base = data&(~bit>>>0),
    //     inverseBit = (~(data & mask) >>>0)&mask;
    return data&(~mask>>>0) | (~(data & mask) >>>0)&mask;
}


function formatDate(timestampStr){

    const timestamp = parseInt('0x'+timestampStr,16),
        dateArray = new Date(timestamp).toString().split(' ');

    return dateArray[4]+' '+dateArray.slice(1,3).join('-');
}


// export function getPaletteSelectionBoundaryRange(selection){
//     const indexBoundary = [Math.maxInt,Math.maxInt, 0,0];
//     for(let sel of selection){
//         if(sel.index[1]<indexBoundary[0])
//             indexBoundary[0] = sel.index[1];
//         if(sel.index[0]<indexBoundary[1])
//             indexBoundary[1] = sel.index[0];
//         if(sel.index[1]>indexBoundary[2])
//             indexBoundary[2] = sel.index[1];
//         if(sel.index[0]>indexBoundary[3])
//             indexBoundary[3] = sel.index[0];
//     }
//     return indexBoundary;
//
// }
function $intersectSelBoundary(a,b){
    a = [0,0]; b = [1,0,1,1];
    a[2] = (a[2]??1) + a[0];
    a[3] = (a[3]??1) + a[1];

    b[2] = (b[2]??1) + b[0];
    b[3] = (b[3]??1) + b[1];
    if($isBoundaryOverlap(a,b,'AABB') === false) return false;

    let result = [];
    if(b[0] < a[0]) result[0] = '-';
    if(b[0] > a[0] && b[2] < a[2]) result[0] = '=';
    if(b[2] > a[2]) result[0] = '+';


    if(b[1] < a[1]) result[1] = '-';
    if(b[1] > a[1] && b[3] < a[3]) result[1] = '=';
    if(b[3] > a[3]) result[1] = '+';

    return result;
}
function _splitBoundaryByline(boundary, dir = 'x', value){
    const [x,y,w,h] = boundary;
    if(dir === 'y')
        return [[x,y,value-x,h], [value,y,w-value,h]];
    else if(dir === 'x')
        return [[x,y,w,value-y], [x,value,w,h-value]];

}
function $splitBoundaries(boundaries, dir, value){
    const bounds = boundaries.slice();
    for(const boundary of bounds){
        boundaries = boundaries.filter(ele=>ele.toString() === boundary.toString());
        boundaries.push(..._splitBoundaryByline(boundary, dir, value));
    }
}

const $isBoundaryOverlap = function(a, b, mode = 'boundary') {

    if(mode === 'boundary'){ //convert2 AABB

        a = a.slice();
        b = b.slice();

        a[2] = (a[2]??1) + a[0];
        a[3] = (a[3]??1) + a[1];

        b[2] = (b[2]??1) + b[0];
        b[3] = (b[3]??1) + b[1];
    }

    const   d1 = [(b[0] - a[2]),(b[1] - a[3])],
            d2 = [(a[0] - b[2]),(a[1] - b[3])];

    if (d1[0] >= 0.0 || d1[1] >= 0.0)return false;
    if (d2[0] >= 0.0 || d2[1] >= 0.0)return false;


    return true;
};
function combineBoundary(out, a, b, direction){
    if(a == null){
        $assert(b);
        return b;
    }

    if(b == null){
        $assert(a);
        return a;
    }

    a = a.slice(); b = b.slice();
    a[2] += a[0], a[3] += a[1];
    b[2] += b[0], b[3] += b[1];

    if(direction.includes('x'))
        out[0] = a[0] < b[0] ? a[0] : b[0];

    if(direction.includes('y'))
        out[1] = a[1] < b[1] ? a[1] : b[1];


    if(direction.includes('x'))
        out[2] = a[2] > b[2] ? a[2] : b[2];


    if(direction.includes('y'))
        out[3] = a[3] > b[3] ? a[3] : b[3];


    if(direction.includes('x'))
        out[2] -= a[0];

    if(direction.includes('y'))
        out[3] -= a[1];
    return out;
}
function addBoundary(instance,condition, direction){

    $assert(instance.Boundary);
    let result = instance.Boundary.slice();
    for(let child of instance.Children){

        if(!condition(child))
            continue;

        const childBoundary = [0,0,0,0];
        multiply(childBoundary,child.transform.localMatrix,child.boundary,'boundary');

        combineBoundary(result, result, childBoundary,direction);
    }
    return result;

}

function refreshBoundary(instance, condition, direction = ['x', 'y'], ref){
    $assert(condition);
    // if(instance.FullName == 'Brush/controller/mainLayout/twoPanelBody/body/canvasLayout/kCanvas/group') debugger;

    const addedDelCheck = ele => condition(ele) &&  !(ele.StatusOfMasked & common$1.setting.STATUS.deleting);

    const ends = depthFirstSearchHierachy(instance,addedDelCheck,ele=>ele.Children.toArray(),ref);

    ends.pop();//pop out branch ends
    ends.reverse();

    const grp = ends.slice();
    while(grp.length) {
        let nodes = grp.shift();
        for (let node of nodes)
            node.Boundary = addBoundary(node, addedDelCheck, direction);
    }

}

function depthFirstSearch(root, condition =_=>true, getChildren = ele=>{
    $assert(ele&&ele.Children);
    return ele.Children.toArray();
}, ref){
    $assert(root);
    const result = condition(root)?[root]:[];
    downstreamFindDFS(result, root, condition,getChildren, ref);
    return result;
}
// export const $getEntry = function(path){
//     if(!path) path = $getKeanuPath();
//     return $listAllFiles()
//         .find(entry=>entry.Path == path);
// }

function downstreamFindDFS(out,ele, condition,getChildren, ref = null){

    if(ref){
        ref.index = ref.index??0;
        if($isNumber$1(ref.depth)&& ref.index == ref.depth)
            return;
        ++ref.index;
    }

    for(let child of getChildren(ele)) {
        if(!condition(child))
            continue;
        out.push(child);
        downstreamFindDFS(out, child, condition,getChildren, ref);
    }
}

function depthFirstSearchHierachy(root, condition =_=> true, getChildren = ele=>ele.Children.toArray(), ref = {index:0}){
    let result = [[root]];
    DFSHierachy(result, root, condition,getChildren, ref);
    return result;
}
function DFSHierachy(out,curNode,condition, getChildren,ref){
    ref = ref??{};
    ref.index = ref.index??0;
    if($isNumber$1(ref.depth)&&ref.index == ref.depth)
        return;

    const index = ++ref.index;

    const pool = [];

    for (let child of getChildren(curNode)) {

        if(!condition(child))
            continue;

        pool.push(child);

    }


    if(pool.length){
        if(!out[index])
            out[index] = [];
        out[index] = out[index].concat(pool);
    }


    for(let child of pool)
        DFSHierachy(out,child,condition,getChildren, ref);

}
function breathFirstSearch(root, condition =_=> true, getChildren = ele=>ele.Children.toArray(), ref = {index:0}){
    let result = [root];
    return BFS(result, condition,getChildren);
}

function BFS(out,condition, getChildren,ref){
    const result = [];
    while(out.length){
        const curNode = out.shift();
        result.push(curNode);
        for (let child of getChildren(curNode)) {
            if(condition(child))
                out.push(child);
        }

    }
    return result;
}


// const width = boundary[2]*scale, height = boundary[3]*scale,
//     halfW = width*0.5, halfH = height*0.5;
// const offset = [-halfW+boundary[2]*0.5, -halfH+ boundary[3]*0.5],
//     posOrigin = [boundary[0]+offset[0], boundary[1]+offset[1]],
//     pivot = [posOrigin[0]+ 0.5*width, posOrigin[1]+0.5*height];
//
// ctx.save();
// ctx.globalAlpha = alpha;
// ctx.translate(pivot[0],pivot[1]);
// ctx.rotate(degree2Rad(-degree));
// ctx.translate(-pivot[0],-pivot[1]);


function getHighlightShadowScale(boundary,degree){
    const width = boundary[2], height = boundary[3],
        angleA = Math.atan(width/height),
        angleX = degree2Rad(90) - angleA - degree2Rad(degree),
        hypotenuse = Math.sqrt(width*width+height*height),
        scale = Math.cos(angleX)*hypotenuse/boundary[2];
    return scale;
}

function highlightShadow(degree, img, boundary){
    return new Promise(res=>{

        const backupCanvas = document.createElement('canvas');
        const ctx = backupCanvas.getContext('2d'),
            scale = getHighlightShadowScale(boundary,degree);

        const
            width = scale*boundary[2], height = scale*boundary[3],
            halfW = width*0.5, halfH = height*0.5,
            offset = [halfW- boundary[2]*0.5, halfH-boundary[3]*0.5];


        backupCanvas.width = width;
        backupCanvas.height = height;

        ctx.translate(-offset[0],-offset[1]);
        ctx.translate(halfW,halfH);
        ctx.rotate(degree2Rad(-degree));
        ctx.translate(-halfW,-halfH);

        const pattern = ctx.createPattern(img, 'repeat');
        ctx.fillStyle = pattern;

        ctx.fillRect(0,0, width, height);

        let resImg = new Image();
        resImg.src = backupCanvas.toDataURL();
        resImg.onload =_=>{
            res(resImg);
        };
    })



}


//https://www.tjvantoll.com/2015/09/13/fetch-and-errors/
//https://developer.mozilla.org/en-US/docs/Web/API/Response/body
//https://developer.mozilla.org/en-US/docs/Web/API/ReadableStream
//https://developer.mozilla.org/en-US/docs/Web/API/Streams_API/Using_readable_streams
function $fetch(url,  callback) {
    const param = {length:0, loaded:0};
    return fetch(url)
        .then(response=>{
            if (!response.ok)    {        //fetch cannot throw Error unless connection lost
                debugger;
                throw new Error(
                    common$1.error.ERR_TYPE.serverErr|common$1.error.ERR_TYPE.cosErr|common$1.error.ERR_TYPE.illegalURL404,
                    {url});
            }
            const LENGTH = response.headers.get("Content-Length");
            if(!LENGTH)
                console.warn(url, 'header "Content-Length" is missing');
            param.length = Number(response.headers.get("content-length"));
            return Promise.resolve(response);
        })
        .then(response => response.body)
        .then(body => {
            const reader = body.getReader();
            return new ReadableStream({
                start(controller) {
                    return pump();
                    function pump() {
                        return reader.read().then(({ done, value }) => {
                            if (done) {// When no more data needs to be consumed, close the stream
                                controller.close();
                                return;
                            }
                            // Enqueue the next data chunk into our target stream
                            controller.enqueue(value);
                            param.loaded += value.length;
                            if(callback)
                                callback(param.length?param.loaded/param.length:param.loaded);
                            return pump();
                        });
                    }
                }
            });
        })
        .then(stream => new Response(stream))
        .then(response=>response.blob())

}
function genDiagonalSortDict(n=4){
    const result = [],
        N = (n-1)*2;
    //upper diagonal
    for(let i=0; i<= N; i++){
        const SUM = i;
        for(let j = 0; j<= N;j++){
            const col = SUM-j,row = j;
            if(col>=0 && col<n && row>=0 && row<n)
                result.push([col,row]);
        }
    }
    return result;
}
function pyramid(pivot, n ,N = 128,dir = '-y') {
    const result = [];
    for(let offsetU = 0; offsetU < Math.round(n/2);offsetU++){
        const  vSize = n - (offsetU*2);

        const u = (dir === '-x'?pivot[0]:pivot[1]) - offsetU,
                isOutOfBound =  (input,N)=>{
                    if (input < 0 || input >= N) return true;
                    return false;
                };
        if(isOutOfBound(u,N)) continue;
        for(let offsetV = 0; offsetV< vSize;offsetV++){

            const v = (dir === '-x'?pivot[1]:pivot[0]) + offsetV + offsetU;
            result.push(dir === '-x'?[u,v]:[v,u]);
        }
    }
    return result;
}




function _swapSort(refGroup,refIndex,pathID,N,LEFT_PIVOT, LEFT_SIZE,dir){

    let swapIndice = [];
    for(const pIndex of pyramid(LEFT_PIVOT,LEFT_SIZE, N, dir)){
        const pickerList = $pickByPaintSolver(pathID, [...pIndex,1,1]);
        for(const [col,row] of pickerList){
            const occupierIndex = refGroup.findIndex(ele=>ele.index.toString() === [col,row].toString());
            if(occupierIndex>refIndex)
                swapIndice.push(occupierIndex);
            
        }
    }
    return swapIndice;
}
const SORT_MODE = {none:1,diagonal:2,bulk:4};
function $sortingGrid(out,pathID, contents, N,mode = SORT_MODE.diagonal){
    out.length = 0;


    if(mode & SORT_MODE.none) {
        for(const indexKey in contents) {
            const [col, row] = $getNumber(indexKey.split(','));

            out.push({index: [col, row], data: contents[indexKey]});
        }
    }else {

        const arr = [];
        for (const indexKey in contents) {
            const [col, row] = $getNumber(indexKey.split(','));
            if (!arr[col])
                arr[col] = [];
            arr[col][row] = contents[indexKey];
        }


        genDiagonalSortDict(N).forEach(([col, row]) => {
            if (arr[col] && arr[col][row])
                out.push({index: [col, row], data: arr[col][row]});
        });
        if (mode & SORT_MODE.diagonal) return out;

        const bulks =  out.slice();
        //out.filter(({data}) => data.boundary && (data.boundary[2] > 1 || data.boundary[3] > 1));


        const swapRules = [], ITER_NUM = 3;
        for (const bulkIndex in bulks) {
            const
                //refIndexBulk = out.findIndex(ele => JSON.stringify(ele) === JSON.stringify(bulk)),
                bulk = bulks[bulkIndex],
                index = bulk.index.slice(),
                size = bulk.data.boundary[2];
            if (index[0] < 0 || index[1] < 0)
                continue;

            //left
            const LEFT_PIVOT = [bulk.index[0] - 1, bulk.index[1] + 1],
                LEFT_SIZE = size - 1;
            const leftSwapIndice = _swapSort(bulks, bulkIndex, pathID, N, LEFT_PIVOT, LEFT_SIZE, '-x',) ?? -1;


            //right
            const RIGHT_PIVOT = [bulk.index[0] + 2, bulk.index[1] - 1],
                RIGHT_SIZE = size - 2;
            const rightSwapIndice = _swapSort(bulks, bulkIndex, pathID, N, RIGHT_PIVOT, RIGHT_SIZE, '-y') ?? -1;

            for(const index of [...leftSwapIndice, ...rightSwapIndice])
                                //TOP                  //Bottom
                swapRules.push([bulks[bulkIndex].index, bulks[index].index]);
        }

        const findIndex =(arr, index)=> arr.findIndex(ele=>ele.index[0] === index[0] && ele.index[1] === index[1]);
        for(let i=0;i<ITER_NUM; i++){
            for(const [gridIndexTop, gridIndexBottom] of swapRules){
                const topRank = findIndex(out, gridIndexTop),
                    bottomRank =  findIndex(out, gridIndexBottom),
                    top = out[topRank];

                if(bottomRank < topRank) continue;

                out.splice(topRank,1);
                out.splice(bottomRank,0,top);

            }
        }
    }
    return out;
}

function $getToolModeStr(editorSetting,mode, panelName, MODE){
    const TOOLS = editorSetting.setting.TOOLS_BOX[panelName]??[];
    for(const modeStr of TOOLS)
        if(mode & MODE[modeStr])
            return modeStr;
    return null;
}





async function initOutline(editor,files){
    for(const {path,version,id} of files){
        let filePathStack = $match(/[^\/]+/gm, path);
        await editor.initByData(editor.Content, filePathStack);
        const entry = $getFileEntry(path);
        // entry.EntryData = fileData;
        entry.Version = version;
        entry.ID = id;
    }
}

var helper = /*#__PURE__*/Object.freeze({
    __proto__: null,
    $JSON2File: $JSON2File,
    $OUTLINE_RENAME_CHECKER: $OUTLINE_RENAME_CHECKER,
    $activateWindow: $activateWindow,
    $activeWin: $activeWin,
    $assert: $assert,
    $base64ToFileBlob: $base64ToFileBlob,
    $batchEmit: $batchEmit,
    $cancelGhostImg: $cancelGhostImg,
    $clearGhostImg: $clearGhostImg,
    $fetch: $fetch,
    $fileBlob2Base64: $fileBlob2Base64,
    $findByFullName: $findByFullName,
    $findParentByType: $findParentByType,
    $findRoot: $findRoot,
    $getProjFolder: $getProjFolder,
    $getToolModeStr: $getToolModeStr,
    $getValidName: $getValidName,
    $guiCatcher: $guiCatcher,
    $img2Base64: $img2Base64,
    $intersectSelBoundary: $intersectSelBoundary,
    $isBoundaryOverlap: $isBoundaryOverlap,
    $readFileDataValue: $readFileDataValue,
    $refreshAllBegin: $refreshAllBegin,
    $refreshAllEnd: $refreshAllEnd,
    $resumeGhostImg: $resumeGhostImg,
    $setGhostImg: $setGhostImg,
    $sleep: $sleep,
    $sortingGrid: $sortingGrid,
    $splitBoundaries: $splitBoundaries,
    $traditionEvt4Focus: $traditionEvt4Focus,
    $wheelDelta2Move: $wheelDelta2Move,
    $wheelDelta2Scale: $wheelDelta2Scale,
    NegArray: NegArray,
    SORT_MODE: SORT_MODE,
    _getElement: _getElement,
    addBoundary: addBoundary,
    array2Color: array2Color,
    b64toBlob: b64toBlob,
    b64toUint8: b64toUint8,
    blob2Img: blob2Img,
    breathFirstSearch: breathFirstSearch,
    checkIfInsideObj: checkIfInsideObj,
    combineBoundary: combineBoundary,
    degree2Rad: degree2Rad,
    delay: delay,
    depthFirstSearch: depthFirstSearch,
    depthFirstSearchHierachy: depthFirstSearchHierachy,
    downstreamFindDFS: downstreamFindDFS,
    file2Img: file2Img,
    findChildrenOf: findChildrenOf,
    findParentElementByType: findParentElementByType,
    findParentsOf: findParentsOf,
    formatDate: formatDate,
    genColor: genColor,
    getArrayLabel: getArrayLabel,
    getBackupCanvas: getBackupCanvas,
    getHighlightShadowScale: getHighlightShadowScale,
    getOffset: getOffset,
    getPaddingNum: getPaddingNum,
    getParentsOf: getParentsOf,
    getSourceClassNm: getSourceClassNm,
    hashCode: hashCode,
    hashStr: hashStr,
    highlightShadow: highlightShadow,
    img2File: img2File,
    initOutline: initOutline,
    intervalChecker: intervalChecker,
    invertStatus: invertStatus,
    isArrowFn: isArrowFn,
    isAsyncFn: isAsyncFn,
    isEmptyObj: isEmptyObj,
    loadImg: loadImg,
    log: log,
    objList2FullNameList: objList2FullNameList,
    onStatusDoing: onStatusDoing,
    queueChecker: queueChecker,
    rad2Degree: rad2Degree,
    readAsText: readAsText,
    readFile: readFile,
    readLocalStorage: readLocalStorage,
    refreshBoundary: refreshBoundary,
    refreshWindow: refreshWindow,
    setCSSData: setCSSData,
    setGrayScale: setGrayScale,
    setPosition: setPosition
});

class LoadManager{

    static async  init(){
        const classNames = getByInterface(ILoad);
        const classes = await classNames2Classes(classNames);
        classes.forEach(loader=>LoadManager.regist(loader));
    }
    static #loadDict = {};

    static regist = (cls, fncName = 'onLoad')=>{
        let result = false,
            descriptors = [];
        getAllDescriptors(descriptors, cls,fncName);
        descriptors.forEach(ele=>{
            const   fnc = ele.value,
                key = ele.klass+'.'+fnc.name;
            let job = LoadManager.#loadDict[key];
            if(!job) {
                result = true;
                LoadManager.#loadDict[key] = {
                    class:cls,
                    instances:[],
                    fnc: fnc,
                    result: null
                };
                console.log(fnc.toString());
            }
        });
        return result;
    }

    static addInstance = (instance, params = {isDynamic:false,fncName:'onLoad'}) =>{
        $assert(instance);
        const cls = instance.constructor;

        if(LoadManager.regist(cls)&&params.isDynamic)
            instance.Status |= common$1.setting.BASIC_STATUS.loading;

        for(const [key, job] of Object.entries(LoadManager.#loadDict)){

            const clsName = key.split('.')[0],
                    target = convertTo(instance,clsName);

            if(job.result && target){
                job.instances.push(target);
                if(target.onFinishLoad)
                    target.onFinishLoad.call(instance,job.result);
            }
        }
    }
    static async execute(){
        return new Promise(res=>{
            const jobs = Object.entries(LoadManager.#loadDict).filter(ele=>ele.result == null);
            if(jobs.length == 0)
                res([]);
            else {
                const promises = jobs.map(([key, value])=>
                        new Promise(async res=>{
                            res( await value.fnc.call(value.class));
                        })
                );
                Promise.all(promises).then((results) => {
                    for(let i =0; i<jobs.length;i++){
                        const job = jobs[i][1];
                        job.result = results[i];
                        if(job.instance){
                            job.instance.Status &= ~common$1.setting.BASIC_STATUS.loading;
                            if(job.instance.onFinishLoad)
                                job.instance.onFinishLoad(results[i]);
                        }
                    }
                    res(results);
                });
            }
        });
    }

    constructor() {
    }


}

// var serializer = (function(){
var Buffer = {};
Buffer.byteLength = function(str, coding){
    return str.length;
};
Buffer.write = function(buffer, str, i,coding){
    for(var j in str){
        buffer[i++] = str.charCodeAt(j);
    }
    return str.length;
};
Buffer.read = function(buffer, i, end,coding){
    var result = "";
    for(var i = i; i < end; i++) {
        result = result + String.fromCharCode(buffer[i]);
    }

    return result;
};





var readIEEE754 = function(buffer, offset, endian, mLen, nBytes) {
    var e, m,
        eLen = nBytes * 8 - mLen - 1,
        eMax = (1 << eLen) - 1,
        eBias = eMax >> 1,
        nBits = -7,
        i = (nBytes - 1),
        d = -1,
        s = buffer[offset + i];

    i += d;

    e = s & ((1 << (-nBits)) - 1);
    s >>= (-nBits);
    nBits += eLen;
    for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8);

    m = e & ((1 << (-nBits)) - 1);
    e >>= (-nBits);
    nBits += mLen;
    for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8);

    if (e === 0) {
        e = 1 - eBias;
    } else if (e === eMax) {
        return m ? NaN : ((s ? -1 : 1) * Infinity);
    } else {
        m = m + Math.pow(2, mLen);
        e = e - eBias;
    }
    return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
};

var writeIEEE754 = function(buffer, value, offset, endian, mLen, nBytes) {
    var e, m, c,
        eLen = nBytes * 8 - mLen - 1,
        eMax = (1 << eLen) - 1,
        eBias = eMax >> 1,
        rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0),
        i = 0,
        d = 1,
        s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0;

    value = Math.abs(value);

    if (isNaN(value) || value === Infinity) {
        m = isNaN(value) ? 1 : 0;
        e = eMax;
    } else {
        e = Math.floor(Math.log(value) / Math.LN2);
        if (value * (c = Math.pow(2, -e)) < 1) {
            e--;
            c *= 2;
        }
        if (e+eBias >= 1) {
            value += rt / c;
        } else {
            value += rt * Math.pow(2, 1 - eBias);
        }
        if (value * c >= 2) {
            e++;
            c /= 2;
        }

        if (e + eBias >= eMax) {
            m = 0;
            e = eMax;
        } else if (e + eBias >= 1) {
            m = (value * c - 1) * Math.pow(2, mLen);
            e = e + eBias;
        } else {
            m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
            e = 0;
        }
    }

    for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8);

    e = (e << mLen) | m;
    eLen += mLen;
    for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8);

    buffer[offset + i - d] |= s * 128;
};


function calculateObjectSize(object) {
    var totalLength = (4 + 1);      /// handles the obj.length prefix + terminating '0' ?!
    for(var key in object) {        /// looks like it handles arrays under the same for...in loop!?
        totalLength += calculateElement(key, object[key]);
    }
    return totalLength;
}

function calculateElement(name, value) {
    var len = 1;                                /// always starting with 1 for the data type byte!
    if (name) len += Buffer.byteLength(name, 'raw') + 1;   /// cstring: name + '0' termination

    if (value === undefined || value === null) return len;  /// just the type byte plus name cstring
    switch( value.constructor ) {      /// removed all checks 'isBuffer' if Node.js Buffer class is present!?

        case ObjectID:          /// we want these sorted from most common case to least common/deprecated;
            return len + 12;
        case String:
            return len + 4 + Buffer.byteLength(value, 'raw') +1; ///
        case Number:
            if (Math.floor(value) === value) {  /// case: integer; pos.# more common, '&&' stops if 1st fails!
                if ( value <= 2147483647 && value >= -2147483647 ) // 32 bit
                    return len + 4;
                else return len + 8;    /// covers Long-ish JS integers as Longs!
            } else return len + 8;      /// 8+1 --- covers Double & std. float
        case Boolean:
            return len + 1;

        case Array:
        case Object:
            return len + calculateObjectSize(value);

        case Buffer:   ///  replaces the entire Binary class!
            return len + 4 + value.length + 1;
        case Uint8Array:   ///  replaces the entire Binary class!
            return len + 4 + value.length + 1;


        case RegExp:  /// these are handled as strings by serializeFast() later, hence 'gim' opts = 3 + 1 chars
            return len + Buffer.byteLength(value.source, 'raw') + 1
                + (value.global ? 1 : 0) + (value.ignoreCase ? 1 : 0) + (value.multiline ? 1 : 0) +1;
        case Date:
        case Long:
        case Timestamp:
        case Double:
            return len + 8;

        case MinKey:
        case MaxKey:
            return len;     /// these two return the type byte and name cstring only!
    }
    return 0;
}

function serializeFast(object, checkKeys, buffer, i) {   /// set checkKeys = false in query(..., options object to save performance IFF you're certain your keys are safe/system-set!
    var size = buffer.length;
    buffer[i++] = size & 0xff; buffer[i++] = (size >> 8) & 0xff;   /// these get overwritten later!
    buffer[i++] = (size >> 16) & 0xff; buffer[i++] = (size >> 24) & 0xff;

    if (object.constructor === Array) {     /// any need to checkKeys here?!? since we're doing for rather than for...in, should be safe from extra (non-numeric) keys added to the array?!
        for(var j = 0; j < object.length; j++) {
            i = packElement(j.toString(), object[j], checkKeys, buffer, i);
        }
    } else {   /// checkKeys is needed if any suspicion of end-user key tampering/"injection" (a la SQL)
        for(var key in object) {    /// mostly there should never be direct access to them!?
            if (checkKeys && (key.indexOf('\x00') >= 0 || key === '$where') ) {  /// = "no script"?!; could add back key.indexOf('$') or maybe check for 'eval'?!
/// took out: || key.indexOf('.') >= 0...  Don't we allow dot notation queries?!
                console.log('checkKeys error: ');
                return new Error('Illegal object key!');
            }
            i = packElement(key, object[key], checkKeys, buffer, i);  /// checkKeys pass needed for recursion!
        }
    }
    buffer[i++] = 0;   /// write terminating zero; !we do NOT -1 the index increase here as original does!
    return i;
}

function packElement(name, value, checkKeys, buffer, i) {    /// serializeFunctions removed! checkKeys needed for Array & Object cases pass through (calling serializeFast recursively!)
    if (value === undefined || value === null){
        buffer[i++] = 10;                                       /// = BSON.BSON_DATA_NULL;
        i += Buffer.write(buffer,name, i, 'raw'); buffer[i++] = 0;    /// buffer.write(...) returns bytesWritten!
        return i;
    }
    switch(value.constructor) {

        case ObjectID:
            buffer[i++] = 7;   /// = BSON.BSON_DATA_OID;
            i += Buffer.write(buffer,name, i, 'raw');     buffer[i++] = 0;
///     i += buffer.write(value.id, i, 'binary');  ///  OLD: writes a String to a Buffer; 'binary' deprecated!!
            value.id.copy(buffer, i);  /// NEW ObjectID version has this.id = Buffer at the ready!
            return i += 12;

        case String:
            buffer[i++] = 2;    ///  = BSON.BSON_DATA_STRING;
            i += Buffer.write(buffer,name, i, 'raw');     buffer[i++] = 0;

            var size = Buffer.byteLength(value) + 1;  /// includes the terminating '0'!?
            buffer[i++] = size & 0xff; buffer[i++] = (size >> 8) & 0xff;
            buffer[i++] = (size >> 16) & 0xff; buffer[i++] = (size >> 24) & 0xff;

            i += Buffer.write(buffer,value, i, 'raw');    buffer[i++] = 0;
            return i;

        case Number:
            if ( ~~(value) === value) {     /// double-Tilde is equiv. to Math.floor(value)
                if ( value <= 2147483647 && value >= -2147483647){ /// = BSON.BSON_INT32_MAX / MIN asf.
                    buffer[i++] = 16;   /// = BSON.BSON_DATA_INT;
                    i += Buffer.write(buffer,name, i, 'raw'); buffer[i++] = 0;
                    buffer[i++] = value & 0xff; buffer[i++] = (value >> 8) & 0xff;
                    buffer[i++] = (value >> 16) & 0xff; buffer[i++] = (value >> 24) & 0xff;

// Else large-ish JS int!? to Long!?
                } else {  /// if (value <= BSON.JS_INT_MAX && value >= BSON.JS_INT_MIN){ /// 9007199254740992 asf.
                    buffer[i++] = 18;   /// = BSON.BSON_DATA_LONG;
                    i += Buffer.write(buffer,name, i, 'raw'); buffer[i++] = 0;
                    var lowBits = ( value % 4294967296 ) | 0, highBits = ( value / 4294967296 ) | 0;

                    buffer[i++] = lowBits & 0xff;           buffer[i++] = (lowBits >> 8) & 0xff;
                    buffer[i++] = (lowBits >> 16) & 0xff;   buffer[i++] = (lowBits >> 24) & 0xff;
                    buffer[i++] = highBits & 0xff;          buffer[i++] = (highBits >> 8) & 0xff;
                    buffer[i++] = (highBits >> 16) & 0xff;  buffer[i++] = (highBits >> 24) & 0xff;
                }
            } else {    /// we have a float / Double
                buffer[i++] = 1;    /// = BSON.BSON_DATA_NUMBER;
                i += Buffer.write(buffer,name, i, 'raw'); buffer[i++] = 0;
/// OLD:    writeIEEE754(buffer, value, i, 'little', 52, 8);
                //buffer.writeDoubleLE(value, i);     i += 8;
                writeIEEE754(buffer, value, i, 'little', 52, 8);
                i += 8;
            }
            return i;

        case Boolean:
            buffer[i++] = 8;    /// = BSON.BSON_DATA_BOOLEAN;
            i += Buffer.write(buffer,name, i, 'raw'); buffer[i++] = 0;
            buffer[i++] = value ? 1 : 0;
            return i;

        case Array:
        case Object:
            buffer[i++] = value.constructor === Array ? 4 : 3; /// = BSON.BSON_DATA_ARRAY / _OBJECT;
            i += Buffer.write(buffer,name, i, 'raw'); buffer[i++] = 0;

            var endIndex = serializeFast(value, checkKeys, buffer, i); /// + 4); no longer needed b/c serializeFast writes a temp 4 bytes for length
            var size = endIndex - i;
            buffer[i++] = size & 0xff;          buffer[i++] = (size >> 8) & 0xff;
            buffer[i++] = (size >> 16) & 0xff;  buffer[i++] = (size >> 24) & 0xff;
            return endIndex;

        /// case Binary:        /// is basically identical unless special/deprecated options!
        case Buffer:            /// solves ALL of our Binary needs without the BSON.Binary class!?
            buffer[i++] = 5;    /// = BSON.BSON_DATA_BINARY;
            i += Buffer.write(buffer,name, i, 'raw'); buffer[i++] = 0;
            var size = value.length;
            buffer[i++] = size & 0xff;          buffer[i++] = (size >> 8) & 0xff;
            buffer[i++] = (size >> 16) & 0xff;  buffer[i++] = (size >> 24) & 0xff;

            buffer[i++] = 0;        /// write BSON.BSON_BINARY_SUBTYPE_DEFAULT;
            value.copy(buffer, i);  ///, 0, size); << defaults to sourceStart=0, sourceEnd=sourceBuffer.length);
            i += size;
            return i;

        case Uint8Array:
            buffer[i++] = 5;    /// = BSON.BSON_DATA_BINARY;
            i += Buffer.write(buffer,name, i, 'raw'); buffer[i++] = 0;
            var size = value.length;
            buffer[i++] = size & 0xff;          buffer[i++] = (size >> 8) & 0xff;
            buffer[i++] = (size >> 16) & 0xff;  buffer[i++] = (size >> 24) & 0xff;

            buffer[i++] = 0;        /// write BSON.BSON_BINARY_SUBTYPE_DEFAULT;
            //value.copy(buffer, i);  ///, 0, size); << defaults to sourceStart=0, sourceEnd=sourceBuffer.length);

            buffer.set(value,i);
            i += size;
            return i;




        case RegExp:
            buffer[i++] = 11;   /// = BSON.BSON_DATA_REGEXP;
            i += Buffer.write(buffer,name, i, 'raw');         buffer[i++] = 0;
            i += Buffer.write(buffer,value.source, i, 'raw'); buffer[i++] = 0x00;

            if (value.global) buffer[i++] = 0x73;        // s = 'g' for JS Regex!
            if (value.ignoreCase) buffer[i++] = 0x69;    // i
            if (value.multiline) buffer[i++] = 0x6d;     // m
            buffer[i++] = 0x00;
            return i;

        case Date:
            buffer[i++] = 9;    /// = BSON.BSON_DATA_DATE;
            i += Buffer.write(buffer,name, i, 'raw'); buffer[i++] = 0;
            var millis = value.getTime();
            var lowBits = ( millis % 4294967296 ) | 0, highBits = ( millis / 4294967296 ) | 0;

            buffer[i++] = lowBits & 0xff;           buffer[i++] = (lowBits >> 8) & 0xff;
            buffer[i++] = (lowBits >> 16) & 0xff;   buffer[i++] = (lowBits >> 24) & 0xff;
            buffer[i++] = highBits & 0xff;          buffer[i++] = (highBits >> 8) & 0xff;
            buffer[i++] = (highBits >> 16) & 0xff;  buffer[i++] = (highBits >> 24) & 0xff;
            return i;

        case Long:
        case Timestamp:
            buffer[i++] = value.constructor === Long ? 18 : 17; /// = BSON.BSON_DATA_LONG / _TIMESTAMP
            i += Buffer.write(buffer,name, i, 'raw'); buffer[i++] = 0;
            var lowBits = value.getLowBits(), highBits = value.getHighBits();

            buffer[i++] = lowBits & 0xff;           buffer[i++] = (lowBits >> 8) & 0xff;
            buffer[i++] = (lowBits >> 16) & 0xff;   buffer[i++] = (lowBits >> 24) & 0xff;
            buffer[i++] = highBits & 0xff;          buffer[i++] = (highBits >> 8) & 0xff;
            buffer[i++] = (highBits >> 16) & 0xff;  buffer[i++] = (highBits >> 24) & 0xff;
            return i;

        case Double:
            buffer[i++] = 1;    /// = BSON.BSON_DATA_NUMBER;
            i += Buffer.write(buffer,name, i, 'raw'); buffer[i++] = 0;
/// OLD: writeIEEE754(buffer, value, i, 'little', 52, 8);    i += 8;
            buffer.writeDoubleLE(value, i);     i += 8;
            return i

        case MinKey:    /// = BSON.BSON_DATA_MINKEY;
            buffer[i++] = 127; i += Buffer.write(buffer,name, i, 'raw'); buffer[i++] = 0;
            return i;
        case MaxKey:    /// = BSON.BSON_DATA_MAXKEY;
            buffer[i++] = 255; i += Buffer.write(buffer,name, i, 'raw'); buffer[i++] = 0;
            return i;

    } /// end of switch
    return i;   /// ?! If no value to serialize
}


function MinKey() { this._bsontype = 'MinKey'; }  /// these are merely placeholders/stubs to signify the type!?

function MaxKey() { this._bsontype = 'MaxKey'; }

function Long(low, high) {
    this._bsontype = 'Long';
    this.low_ = low | 0;    this.high_ = high | 0;          /// force into 32 signed bits.
}
Long.prototype.getLowBits = function(){ return this.low_; };
Long.prototype.getHighBits = function(){ return this.high_; };

Long.prototype.toNumber = function(){
    return this.high_ * 4294967296 + (this.low_ < 0 ? this.low_ + 4294967296 : this.low_);
};
Long.fromNumber = function(num){
    return new Long(num % 4294967296, num / 4294967296);    /// |0 is forced in the constructor!
};
function Double(value) {
    this._bsontype = 'Double';
    this.value = value;
}
function Timestamp(low, high) {
    this._bsontype = 'Timestamp';
    this.low_ = low | 0;    this.high_ = high | 0;          /// force into 32 signed bits.
}
Timestamp.prototype.getLowBits = function(){ return this.low_; };
Timestamp.prototype.getHighBits = function(){ return this.high_; };




function ObjectID(id) {
    this._bsontype = 'ObjectID';
    if (!id){  this.id = createFromTime();     /// base case, DONE.
    } else {
        if (id.constructor === Buffer){
            this.id = id;  /// case of
        } else if (id.constructor === String) {
            if ( id.length === 24 && checkForHex.test(id) ) {
                this.id = new Uint8Array(id.length);
            } else {
                this.id = new Error('Illegal/faulty Hexadecimal string supplied!');     /// changed from 'throw'
            }
        } else if (id.constructor === Number) {
            this.id = createFromTime(id);    /// this is what should be the only interface for this!?
        }
    }
}

function createFromTime(ts) {
    ts || ( ts = ~~(Date.now()/1000) );     /// 4 bytes timestamp in seconds only
    var buf = new Uint8Array(12), i = 0;
    buf[i++] = (ts >> 24) & 0xFF;    buf[i++] = (ts >> 16) & 0xFF;
    buf[i++] = (ts >> 8) & 0xFF;     buf[i++] = (ts) & 0xFF;

    for (;i < 12; ++i) buf[i] = 0x00;       /// indeces 4 through 11 (8 bytes) get filled up with nulls
    return buf;
}
ObjectID.prototype.toHexString = function toHexString() {
    return this.id.toString('hex');
};
ObjectID.prototype.getTimestamp = function getTimestamp() {
    return this.id.readUIntBE(0, 4);
};
ObjectID.prototype.getTimestampDate = function getTimestampDate() {
    var ts = new Date();
    ts.setTime(this.id.readUIntBE(0, 4) * 1000);
    return ts;
};
ObjectID.createPk = function createPk () {  ///?override if a PrivateKey factory w/ unique factors is warranted?!
    return new ObjectID();
};
ObjectID.prototype.toJSON = function toJSON() {
    return "ObjectID('" +this.id.toString('hex')+ "')";
};


class Serializer{
    constructor(){
    }

    serialize(object, checkKeys = false, asBuffer, serializeFunctions, index) {
        var buffer = new Uint8Array(calculateObjectSize(object));
        serializeFast(object, checkKeys, buffer, 0);
        return buffer;
    }




    deserialize(buffer, i, isArray){   //// , options, isArray) {       //// no more options!
            if (buffer.length < 5) return new Error('Corrupt bson message < 5 bytes long'); /// from 'throw'
            var elementType, tempindex = 0, name='';
            var low, high;              /// = lowBits / highBits
                                                /// using 'i' as the index to keep the lines shorter:
            i || ( i = 0 );  /// for parseResponse it's 0; set to running index in deserialize(object/array) recursion
            var object = isArray ? [] : {};         /// needed for type ARRAY recursion later!
            var size = buffer[i++] | buffer[i++] << 8 | buffer[i++] << 16 | buffer[i++] << 24;
            if(size < 5 || size > buffer.length) return new Error('Corrupt BSON message');
            /// 'size' var was not used by anything after this, so we can reuse it

            while(true) {                           // While we have more left data left keep parsing
                name='';
                elementType = buffer[i++];          // Read the type
                if (elementType === 0) break;       // If we get a zero it's the last byte, exit

                // if(105365 == tempindex)
                //     console.log(tempindex);
                tempindex = i;  /// inlined readCStyleString & removed extra i<buffer.length check slowing EACH loop!
                while( buffer[tempindex] !== 0x00 ) tempindex++;  /// read ahead w/out changing main 'i' index
                if (tempindex >= buffer.length) return new Error('Corrupt BSON document: illegal CString')
                //name = buffer.toString('raw', i, tempindex);
                for(var index = i; index < tempindex; index++) {
                    name = name + String.fromCharCode(buffer[index]);
                }

                i = tempindex + 1;               /// Update index position to after the string + '0' termination

                switch(elementType) {

                    case 7:     /// = BSON.BSON_DATA_OID:
                        var buf = new Uint8Array(12);
                        buffer.copy(buf, 0, i, i += 12 );   /// copy 12 bytes from the current 'i' offset into fresh Buffer
                        object[name] = new ObjectID(buf);   ///... & attach to the new ObjectID instance
                        break;

                    case 2:     /// = BSON.BSON_DATA_STRING:
                        size = buffer[i++] | buffer[i++] <<8 | buffer[i++] <<16 | buffer[i++] <<24;
                        object[name] = Buffer.read(buffer,i,i += size -1, 'raw'); //buffer.toString('raw', i, i += size -1 );

                        i++;        break;          /// need to get the '0' index "tick-forward" back!

                    case 16:    /// = BSON.BSON_DATA_INT:        // Decode the 32bit value
                        object[name] = buffer[i++] | buffer[i++] << 8 | buffer[i++] << 16 | buffer[i++] << 24;    break;

                    case 1:     /// = BSON.BSON_DATA_NUMBER:     // Decode the double value
                        //object[name] = buffer.readDoubleLE(i);   /// slightly faster depending on dec.points; a LOT cleaner
                        /// OLD: object[name] = readIEEE754(buffer, i, 'little', 52, 8);
                        object[name] = readIEEE754(buffer, i, 'little', 52, 8);
                        i += 8;     break;

                    case 8:     /// = BSON.BSON_DATA_BOOLEAN:
                        object[name] = buffer[i++] == 1;    break;

                    case 6:     /// = BSON.BSON_DATA_UNDEFINED:     /// deprecated
                    case 10:    /// = BSON.BSON_DATA_NULL:
                        object[name] = null;     break;

                    case 4:     /// = BSON.BSON_DATA_ARRAY
                        size = buffer[i] | buffer[i+1] <<8 | buffer[i+2] <<16 | buffer[i+3] <<24;  /// NO 'i' increment since the size bytes are reread during the recursion!
                        object[name] = deserializeFast(buffer, i, true );  /// pass current index & set isArray = true
                        i += size;      break;
                    case 3:     /// = BSON.BSON_DATA_OBJECT:
                        size = buffer[i] | buffer[i+1] <<8 | buffer[i+2] <<16 | buffer[i+3] <<24;
                        object[name] = deserializeFast(buffer, i, false );          /// isArray = false => Object
                        i += size;      break;

                    case 5:     /// = BSON.BSON_DATA_BINARY:             // Decode the size of the binary blob
                        size = buffer[i++] | buffer[i++] << 8 | buffer[i++] << 16 | buffer[i++] << 24;
                        buffer[i++];             /// Skip, as we assume always default subtype, i.e. 0!
                        //var a = buffer.slice(i, i + size);  /// creates a new Buffer "slice" view of the same memory!

                        //var b = buffer.subarray(i,i + size);
                        //
                        //b = new Uint8Array(b);


                        //if(a.byteLength!= b.byteLength)
                        //  console.log();
                        //
                        //if(a.byteOffset!= b.byteOffset)
                        //  console.log();
                        //i += size;
                        object[name] = buffer.slice(i, i += size);
                        break;

                    case 9:     /// = BSON.BSON_DATA_DATE:      /// SEE notes below on the Date type vs. other options...
                        low  = buffer[i++] | buffer[i++] << 8 | buffer[i++] << 16 | buffer[i++] << 24;
                        high = buffer[i++] | buffer[i++] << 8 | buffer[i++] << 16 | buffer[i++] << 24;
                        object[name] = new Date( high * 4294967296 + (low < 0 ? low + 4294967296 : low) );  break;

                    case 18:    /// = BSON.BSON_DATA_LONG:  /// usage should be somewhat rare beyond parseResponse() -> cursorId, where it is handled inline, NOT as part of deserializeFast(returnedObjects); get lowBits, highBits:
                        low  = buffer[i++] | buffer[i++] << 8 | buffer[i++] << 16 | buffer[i++] << 24;
                        high = buffer[i++] | buffer[i++] << 8 | buffer[i++] << 16 | buffer[i++] << 24;

                        size = high * 4294967296 + (low < 0 ? low + 4294967296 : low);      /// from long.toNumber()
                        if (size < JS_INT_MAX && size > JS_INT_MIN) object[name] = size;    /// positive # more likely!
                        else object[name] = new Long(low, high);    break;

                    case 127:   /// = BSON.BSON_DATA_MIN_KEY:   /// do we EVER actually get these BACK from MongoDB server?!
                        object[name] = new MinKey();     break;
                    case 255:   /// = BSON.BSON_DATA_MAX_KEY:
                        object[name] = new MaxKey();     break;

                    case 17:    /// = BSON.BSON_DATA_TIMESTAMP:   /// somewhat obscure internal BSON type; MongoDB uses it for (pseudo) high-res time timestamp (past millisecs precision is just a counter!) in the Oplog ts: field, etc.
                        low  = buffer[i++] | buffer[i++] << 8 | buffer[i++] << 16 | buffer[i++] << 24;
                        high = buffer[i++] | buffer[i++] << 8 | buffer[i++] << 16 | buffer[i++] << 24;
                        object[name] = new Timestamp(low, high);     break;

///        case 11:    /// = RegExp is skipped; we should NEVER be getting any from the MongoDB server!?
                }   /// end of switch(elementType)
            }   /// end of while(1)
            return object;  // Return the finalized object
    }




}
var serializer = new Serializer();

class
Transform2D
    extends implement(ITransform2D,IConnection,ISerializable){

    static serialize(transform){
        let data = {
            name:transform.name,
            connections:{},
            position:transform.Position,
            scale:transform.Scale,
            rotation:transform.Rotation,
            pivot:transform.Pivot,
        };


        data.connections[ConnectionType.inputs] = {};

        let transInputs = transform[ConnectionType.inputs],
            transOutputs = transform[ConnectionType.outputs],
            inputs={}, outputs = {};

        for(let name of transInputs)
            switch (typeof transInputs[name]) {
                case 'object':
                    inputs[name] = transInputs[name].FullName;
                    break;
                case 'array':
                    inputs[name] = [];
                    for(let ele of transInputs[name])
                        inputs[name].push(ele.name);
                    break;
                
            }
        data.connections.inputs = inputs;



        for(let name of transOutputs)
            switch (typeof transOutputs[name]) {
                case 'object':
                    outputs[name] = transOutputs[name].FullName;
                    break;
                case 'array':
                    outputs[name] = [];
                    for(let ele of transOutputs[name])
                        outputs[name].push(ele.name);
                    break;

            }
        data.connections.outputs = outputs;

        return serializer.bson.serialize(data);
    };



    static deserialize(bson){

        let json = serializer.bson.deserialize(bson),
            result = new Transform2D(json.name);
        result.Position = json.position;
        result.Scale = json.scale;
        result.Rotation = json.rotation;
        result.Pivot = json.pivot;



        let transInputs = json.connections.inputs;
        for(let name of transInputs)
            result.setConnection(ConnectionType.inputs,name,transInputs[name]);

        return result;

    };

    set UpdateCallback(value){
        $assert$1(typeof value == 'function');
        this.#updateCallback = value;
    }

    #globalPosition =  [0,0];
    #updateCallback = null;

    constructor(name='__test',def={}){
        super();
        this.name = name;
        this.position = def.position?def.position.slice():[0,0];
        this.scale = [1,1];
        this.rotation =  def.rotation??0;
        this.q = def.q??{sin:Math.sin(this.rotation),cos:Math.cos(this.rotation)};
        this.pivot = [0,0];
        this.localMatrix = [1,0,0,1,0,0]; //2x3
        this.globalMatrix = [1,0,0,1,0,0];





        this.initConnection(transformConnection);
        this.#updateCallback = def&&def.updateCallback?def.updateCallback:null;


    };
    delete(){
        this.name = null;
        this.position = null;
        this.#globalPosition =  null;
        this.scale =  null;
        this.rotation =  null;
        this.q =  null;
        this.pivot =  null;
        this.localMatrix =  null;
        this.globalMatrix =  null;

        //this.#inputs =  null;
        this.#updateCallback =  null;


    }



    set Pivot(value){

        $assert$1(value instanceof  Array && value.length == 2);
        this.pivot = value.slice();
        this.update();

    };
    get Pivot(){
        return this.pivot;
    }


    //[T][+p][RS][-P]
    //move position to compensate pivot
    insertPivot(pivot){
        const mat = this.localMatrix,
            pdx = pivot[0],
            pdy = pivot[1],

            dx =  mat[0]*-pdx + mat[2]*-pdy + pdx,
            dy =  mat[1]*-pdx + mat[3]*-pdy + pdy;

        this.position[0] = mat[4] - dx;
        this.position[1] = mat[5] - dy;

        this.Pivot = pivot;
    }

    move(value){
        $assert$1(value instanceof Array);
        this.position[0] += value[0],
        this.position[1] += value[1];
        this.update();
    }
    set Position(value){
        $assert$1(value instanceof Array);

        this.position[0] = value[0],
        this.position[1] = value[1];

        this.update();
    };
    get Position(){return this.position;}
    get GlobalPosition(){
        this.#globalPosition[0] = this.globalMatrix[4],
        this.#globalPosition[1] = this.globalMatrix[5];
        return this.#globalPosition;

        // return [this.globalMatrix[4], this.globalMatrix[5]];
    }



    set Scale(val){this.scale = val;}
    get Scale(){return this.scale;}

    set Rotation(val){this.rotation = val;}
    get Rotation(){return this.rotation;}

    clone(transform){
        this.position = transform.position.slice();
        this.scale = transform.scale.slice();
        this.rotation = transform.rotation;
        this.q = {sin:transform.q.sin,cos:transform.q.cos};
        this.transform.pivot.slice();
    }



    // set(value, anotherValue){
    //
    //
    //     if(typeof anotherValue === 'undefined'){
    //
    //         if(value.length == 2){
    //
    //             $assert($isNumber(value[0]) && $isNumber(value[1]));
    //             this.position[0] = value[0];
    //             this.position[1] = value[1];
    //         }else if($isNumber(value)){
    //
    //             this.rotation = value;
    //             let sin = Math.sin(value);
    //             let cos = Math.cos(value);
    //             this.q = {sin:sin,cos:cos};
    //         }else
    //             $assert(false);
    //     }else{
    //
    //         const rotation = anotherValue;
    //         $assert($isNumber(rotation));
    //         $assert(value.length == 2 && $isNumber(value[0]) && $isNumber(value[1]));
    //
    //         this.position[0] = value[0];
    //         this.position[1] = value[1];
    //
    //         this.rotation = rotation;
    //         let sin = Math.sin(rotation);
    //         let cos = Math.cos(rotation);
    //         this.q = {sin:sin,cos:cos};
    //     }
    //     this.update();
    // };








    //sx,   0,      tx
    //0,    sy,     ty
    //0,    0,      1

    //rot
    //cos   -sin
    //sin   cos
    get Matrix(){
        //this.localMatrix[0] = 1; this.localMatrix[1] = 0;this.localMatrix[2] = 0;this.localMatrix[3] = 1;this.localMatrix[4] = 0;this.localMatrix[5] = 0;

        // this.update();

        return this.globalMatrix;
    };


    get LocalMatrix(){return this.localMatrix;}


    set LocalMatrix(value){

        let i = value.length;
        while(i--) this.localMatrix[i] = value[i];

        // const   sx = math.vec2.length([value[0], value[1]]),
        //         sy = math.vec2.length([value[2], value[3]]);
        // this.q.cos = value[0]/sx;
        // this.q.sin = value[1]/sy;
        // this.scale[0] = sx;
        // this.scale[1] = sy;
        // this.position = value[4];
        // this.position = value[5];
        Transform2D.set(this, value);
    }
    clear(){
        this.position[0] = this.position[1] = 0;
        this.pivot[0] = this.pivot[1] = 0;
        this.scale[0] = this.scale[1] = 1;

        this.rotation = 0;
        this.q = {sin:Math.sin(this.rotation),cos:Math.cos(this.rotation)};


        this.localMatrix = [1,0,0,1,0,0];
        this.globalMatrix = [1,0,0,1,0,0];
        this.update();

    }
    //https://gamedev.stackexchange.com/questions/61473/combining-rotation-scaling-around-a-pivot-with-translation-into-a-matrix
    // [T]*[+p]*[R]*[S]*[-p]
    update(){ //localUpdate = true

        const localMat = this.getConnection(ConnectionType.inputs, 'localMatrix');
        if(localMat.length){//if external input localMatrix
            this.LocalMatrix = localMat;
        } else { // if(localUpdate)
            const mat = this.localMatrix,
                px = this.pivot[0], py = this.pivot[1],
                tx = this.position[0], ty  = this.position[1],
                sx = this.scale[0],  sy = this.scale[1],
                cos = this.q.cos, sin = this.q.sin;

            //[RS] = [R]*[S]
            mat[0] = cos*sx;    mat[2] = -sin*sy;
            mat[1] = sin*sx;    mat[3] = cos*sy;

            // [T]*[+p]*[RS]*[-p]
            mat[4] = mat[0]*-px+mat[2]*-py  + px + tx;
            mat[5] = mat[1]*-px+mat[3]*-py + py + ty;

        }


        let obj = this.getConnection(ConnectionType.inputs,'object'),
            parent = obj&&obj.Parent&&obj.Parent.transform?obj.Parent:null,
            children = obj&&obj.Children?obj.Children:[];


        if(parent)
            multiply$3(this.globalMatrix,parent.transform.globalMatrix,this.localMatrix);
        else
            copy$1(this.globalMatrix,this.localMatrix);

        for(let child of children){

            $assert$1(!(child.Status & common$1.setting.STATUS.creating), {errorType:common$1.error.ERR_TYPE.internalErr,
                msg:`${this.name} child transform update() failed, object is uninitialized`});
            $assert$1( !(child.Status & common$1.setting.STATUS.deleting), {errorType:common$1.error.ERR_TYPE.internalErr,
                msg:`${this.name} child transform update() failed, object is deleted`});

            multiply$3(child.transform.globalMatrix,this.globalMatrix,child.transform.localMatrix);
            child.transform.update();
        }

        if(this.#updateCallback)
            this.#updateCallback(this);
    }



    //https://www.gamedev.net/forums/topic/441695-transform-localMatrix-decomposition/

    //R*S
    // R0S0     R2S1
    // R1S0     R3S1
    static set(out,mat){
        out.position = [mat[4],mat[5]];
        out.scale = [Math.sqrt(mat[0]*mat[0]+mat[1]*mat[1]),Math.sqrt(mat[2]*mat[2]+mat[3]*mat[3])];
        out.q.cos = mat[0]/out.scale[0];
        out.q.sin = mat[1]/out.scale[1];
        out.pivot = [0,0];
        out.localMatrix = mat.slice();
    }


    static multiply = multiply;

    static inverse = inverse;

    static multiplyInv = multiplyInv;

}

let setting$2 = {


    MAX_WINDOWS:30,
    WINDOW_BODYLIGHTALPHA:0.2,
    SCROLL_BARSIZE:15,

    MIN_HEIGHT:30,
    MIN_WIDTH:30,

    MAX_WIDTH:600,
    MAX_HEIGHT:1200,

    SCROLL_SCALE:0.4,
    SCROLL_BOUNCE:2,
    SCROLL_CHECK_THRESHOLD:0,
    SCROLL_ITER_STEPS:1,

    CANVAS_SCALE_MAXSCROLL:500,
    CANVAS_MAXSCALE:10,

    NODE_WIDTH:100,
    NODE_HEIGHT:160,
    NODE_COLOR:'red',
    NODE_COLOR_ONFOCUS:'Cornsilk',

    GAMEOBJ_COLOR_ONFOCUS:'Cornsilk',


    CONNECTOR_WIDTH:10,
    LINE_WIDTH:2,
    CURVE_CONST:0.3,


    DELTA_Y:40,
    TITLE_FONT_SIZE:30,
    INPUT_FONT_SIZE:20,
    OUTPUT_FONT_SIZE:15,
    ENTRY_MARGIN:5,
    CURVE_X_MULTIPLIER:0.3,


    MANIPULATOR_WIDTH:15,

    BACKGROUND:'rgb(159,218,165)',//'black',//rgb(159,218,165)

    MAX_CANVAS_SIZE:1024*1024,

    SCENE_EDITOR:{
        manipulator:{extention:5},dragDelta:6,
        grid:{cellSize:32,rows:4,cols:4,lineWidth:2}
    },

    TOOLS_BOX:{
        Palette:[
            'camTumble',
            'camZoom',
            'select',
            'paint',
        ],
        Brush:[
            'camTumble',
            'camZoom',
            'select',
            'cut',
            'copy',
        ]

    },
    OUTLINE:{

        fontParams:{
            bold:false,
            font:'Arial',
            size:18,
            color:'white'//'black'
        },

        selectColor:'rgb(188,200,200)',

        entryColor:'rgba(0,0,0,0)',
        margin: {left:2,top:1,right:2,bottom:1},
        entryHeight:30,
        textBoxWidth:60,
        assetBoxWidth:60,
        entryImageLeftMargin:"15px",
        srcFoldIcon:[0,0,64,64],
        srcUnfoldIcon:[64,0,64,64],
        folderIcon:[128,0,64,64],
        jsIcon:[192,0,64,64],
        imgIcon:[256,0,64,64],


        paletteIcon:[64*5,0,64,64],
        tileBrushIcon:[64*6,0,64,64],
        autoBrushIcon:[64*7,0,64,64],

        layerIcon:[0,64,64,64],
        objIcon:[64,64,64,64],

        selectIcon:[0,128,64,64],
        setAttrIcon:[64,128,64,64],
    },
    WINDOW:{
        boxShadow:'0 0 1pt 2pt white',
        fontParams:{
            bold:true,
            font:'Arial',
            size:18,
            color:'white'
        },
        titleBar:{
            fontParams:{
                bold:true,
                font:'Arial',
                size:24,
                color:'white'
            },
        },

        slider:{
            backgroundColor:'rgb(161,170,165)',
            color:'rgb(188,200,200)',
            strokeColor:'black',
            radius:8,
        },

        outlineStrokeWidth: 2,
        outlineStrokeColor:'black',
        margin:4,
        marginColor:'rgb(12,239,245)',//'rgb(188,200,200)',

        titleHeight:50,

        titleColor:'rgba(0,0,0,0)',//rgb(92,136,175)
        toolBoxHeight:40,
        toolBoxColor:'white',
        toolBoxSelectedColor:'rgba(70,70,70,1)',
        highlightSrcBoundary:[0,384,256,256],

        hasPattern:false,//true
        patternSrcBoundary:[32*4,64*3,32,32],
        patternSize:[10,10],
        color:'black',//'rgb(250,250,230)',



    },HISTORY:{
        color:"black",
        selectColor:"grey",
        entryLeftMargin:30,
        entryLeft:30,


        fontParams:{
            bold:true,
            font:'Arial',
            size:14,
            color:'white'
        }
    },

    INSPECTOR:{

        titleLayout:{
            titleColor:'gray',
            color:'rgba(250,249,228)',
            strokeColor:'rgba(0,0,0,0)',
            lineWidth:0,
        },
        layout:{
            color:'rgba(250,249,228)',
            strokeColor:'rgba(0,0,0,0)',
            lineWidth:0,
        },


        dataEntryMargin:{left:0,top:2,right:0,bottom:0},

        fontParams:{
            bold:true,
            font:'Arial',
            size:12,
            color:'white'
        },


        autoTileLayout:{
            ruleHeight:60,
            checkerSize:48,
            previewSize:48,
            previewColor:'black',
            fontParams:{
                bold:true,
                font:'Arial',
                size:12,
                color:'white'
            },
            margin:6,
            selectedColor  :'white'
        },

        autoTileRule:{
            checkerBoundary:[32*3,64*3,32,32],
            checkerSize:16,
            leftCheckerBoundary:[32*3,64*3,16,16],
            leftBottomCheckerBoundary:[32*3+16,64*3,16,16],
            crossCheckerBoundary:[32*3,64*3+16,16,16],
        },
    },

    PALETTE:{
        fontParams:{
            bold:true,
            font:'Arial',
            size:12,
            color:'white'
        },
        expandBtn:{
            width:24,
            color:'black',
            mouseoverColor:'grey',
            mouseoverAlpha:0.4,
            fontParams:{
                bold:false,
                font:'Arial',
                size:12,
                color:'white'
            },
        },
        cuttedLabel:{
            color:'black',
            width:80,
            fontParams:{
                bold:false,
                font:'Arial',
                size:4,
                color:'white'
            },
        },

        sideDocker:{
            color:'rgba(0,0,0,0)',
            selectedColor  :'blue',
            selectedTxtColor :'white',
            width:200,
            titleLayout:{
                titleColor:'rgb(250,237,202)',
                fontParams:{
                    bold:true,
                    font:'Arial',
                    size:12,
                    color:'gray'
                },
            },
            fontParams:{
                bold:false,
                font:'Arial',
                size:12,
                color:'gray'
            },
        },

        cuttedLabelDefaultName:'unnamed',
        selectedOffsetYMultiplier:1/4,
        gridStrokeColor:'gray',
        gridErrorColor:'red',
        gridLineWidth:1,
        selectedGridColor:'rgba(200,200,200,0.5)',
        selectedContentColor:'rgba(200,0,0,0.2)',

        cuttedBoundaryStrokeColor:'rgba(200,100,100,0.5)',
        cuttedLineWidth:6,

        icon:{
            camTumble:[64*5,64,64,64],
            camZoom:[64*6,64,64,64],
            select:[0,64*2,64,64],
            paint:[64*7,64,64,64],
            grid:[64*8,64,64,64],
            cut:[64*9,64,64,64],
            copy:[64*5,64*2,64,64],
        }
    },

    COMPONENTS:{
        color:'rgba(0,0,0,0)',
        strokeColor:'rgba(0,0,0,0)',
        lineWidth:0,
        image:{
            shinningSpeed:2,
        },
        titleLayout:{
            titleColor:'gray',
            fontParams:{
                bold:false,
                font:'Arial',
                size:18,
                color:'black'
            },
            color:'rgba(0,0,0,0)',
            strokeColor:'rgba(0,0,0,0)',
            lineWidth:0,
        },

        layout:{
            color:'rgba(0,0,0,0)',
            strokeColor:'rgba(0,0,0,0)',
            lineWidth:0,
        },
        locker:{
            iconSrcBoundary:[0,64*3+32,32*3,32],
            size:[32,32],
        },

        label:{
            fontParams:{
                bold:false,
                font:'Arial',
                size:16,
                color:'white'
            },
            maxTextLength:32,
            margin: {left:12,top:4,right:12,bottom:4}
        },


        textbox:{
            color:'rgba(0,0,0,0)',
            selectedColor  :'blue',
            selectedTxtColor :'white',
            maxTextLength:32,

            fontParams:{
                bold:false,
                font:'Arial',
                size:16,
                color:'white'
            },

            margin: {left:4,top:4,right:4,bottom:4}
        },

        inputbox:{
            waitingBGColor:'black',
            waitingMsg:'waiting',
            fontParams:{
                bold:true,
                font:'Arial',
                size:12,
                color:'white'
            },
            padding:{left:12,top:1,right:12,bottom:1}
        },

        foldableLayout:{
            titleHeight:30,
        },


    },

    "tester":'red',


    "version": "1.0.0",
    "INTERFACE_DIAMETER":15,
    "INTERFACE_SCALE":1.3,
    "INPUTBOX_WIDTH":60,
    "CAM_POSITION_MULTI":[1,1,1],
    "CAM_POSITION_MIN":[-100,-100,-100],
    "CAM_POSITION_MAX":[100,100,100],
    "LINE_ANCHOR_MULTIPLIER":0.4,
    "LINE_Z":0.001,
    "LINE_DASH_ARRAY":[2,2],


    "TEXT_SIZE":16,
    "FONT":'serif',

    "HIGHTLIGHT_COLOR":'grey',




};


function getFont(){
  return setting$2.TEXT_SIZE+'px '+setting$2.FONT;
}

function parseSetting(value){
    if($isNumber$1(value))
        return value;

    if(/px/.test(value))
        return Number(value.match(/(\d+)px/)[1]);

}


var editorSetting = {setting: setting$2,getFont,parseSetting};

const isNode = typeof process != 'undefined';
const __dragData = {raw: {}, controller: null};
if (!isNode) {
    window.__dragData = __dragData;
    setupDragDrop();
}


function dragoverInverse2MoveOrOver(evt, controller) {

    const
        Controller = controller.constructor,
        ctrlEvt = new KeanuCtrlEvt(evt, controller);//$convert2ctrlEvt(controller,evt),

    ctrlEvt.initialize();
    controller.touchState |= Controller.TOUCH_STATE.drag;

    _dispatch(ctrlEvt, controller);
}

function setupDragDrop() {
//ONLY for external drag
    window.addEventListener("dragleave", function (e) {

        const editorName = e.target.getAttribute('editorName');
        if (!editorName) return;

        const editor = e.target.parentElement,
            controller = editor.Controller,
            Controller = controller.constructor;
        $assert(editor && controller && Controller);
        controller.touchState &= ~Controller.TOUCH_STATE.drag;

    });
//ONLY for external drag
    window.addEventListener("dragover", async function (e) {

        $assert(e.relatedTarget == null, {msg: 'dragover is only handled by the situation of external drag '});

        const editorName = e.target.getAttribute('editorName');
        if (!editorName) return;

        const editor = e.target.parentElement,
            controller = editor.Controller;
        if (isImplement(editor, IWindow)) {
            await editor.active();
            dragoverInverse2MoveOrOver(e, controller);
        }
        e.preventDefault();
    });
//
    window.addEventListener("drop", function (e) {
        const editorName = e.target.getAttribute('editorName');
        if (!editorName) return;

        const editor = e.target.parentElement,
            controller = editor.Controller;
        if (isImplement(editor, IWindow)) {
            dragoverInverse2MoveOrOver(e, controller);
        }
        e.preventDefault();
    });


    window.addEventListener('pointerdown', evt => {
        if (!evt.isPrimary) return;
        const editorName = evt.target.getAttribute('editorName');
        if (evt.target instanceof HTMLCanvasElement && editorName) {
            const editor = Keanu.editors.objs[editorName];
            __dragData.controller = editor.Controller;
        }
    }, {capture: false});


    window.addEventListener('pointerup', evt => {
        if (!evt.isPrimary) return;


        __clearBubbleControllerDragInfo();

        __clearDragRAW();


    });

    /////////////////////////////////////
    //managing drag between controllers
    /////////////////////////////////////
    //pointerenter would not support yet
    window.addEventListener('pointerover', evt => {
        if (__dragData.controller == null)
            return;

        const editorName = evt.target.getAttribute('editorName');
        if (evt.target instanceof HTMLCanvasElement && editorName) {
            const dragstartController = __dragData.controller,
                Controller = dragstartController.constructor,
                editor = Keanu.editors.objs[editorName];
            if (dragstartController.touchState & Controller.TOUCH_STATE.drag) {
                editor.Controller.touchState |= Controller.TOUCH_STATE.drag;
            }

        }
    }, {capture: true});


}


const __clearBubbleControllerDragInfo = _ => {
    if (!__dragData.controller) return;
    const controller = __dragData.controller,
        Controller = controller.constructor;
    controller.touchState &= ~Controller.TOUCH_STATE.drag;
    $clearGhostImg(controller);
    clearFocusGrp(controller, {typeExp: /drag/});

};

const __clearDragRAW = evt => {

        // if(__isInspectorInputBoxDrop(evt))
        //     //InputBox needs submit data to server, so following clear raw should be delayed
        //     setTimeout(_=>{
        //         __dragData.raw = {};
        //         __dragData.controller = null;
        //     },2100);
        // else{
        //     __dragData.raw = {};
        //     __dragData.controller = null;
        // }
        __dragData.raw = {};
        __dragData.controller = null;

    };


function DataTransfer(inputData = null) {
    if (inputData)
        __dragData.raw = inputData;
    return {
        setData: function (key, value) {
            __dragData.raw[key] = value;
            console.log(window.__dragData.raw);
        },
        getData: function (key) {
            if (!key)
                return __dragData.raw;
            return __dragData.raw[key];
        },
    }
}

DataTransfer.getRawData = _ => {
    return JSON.stringify(__dragData.raw) == '{}' ? null : __dragData.raw;
};

// const dataTransfer = new DataTransfer();

class KeyBoardCtrlEvt {
    constructor(evt) {
        this.type = evt.type;
        this.isComposing = evt.isComposing;
        this.code = evt.code;
        this.key = evt.key;
        // this.klass = evt.constructor.name;
        //function dummy for simulator
        this.originalEvt = evt.preventDefault ? evt : {
            preventDefault: function dummy() {
            }
        };
    }

    static serialize(evt) {
        delete evt.originalEvt;
        return {evt};

    }
}

function _emitEvt(ctrlEvt, type, controller) {
    const Controller = controller.constructor,
        shared = Controller.sharedController;


    //TODO: sharedController cannot be record
    // if(checkStatus(controller.Mode, common.setting.CONTROLLER_MODE.recording))
    //     Controller.recordEvt(evt, shared);


    const oldType = ctrlEvt.type;
    ctrlEvt.type = type;


    if (controller.name === shared.name)
        $processEvt(ctrlEvt, shared.FullName, shared);
    else
        _dispatch(ctrlEvt, controller);
    ctrlEvt.type = oldType;

}

function _dispatch(ctrlEvt, controller) {
    dispatchEvt(ctrlEvt, controller);
}


const CHECKDIS = 32, GESTURE_IDs = [0, 0];
let GESTURE_DIS = 0,
    GESTURE_ORIGIN_DOWN = {},
    GESTURE_ORIGIN_MOVE = {};

function setScrollParams(curEvt) {
    const id = curEvt.pointerId;
    $assert($isNumber$1(GESTURE_ORIGIN_MOVE[id][2]));
    $assert($isNumber$1(GESTURE_ORIGIN_MOVE[id][3]));

    curEvt.deltaX = -GESTURE_ORIGIN_MOVE[id][2];
    curEvt.deltaY = -GESTURE_ORIGIN_MOVE[id][3];


}

function setZoomParams(curEvt) {


    const moveA = GESTURE_ORIGIN_DOWN[GESTURE_IDs[0]],
        moveB = GESTURE_ORIGIN_DOWN[GESTURE_IDs[1]],
        dx = moveB[0] - moveA[0],
        dy = moveB[1] - moveA[1],
        dis = Math.sqrt(dx * dx + dy * dy);

    curEvt.scale = Math.sqrt(dis) / Math.sqrt(GESTURE_DIS);

}

//TODO:multiTouch2Gesture outdated
function multiTouch2Gesture(curEvt, controller) {
    const
        TOUCH_STATE = controller.constructor.TOUCH_STATE,

        moveA = GESTURE_ORIGIN_DOWN[GESTURE_IDs[0]],
        moveB = [curEvt.originX, curEvt.originY],
        dx = moveB[0] - moveA[0],
        dy = moveB[1] - moveA[1],
        dis = Math.sqrt(dx * dx + dy * dy);

    curEvt.originX = moveA[0];
    curEvt.originY = moveA[1];
    if (Math.abs(dis - GESTURE_DIS) < CHECKDIS) {

        curEvt.deltaX = curEvt.deltaY = 0;
        return TOUCH_STATE.scroll;
    } else {
        curEvt.scale = Math.sqrt(dis) / Math.sqrt(GESTURE_DIS);
        return TOUCH_STATE.zoom;
    }
}

//https://danburzo.ro/dom-gestures/
let gesture;
editorSetting.setting.CANVAS_SCALE_MAXSCROLL;
    editorSetting.setting.CANVAS_MAXSCALE;


function wheel2Gesture(curEvt, controller, emitter) {
    const dx = curEvt.deltaX,
        dy = curEvt.deltaY,
        TOUCH_STATE = controller.constructor.TOUCH_STATE;
    if (!gesture) {
        gesture = {
            origin: {x: curEvt.clientX, y: curEvt.clientY},
            scale: 1,
            translation: {x: 0, y: 0}
        };
        controller.touchState |= TOUCH_STATE.gesture;
        controller.touchState |= TOUCH_STATE.start;
    } else {

        controller.touchState |= TOUCH_STATE.change;

        if (curEvt.ctrlKey) {
            // pinch-zoom
            const factor = $wheelDelta2Scale(-dy);
            gesture = {
                mode: 'zoom',
                dx, dy,
                origin: {x: curEvt.clientX, y: curEvt.clientY},
                scale: gesture.scale * factor,
                translation: gesture.translation
            };
            console.log(`dy: ${dy.toFixed(2)}, factor: ${factor.toFixed(2)}, deltaY:${curEvt.deltaY.toFixed(2)} scale:${gesture.scale.toFixed(2)}`);
        } else {

            // panning
            gesture = {
                mode: 'pan',
                dx, dy,
                origin: {x: curEvt.clientX, y: curEvt.clientY},
                scale: gesture.scale,
                translation: {
                    x: gesture.translation.x - $wheelDelta2Move(dx),
                    y: gesture.translation.y - $wheelDelta2Move(dy)
                }
            };
        }
    }

    curEvt.originalEvt.stopPropagation();
    curEvt.originalEvt.preventDefault();

    curEvt.gesture = gesture;
    emitter.emit = _ => _emitEvt(curEvt, 'gesture', controller);

    $debounce(_ => {
        controller.touchState &= ~TOUCH_STATE.gesture;
        controller.touchState &= ~TOUCH_STATE.start;
        controller.touchState &= ~TOUCH_STATE.change;
        gesture = null;
        curEvt.gesture = null;
        emitter.emit = _ => _emitEvt(curEvt, 'gesture', controller);
    }, 100);

}

function setControllerState(curEvt, controller, button) {

    const TOUCH_STATE = controller.constructor.TOUCH_STATE,
        SYS_FLAG = common$1.system.SYS_FLAG;

    const id = curEvt.pointerId,
        emitter = {
            emit: function () {
            }
        };
    switch (curEvt.type) {
        case "wheel":
            wheel2Gesture(curEvt, controller, emitter);
            break;
        case "pointerdown":

            controller.touchState |= TOUCH_STATE.press;
            controller.touchState |= TOUCH_STATE.start;
            GESTURE_ORIGIN_DOWN[id] = [curEvt.originX, curEvt.originY];
            if (__ua.sysFlag & SYS_FLAG.Mobile) {//&& !(controller.touchState & TOUCH_STATE.drag

                if (curEvt.isPrimary) {
                    GESTURE_IDs[0] = id;
                } else {
                    GESTURE_IDs[1] = id;
                    controller.touchState |= TOUCH_STATE.multi;

                    const
                        pressA = GESTURE_ORIGIN_DOWN[GESTURE_IDs[0]],
                        pressB = [curEvt.originX, curEvt.originY];

                    const dx = pressB[0] - pressA[0],
                        dy = pressB[1] - pressA[1];
                    GESTURE_DIS = Math.sqrt(dx * dx + dy * dy);
                }
            }

            break;

        case "pointermove":
            // controller.touchState |= TOUCH_STATE.change;
            // $debounce(_ => controller.touchState &= ~TOUCH_STATE.change, CHECK_HOLD_TIME);


            const originX = GESTURE_ORIGIN_DOWN[id] ? GESTURE_ORIGIN_DOWN[id][0] : curEvt.originX,
                originY = GESTURE_ORIGIN_DOWN[id] ? GESTURE_ORIGIN_DOWN[id][1] : curEvt.originY;

            const oldX = GESTURE_ORIGIN_MOVE[id] ? GESTURE_ORIGIN_MOVE[id][0] : originX,
                oldY = GESTURE_ORIGIN_MOVE[id] ? GESTURE_ORIGIN_MOVE[id][1] : originY;


            GESTURE_ORIGIN_MOVE[id] = [
                curEvt.originX, curEvt.originY,                     //curPos
                curEvt.originX - oldX, curEvt.originY - oldY        //deltaPos
            ];


            if (__ua.sysFlag & SYS_FLAG.Mobile &&
                controller.touchState & TOUCH_STATE.press &&
                controller.touchState & TOUCH_STATE.multi) {


                if (curEvt.isPrimary) {
                    return curEvt.stopPropagation();
                } else {
                    const res = multiTouch2Gesture(curEvt, controller);
                    switch (res) {
                        case TOUCH_STATE.zoom:
                            controller.touchState |= TOUCH_STATE.zoom;
                            setZoomParams(curEvt);
                            emitter.emit = _ => _emitEvt(curEvt, 'zoom', controller);
                            break;
                        case TOUCH_STATE.scroll:
                            controller.touchState |= TOUCH_STATE.scroll;
                            setScrollParams(curEvt);
                            emitter.emit = _ => _emitEvt(curEvt, 'scroll', controller);
                            break;
                        default:
                            $assert(true);
                    }
                }


            }
            break;

        case "pointerup":
            if (button === 0)//left
                curEvt.buttons = 1;
            if (button === 2)//right
                curEvt.buttons = 2;
            if (button === 1)//mid
                curEvt.buttons = 4;
            if (button === 3)//4th
                curEvt.buttons = 8;
            if (button === 4)//5th
                curEvt.buttons = 16;

            const isMulti = controller.touchState & TOUCH_STATE.multi;

            const
                MOVE_THRESHOLD = 0.5,
                noMoving = GESTURE_ORIGIN_MOVE[id] === undefined ||
                    (Math.abs(GESTURE_ORIGIN_MOVE[id][2]) < MOVE_THRESHOLD &&
                        Math.abs(GESTURE_ORIGIN_MOVE[id][3]) < MOVE_THRESHOLD);

            if (__ua.sysFlag & SYS_FLAG.Desktop && curEvt.buttons & 2 && noMoving) {//right btn click
                emitter.emit = _ => _emitEvt(curEvt, 'menu', controller);
            } else if (__ua.sysFlag & SYS_FLAG.Mobile) {


                if (noMoving && isMulti) {

                    if (curEvt.isPrimary === false) {
                        emitter.emit = _ => _emitEvt(curEvt, 'menu', controller);
                    } else
                        return curEvt.stopPropagation();
                }
            }

            if (isMulti && curEvt.isPrimary === true) //escape
                break;
            controller.touchState &= ~TOUCH_STATE.press;
            controller.touchState &= ~TOUCH_STATE.start;
            controller.touchState &= ~TOUCH_STATE.change;
            controller.touchState &= ~TOUCH_STATE.multi;
            controller.touchState &= ~TOUCH_STATE.scroll;
            controller.touchState &= ~TOUCH_STATE.gesture;
            GESTURE_ORIGIN_DOWN = {};
            GESTURE_ORIGIN_MOVE = {};
            break;

    }

    return emitter;
}


function cpyPointer(ctlEvt, pointer, mode = 'serialize') {
    // $assert(evt instanceof KeanuCtrlEvt);
    const excludes = ['composedPath', 'currentTarget', 'relatedTarget', 'getCoalescedEvents',
        'getModifierState', 'getPredictedEvents', 'initEvent', 'initMouseEvent',
        'initUIEvent', 'path', 'preventDefault', 'srcElement', 'stopImmediatePropagation',
        'stopPropagation', 'target', 'view'];


    ctlEvt.klass = pointer.constructor.name;
    for (const key in pointer) {
        if (mode == 'serialize' && excludes.includes(key))
            continue;
        ctlEvt[key] = pointer[key];
    }
}

class KeanuCtrlEvt {
    static PHASE = {CAPTURING_PHASE: 1, TARGETING_PHASE: 2, BUBBLING_PHASE: 3};
    originalEvt = null;
    default = true;
    immediatePropagation = true;
    propagation = true;
    isPrimary = true;

    target = null;
    currentTarget = null;
    relatedTarget = null;

    constructor(evt = {}, controller, params = {mode: 'translator'}) {


        this.target = evt.target;

        if (params.mode === 'serialize')//|| params.mode == 'copy'
            return cpyPointer(this, evt);


        //function dummy for simulator
        this.originalEvt = evt.preventDefault ? evt : {
            preventDefault: function dummy() {
            }
        };
        $assert(controller);
        this.controller = controller;


        //>>> 0 unsigned right shift operator.
        this.timestamp = evt.timestamp ?? Date.now() - controller.timestamp;
        this.dataTransfer = evt.dataTransfer ?? null;
        this.customDataTransfer = evt.rawData ?
            DataTransfer(evt.rawData) :
            DataTransfer();
        this.path = [];//evt.path.slice();

    }

    initialize(evt = this.originalEvt) {
        this.type = evt.type;
        this.localX = null;
        this.localY = null;

        if (!evt.target)//from simulator
            evt.target = this.controller.parent;
        const {x, y} = evt.target.getBoundingClientRect(),
            gScale = $infinityDesktopGetScale();
        this.offsetX = (evt.clientX - x) / gScale;
        this.offsetY = (evt.clientY - y) / gScale;
        this.ctrlKey = evt.ctrlKey;
        this.altKey = evt.altKey;
        this.shiftKey = evt.shiftKey;

        this.originX = evt.offsetX;
        this.originY = evt.offsetY;
        this.eventPhase = evt.eventPhase;
        this.cpyParams(evt);
        return this.convert2InternalType(evt);
    }

    switchTypes(evt) {
        switch (evt.type) {
            case 'pointerdown':
                this.type = 'press';
                break;
            case 'pointerup':
                this.type = 'release';
                break;
            case 'pointermove':
                this.type = 'move';
                break;


            case 'pointerover':
                this.type = 'over';
                break;
            case 'pointerout':
                this.type = 'out';
                break;
            case 'pointercancel':
                this.type = 'cancel';
                break;

            //
            //
            // case 'wheel':
            //     this.type = 'gesture';
            //     break;

            case 'drop':
                this.type = 'release';
                break;

            case 'dragover': //external dragover
                this.type = 'move';
                break;


            default:
                $assert(true);
        }
    }

    cpyParams(evt) {
        this.buttons = evt.buttons;
        this.screenX = evt.screenX;
        this.screenY = evt.screenY;
        this.clientX = evt.clientX;
        this.clientY = evt.clientY;
        this.pageX = evt.pageX;
        this.pageY = evt.pageY;

        if (evt instanceof PointerEvent) {
            this.pointerId = evt.pointerId;

            this.width = evt.width;
            this.height = evt.height;
            this.tiltX = evt.tiltX;
            this.tiltY = evt.tiltY;
            this.pressure = evt.pressure;
            this.pointerType = evt.pointerType;
            this.isPrimary = evt.isPrimary;
        } else if (evt instanceof MouseEvent) {
            if (evt.type === 'wheel') {
                this.deltaY = evt.deltaY;
                this.deltaX = evt.deltaX;
            }
        }
    }

    convert2InternalType(evt) {

        const emitter = setControllerState(this, this.controller, evt.button);

        this.switchTypes(evt);

        return emitter;
    }


    preventDefault(blockingOriginalEvt = false) {
        // if(blockingOriginalEvt)
        //     this.originalEvt.preventDefault();
        this.default = false;
    }

    stopPropagation(stopOriginEvtPropagation = false) {
        this.propagation = false;
        if (stopOriginEvtPropagation)
            this.originalEvt.stopPropagation();
    };

    stopImmediatePropagation() {
        this.immediatePropagation = false;
        this.propagation = false;
    }

    static serialize(evt) {
        delete evt.controller;
        delete evt.originalEvt;
        delete evt.customDataTransfer;
        evt.rawData = DataTransfer.getRawData();
        // const path = result.path.map(ele=>ele.name),
        //     target = result.target ?result.target.FullName:null;
        return {evt};//,result:{path,target}

    }


}

function uiAddChild (child){
    child.Parent = this;
    const oldName = child.name;
    child.name = $getValidName(this, oldName);
    this.Children.push(child);


    //
    // if(checkStatus(this.status,common.setting.STATUS.visible))
    //     child.Status |= common.setting.STATUS.visible;
    // else
    //     child.Status &= ~common.setting.STATUS.visible;


    return {oldName:oldName,newName:child.name};
}
function uiInsertChild (index,child){
    child.Parent = this;
    const oldName = child.name;
    child.name = $getValidName(this, oldName);
    this.Children.insert(index, child);



    // if(checkStatus(this.status,common.setting.STATUS.visible))
    //     child.Status |= common.setting.STATUS.visible;
    // else
    //     child.Status &= ~common.setting.STATUS.visible;



    return {oldName:oldName,newName:child.name};
}

function uiDelChild(child){
    child.Parent = null;
    this.Children.delete(child);
}


const NO_BUBBLE_TYPE = ['gesture', 'enter', 'leave'];
function _toLeafsDo(group,callback=(parent,child)=>{}){
    while(group.length){
        const parent = group.shift();

        $assert(parent.Children);
        for(let child of parent.Children){
            // const isActive = checkStatus(child.Status, common.setting.STATUS.active);
            // if(isActive)
                callback(parent,child);
            group.push(child);
        }
    }
}



function _toParents(curObj,updateTypes,Controller){
    const parents = getParentsOf( curObj, ele=>{
        if(isImplement(ele, IWindow))
            return false;

        // if(!checkStatus(ele.Status, common.setting.STATUS.active)){
        //     debugger;
        //     return false;
        // }

        let needsUpdate = false;
        for(const type of updateTypes)
            needsUpdate ||= !(ele.Filters.includes(type));

        return needsUpdate;
    });


    while(parents.length){
        const obj = parents.shift();

        $assert(obj);

        if(obj instanceof Controller)
            continue;

        for(const type of updateTypes){
            if(!obj.Filters.includes(type))
                obj.Filters.add(type);
        }
    }
}



function registFilter(controller, types, curObj,Controller = controller.constructor){

    const updateTypes = Array.from(types);
    for(const evtType of types){
        if(!curObj.Filters.includes(evtType)){
            curObj.Filters.add(evtType);
        }
    }

    //curObj 2 leafs
    const group = [curObj],
        includes = updateTypes.filter(ele=>!NO_BUBBLE_TYPE.includes(ele));
    _toLeafsDo(group,(parent,child)=>{
        for(const type of includes){
            const isFilterContain = child.Filters.includes(type);
            if( !isFilterContain)
                child.Filters.add(type);
        }
    });

    //2 parents
    if(!(curObj instanceof  Controller))
        _toParents(curObj, updateTypes,Controller);

}

function resetFilter(controller,Controller = controller.constructor){

    if(controller.__DELAY_RESET == true)
        return;

    const nodes = depthFirstSearch(controller,
            ele=>!(ele.StatusOfMasked & common$1.setting.BASIC_STATUS.deleting))
            .filter(ele=>ele.Status&common$1.setting.STATUS.active);

    for(let node of nodes){
        node.Filters.clear();
        for(let [type] of Object.entries(node.EvtPool)){
            $assert(type);
            if(!node.Filters.includes(type)){
                node.Filters.add(type);
            }
        }
    }
    $assert(controller);
    updateFilter(controller, Controller);
}
function updateFilter(parent, Controller){
    //Top 2 Bottom
    const group = [parent];
    // toLeafsExpand(group);
    _toLeafsDo(group, (parent,child)=>
        child.Filters.expand(parent.Filters, NO_BUBBLE_TYPE));
    const
        condition = child=>true, //child=> checkStatus(child.Status,common.setting.STATUS.active),

        leafs = depthFirstSearch(parent,condition).filter(ele=>ele.Children.length === 0);
    //Bottom 2 Top
    while(leafs.length){
        let curObj = leafs.shift();

        $assert(curObj.Parent);

        // if(!checkStatus(curObj.Status, common.setting.STATUS.active))
        //     continue;

        if(curObj instanceof Controller)
            continue;

        curObj.Parent.Filters.expand(curObj.Filters);

        if(!leafs.find(ele=>ele.FullName == curObj.Parent.FullName))
            leafs.push(curObj.Parent);
    }

}



//TODO: Optional {index, capture,once,passive, signal}

//TODO:
// index

//TODO:
// once
// A boolean value indicating that the listener should be invoked at most once after being added.
// If true, the listener would be automatically removed when invoked.

//TODO:
// passive
// A boolean value that, if true, indicates that the function specified by listener
// will never call preventDefault(). If a passive listener does call preventDefault(),
// the user agent will do nothing other than generate a console warning.
// See Improving scrolling performance with passive listeners to learn more.
//https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener#improving_scrolling_performance_with_passive_listeners

//TODO:
// signal
// An AbortSignal. The listener will be removed when the given AbortSignal’s abort() method is called.

function  checkEventListener(curEle, evtType,fnc){
    if(!curEle.EvtPool[evtType]){
        return false;
    }


    const   capture =  curEle.EvtPool[evtType].capture
            .findIndex(item => (item.caller === curEle && item.fnc.toString() === fnc.toString())) !== -1,
            bubble =  curEle.EvtPool[evtType].bubble
                .findIndex(item => (item.caller === curEle && item.fnc.toString() === fnc.toString())) !== -1;

    return capture||bubble;
}
const __REGISTER_COUNTER = (mode, value)=>{
        if(mode === 'add')
            return value?++value:1;
        else if(mode === 'remove'){
            $assert(value);
            $assert(value-1>=0);
            return --value;
        }
    },
    __REGISTER =(evtType,register,mode,binder,listenHandler,option)=>{

        register.set(evtType, __REGISTER_COUNTER(mode,register.get(evtType)));//register['pointermove']?++register['pointermove']:1
        if(register.get(evtType) === 1 && mode === 'add'){

            binder.addEventListener(evtType, listenHandler, option);
        }else if(register.get(evtType) === 0 && mode === 'remove'){
            binder.removeEventListener(evtType, listenHandler, option);
        }
    };

function $updateEventRegister(evtType,obj, register, binder,capture, mode = 'add',Controller){
    let passive = true;
    if(evtType === 'gesture'){
        passive = false;
        capture = true;
    }

    const option = {capture, passive},
        listenHandler = obj instanceof Controller? Controller.rootWindowHandler:Controller.listenHandler;
    const isMove = evtType === "move",
        isInOut = !( obj instanceof Controller) &&(evtType === "over" || evtType === "out" || evtType === 'enter' || evtType === 'leave');


    if (isMove){
        __REGISTER('pointermove',register,mode,binder,listenHandler,option);
    }else if(isInOut){

        __REGISTER('pointermove',register,mode,binder,listenHandler,option);
        __REGISTER('pointerover',register,mode,binder,listenHandler,option);
        __REGISTER('pointerout',register,mode,binder,listenHandler,option);


    } else if(evtType === "press") {

        __REGISTER('pointerdown',register,mode,binder,listenHandler,option);


    }else if(evtType === "release"){
        __REGISTER('pointerup',register,mode,binder,listenHandler,option);

    }else if (evtType === 'click' || evtType === 'dblclick') {

        __REGISTER('pointerdown',register,mode,binder,listenHandler,option);
        __REGISTER('pointermove',register,mode,binder,listenHandler,option); //move a bit should be tolerated
        __REGISTER('pointerup',register,mode,binder,listenHandler,option);

    }else if(evtType ==='menu'){

        __REGISTER('pointerdown',register,mode,binder,listenHandler,option);
        __REGISTER('pointerup',register,mode,binder,listenHandler,option);

    }
    else if(evtType === 'drop'){

        __REGISTER('pointerdown',register,mode,binder,listenHandler,option);
        __REGISTER('pointermove',register,mode,binder,listenHandler,option); //move a bit should be tolerated
        __REGISTER('pointerup',register,mode,binder,listenHandler,option);


    }else if(evtType === 'gesture'){

        __REGISTER('wheel',register,mode,binder,listenHandler,option);


    }

}

function addEventListener( curEle, evtType,fnc,optional=false){

    let isCapture = optional === true || optional.capture === true,
        isOnce = typeof optional == 'object'?(optional.once):false;

    //hard coded, gestures are handled in capture phase
    if(evtType === 'gesture') isCapture = true; //prevent $infinityDesktop wheel
    $assert(curEle.EvtPool);

    if(!curEle.EvtPool[evtType])
        curEle.EvtPool[evtType] = {'capture':[],'bubble':[]};

    let callbacks = isCapture?
        curEle.EvtPool[evtType].capture:curEle.EvtPool[evtType].bubble;

    if($isNumber$1(optional.index))
        callbacks[index] = {fnc:fnc,caller:curEle,isOnce};
    else {
        if(callbacks.find(ele=>ele.fnc.toString() === fnc.toString()))
            console.warn('duplicated addEventListener function', $getStackLocationByIndex());
        else
            callbacks.push({fnc: fnc, caller: curEle, isOnce});
    }

}
function removeEventListener(curEle,evtType,fnc,optional=false){
    if(!curEle.EvtPool[evtType]){
        debugger;
        throw new Error('delEvent Err');
    }

    let isCapture =  optional === true || optional.capture === true;

    //hard coded, gestures are handled in capture phase
    if(evtType === 'gesture') isCapture = true; //prevent $infinityDesktop wheel

    const pool = curEle.EvtPool[evtType][(isCapture?'capture':'bubble')];
    curEle.EvtPool[evtType][(isCapture?'capture':'bubble')]= pool.filter(item=>
        !(item.caller === curEle&&item.fnc === fnc)
    );

    if(curEle.EvtPool[evtType].capture.length === 0 &&curEle.EvtPool[evtType].bubble.length === 0)
        delete curEle.EvtPool[evtType];




}


async function catcher(controller,job, evt) {
    try {
        const panel = controller.Parent;
        if(panel&&panel.onActive)
            panel.onActive();


        await job(evt); //maybe job is promise, add await for safety catch

    } catch (err) {
        debugger;
        console.error(job.name, err);
    }
}
function _setLocalXY( target,originPos){
    if(!target.transform)//is controller
        return [target.offsetX, target.offsetY];

    const transform = target.transform, local = [0,0],
        invMat = [0,0,0,0,0,0];
    $assert(transform);
    invert$2(invMat, transform.globalMatrix);
    Transform2D.multiply(local, invMat, originPos);
    return local;
}

function _callbackRootFncs(evt, controller, state = 'capture'){

    const Controller = controller.constructor;

    if(!evt.propagation)
        return;
    if(controller.EvtPool[evt.type]&&controller.EvtPool[evt.type][state].length)
        for(let {fnc,caller,isOnce} of controller.EvtPool[evt.type][state]){

            if(!controller.FullName.includes(caller.FullName))//check desendant
                continue;

            catcher(controller,fnc,evt);
            if(isOnce)
                Controller.removeEventListener(evt.type, fnc);

            if(!evt.immediatePropagation){
                evt.originalEvt.stopPropagation();
                break;
            }
        }
}
function _callbackFncs(evt,path, controller, state = 'capture'){

    const Controller = controller.constructor;
    for(const obj of path){
        if(!obj.EvtPool)
            continue;
        else if(!evt.propagation)
            break;
        else if(obj.EvtPool[evt.type]&&obj.EvtPool[evt.type][state].length)
            for(let {fnc,caller,isOnce} of obj.EvtPool[evt.type][state]){

                if(!obj.FullName.includes(caller.FullName))//check desendant
                    continue;

                if(['enter','leave'].includes(evt.type)&&
                    state == 'bubble' && obj.FullName != evt.target.FullName)
                    continue;

                evt.currentTarget = obj;
                const originPos = [evt.originX, evt.originY];
                // [evt.localX, evt.localY] = obj instanceof Controller?
                //     originPos: _setLocalXY( evt.currentTarget,originPos);

                $assert(!(obj instanceof Controller));
                [evt.localX, evt.localY] = _setLocalXY( evt.currentTarget,originPos);

                catcher(controller,fnc,evt);
                if(isOnce)
                    controller.removeEventListener(evt.type, fnc);

                if(!evt.immediatePropagation){
                    evt.originalEvt.stopPropagation();
                    break;
                }
            }

    }

    delete evt.localX;
    delete evt.localY;
    delete evt.currentTarget;
}


function notify(evt,target,controller){

    if(!target.Filters.includes(evt.type)){
        return;
    }

    const oldTarget = evt.target;
    evt.target = target;

    $assert(target&&target.FullName, {errorType:common$1.error.ERR_TYPE.internalErr});


    let names = target.FullName.split('/');

    for(let i=1;i<names.length;i++)
        names[i] = names[i-1] + '/' + names[i];

    names.shift();
    const path = names.map(ele=>$findByFullName( ele)).reverse();

    evt.path = path.filter(ele=>!(ele instanceof controller.constructor));


    if(evt.eventPhase == KeanuCtrlEvt.PHASE.CAPTURING_PHASE)
        // evt.eventPhase = KeanuCtrlEvt.PHASE.CAPTURING_PHASE;
        _callbackFncs(evt,path.slice().reverse(),controller, 'capture');

    if(evt.eventPhase == KeanuCtrlEvt.PHASE.BUBBLING_PHASE)
        // evt.eventPhase = KeanuCtrlEvt.PHASE.BUBBLING_PHASE;
        _callbackFncs(evt,path.slice(),controller, 'bubble');

    delete evt.path;
    evt.target = oldTarget;
}


//https://javascript.info/mousemove-mouseover-mouseout-mouseenter-mouseleave




function clearFocusGrp(controller, params, phases = ['bubble','capture']){//mode = 'sameController'

    $assert(controller);

    if(!params) return ;

    const {target,exclude,typeExp,targetExp, type} = params;
    $assert(target||typeExp||targetExp||type||exclude);

    let condition;
    if(!typeExp && !targetExp){
        if(target && !type)
            condition = ele => ele.target == target;
        else if(target && type)
            condition = ele => ele.target == target && ele.type == type;
        else if(exclude && !type)
            condition = ele => ele.target != exclude;
        else if(exclude && type)
            condition = ele => ele.target != exclude&& ele.type == type;
        else if(!target&&!exclude && type)
            condition = ele => ele.type == type;
    }else {
        if(typeExp){
            if(!target && !exclude)
                condition = ele => typeExp.test(ele.type);
            else if(target && !exclude)
                condition = ele => ele.target == target && typeExp.test(ele.type);
            else if(!target && exclude)
                condition = ele => ele.target != exclude && typeExp.test(ele.type);
        }

        if(targetExp){
            if(!type&& !exclude)
                condition = ele => targetExp.test(ele.target);
            else if(!type&& exclude)
                condition = ele => ele.target != exclude && targetExp.test(ele.target);
            else if(type&& !exclude)
                condition = ele => ele.type == type && targetExp.test(ele.target);
            else if(type&& exclude)
                condition = ele =>  ele.target != exclude && ele.type == type && targetExp.test(ele.target);
        }
    }

    for(const phase of phases){
        const
            focusGrp = controller.getFocusGrp(phase),
            result = focusGrp.filter(ele=>!condition(ele));

        focusGrp.length = 0;
        for(const ele of result)
            focusGrp.push(ele);
    }
}




function checkFilter(evtType, filters){
    if(//['press','release','click', 'dblclick', 'contextmenu'].includes(type) &&
        filters.includes(evtType))
        return true;


    const
            drag = [['move','press'],['dragstart','drag']],
            drop = [['move','release'],['dragend','drop']],
            enter = [['move'],['enter']],
            leave = [['move'],['leave']],
            over = [['move'],['over']],
            out = [['move'],['out']],
            clicks = [['press', 'release'], ['click', 'dblclick']];

    let
        TYPES = [enter,over,out, leave, clicks,drag,drop];

    if(__ua.sysFlag & common$1.system.SYS_FLAG.Mobile){
        const
            menu = [['move','press'],['menu']],//noMoving and press with two finger
            gesture = [['move','press', 'release',],['gesture']];
        TYPES = [...TYPES, menu, gesture];
    }

    for(const typeArr of TYPES){
        for(const type of typeArr[1]){
            if(filters.includes(type)){
                for(const inputType of typeArr[0]){
                    if(inputType == evtType)
                        return true;
                }
            }
        }
    }

    return false;

}

function beforeCheck(evt,controller, targetFullName){
    //mousedown mouseup click dblclick
    const focusGrp = controller.getFocusGrp(evt.eventPhase),
        isContain = ele=>new RegExp(targetFullName).test(ele.target);
        //focusGrp.find(ele=>new RegExp(targetFullName).test(ele.target) && ele.type == 'press')
        focusGrp.find(ele=>isContain(ele) && ele.type == 'press');
        focusGrp.find(ele=>isContain(ele) && ele.type == 'release');
        focusGrp.find(ele => isContain(ele) && ele.type == 'click');


    const dragstartGrp = controller.getFocusGrp(evt.eventPhase).filter(ele=>ele.type == 'dragstart');
    if(dragstartGrp.length){
        $assert(dragstartGrp.length ==1);
        const draggingTarget = dragstartGrp[0].target;
        if(evt.type === 'move' && targetFullName == draggingTarget){
            return false;
        }
    }
    return true;

    // switch (evt.type){
    //     case 'press':
    //         return true;
    //     case 'release':
    //         return true;
    //     case 'click':
    //         return true;
    //     case 'dblclick':
    //         return true;
    //     case 'drop':
    //         return true;
    //     case 'move':
    //         return true;
    //     case 'gesture':
    //         return true;
    //     case 'menu':
    //         return true;
    //     case 'out':
    //         return true;
    //     default:
    //         return false;
    // }
}


function afterCheck(evt,controller, targetFullName){
    //mousedown mouseup click dblclick

    const
        focusGrp = controller.getFocusGrp(evt.eventPhase),
        TOUCH_STATE = controller.constructor.TOUCH_STATE;

    if(evt.default == false){
        const delIndex = focusGrp.findIndex(ele=>ele.type == evt.type&&ele.target == targetFullName);
        if(delIndex === -1)
            return;

        if(focusGrp[delIndex].type == 'dragstart'){
            controller.touchState &= ~TOUCH_STATE.drag;//stop dragging
        }
        focusGrp.splice(delIndex,1);
    }

}

function focusGrpCleaner(evt, controller, fullName){
    $assert(controller);
    //ExternalDrop : dragstart from outside of browser,  dragend would NOT be executed
    // TODO: dragstart drop dragend
    //  https://stackoverflow.com/questions/8414154/html5-drop-event-doesnt-work-unless-dragover-is-handled
    const
        focusGrp = controller.getFocusGrp(evt.eventPhase),
        isExternalDropWithoutDragStart = /drop/.test(evt.type) &&
        focusGrp.findIndex(ele=>ele.type == 'dragstart') == -1;
    //TODO: erasing [dragstart drag dragover dragenter dragleave]
    if(/dragend/.test(evt.type) || isExternalDropWithoutDragStart)
        clearFocusGrp(controller, {typeExp:/drag/}, [evt.eventPhase]);


    if(evt.type === "press"){
        $assert(fullName);
        clearFocusGrp(controller,{target:fullName,type:"move"}, [evt.eventPhase]);
        clearFocusGrp(controller,{target:fullName,type:'over'}, [evt.eventPhase]);
    }

    if(evt.type === "release"){
        $assert(fullName);
        clearFocusGrp(controller,{target:fullName,type:"move"}, [evt.eventPhase]);
        clearFocusGrp(controller,{target:fullName,type:'over'}, [evt.eventPhase]);
        clearFocusGrp(controller,{target:fullName,type:'release'}, [evt.eventPhase]);
    }



    if(evt.type === 'drop'){
        clearFocusGrp(controller,{type:"move"}, [evt.eventPhase]);
        clearFocusGrp(controller,{ typeExp:/drag/}, [evt.eventPhase]);


        $assert(fullName);
        clearFocusGrp(controller,{target:fullName,type:"move"}, [evt.eventPhase]);
        clearFocusGrp(controller,{target:fullName,type:'over'}, [evt.eventPhase]);
        clearFocusGrp(controller,{target:fullName,type:'release'}, [evt.eventPhase]);

    }

    if(evt.type === 'gesture'){
        clearFocusGrp(controller,{type:'over'}, [evt.eventPhase]);
        clearFocusGrp(controller,{type:"move"}, [evt.eventPhase]);
        clearFocusGrp(controller,{type:"press"}, [evt.eventPhase]);
    }
    if(evt.type === 'over'){
        clearFocusGrp(controller, {type:'move'},[evt.eventPhase]);
    }

    if(evt.type === 'out'){
        if(fullName){
            clearFocusGrp(controller,{type:'move'}, [evt.eventPhase]);
            clearFocusGrp(controller,{targetExp:new RegExp(fullName), type:'over'}, [evt.eventPhase]);
            clearFocusGrp(controller,{targetExp:new RegExp(fullName), type:'out'}, [evt.eventPhase]);
        }
    }


    if(evt.type == 'dragstart'){
        clearFocusGrp(controller,{ type:'move'}, [evt.eventPhase]);
        clearFocusGrp(controller,{target:fullName, type:'press'}, [evt.eventPhase]);
    }

    if(evt.type == 'dragend'){
        clearFocusGrp(controller,{ type:'move'}, [evt.eventPhase]);
        clearFocusGrp(controller,{ type:'over'}, [evt.eventPhase]);
        clearFocusGrp(controller,{ type:'release'}, [evt.eventPhase]);
    }





}

function seqInputDispatch(evt,controller){

    evt =  new KeanuCtrlEvt(evt, controller,{mode:'serialize'});
    const
        focusGrp = controller.getFocusGrp(evt.eventPhase),
        downTarget = focusGrp.find(ele=> ele.type == 'press');
    if(!downTarget)
        return false;
    const
        upTarget = focusGrp.find(ele=> ele.type == 'release'),
        clickTarget = focusGrp.find(ele =>  ele.type == 'click' && ele.buttons == downTarget.buttons);



    $assert(downTarget||upTarget);


    const short = downTarget.target.length<upTarget.target.length? downTarget:upTarget,
        long = downTarget.target.length>upTarget.target.length? downTarget:upTarget,
        isRelated = downTarget.target.length == upTarget.target.length?
            downTarget.target==upTarget.target:
            new RegExp(short.target).test(long.target),
        hasMove = focusGrp.find(ele=> ele.type == 'move' && (ele.target == short || ele.target == long));

    if(hasMove) return false;

    const oldType = evt.type;
    if(clickTarget&&isRelated&&new RegExp(clickTarget.target ).test(upTarget.target)){
        evt.type = 'dblclick';
        const
            id = evt.pointerId,
            type = evt.type,
            target = clickTarget.target,
            timestamp = evt.timestamp,
            offsetX = evt.offsetX,
            offsetY = evt.offsetY,
            originX = evt.originX,
            originY = evt.originY;

        focusGrp.push({
            id,
            type,
            target,
            timestamp,
            offsetX,
            offsetY,
            originX,
            originY,
        });
        notify(evt,$findByFullName(clickTarget.target),controller);
        evt.type = oldType;
        clearFocusGrp(controller,{type:'click'}, [evt.eventPhase]);
        clearFocusGrp(controller,{type:'dblclick'}, [evt.eventPhase]);
        clearFocusGrp(controller,{type:"press"}, [evt.eventPhase]);
        clearFocusGrp(controller,{type:"release"}, [evt.eventPhase]);
        clearFocusGrp(controller, {type:"move"}, [evt.eventPhase]);
        return true;
    }else if(!clickTarget && isRelated){

        evt.type = 'click';
        const
            id = evt.pointerId,
            type = evt.type,
            target = upTarget.target,
            buttons = downTarget.buttons,
            timestamp = evt.timestamp,
            offsetX = evt.offsetX,
            offsetY = evt.offsetY,
            originX = evt.originX,
            originY = evt.originY;

        focusGrp.push({
            id,
            type,
            target,
            buttons,
            timestamp,
            offsetX,
            offsetY,
            originX,
            originY,
        });
        notify(evt,$findByFullName(upTarget.target),controller);
        evt.type = oldType;

        clearFocusGrp(controller,{type:"press"}, [evt.eventPhase]);
        clearFocusGrp(controller,{type:"release"}, [evt.eventPhase]);
        clearFocusGrp(controller, {type:"move"}, [evt.eventPhase]);

        setTimeout(_=> clearFocusGrp(controller,{type:'click'}, [evt.eventPhase]),
                common$1.setting.CLICK_DELAY);

        return true;
    }

    return false;

}



function findTargetRecursive(results = [],evt,parent, checkFnc=_=>true, _checkFilter=checkFilter){
    $assert(evt);
    if(!checkStatus$1(parent.Status,common$1.setting.STATUS.active))
        return;


    parent.Children.forEach(child=>{

        if(!isImplement(child,IControllable))
            return;

        if (!checkStatus$1(child.status, common$1.setting.STATUS.active))
            return;
        if(!_checkFilter(evt.type, child.Filters)){
            return;
        }

        if(!checkFnc(child.FullName))
            return;

        // if(evt.type == 'press' && child.FullName == 'Brush/controller/mainLayout/twoPanelBody/body/canvasLayout/kCanvas/group') debugger;

        const pos = [evt.offsetX, evt.offsetY],
            oldPos = pos.slice(),
            isInside = checkIfInsideObj(pos,child);
        if(isInside){
            const copy = results.slice();
            copy.push({fullName:child.FullName,offset:pos.slice()});

            results.length = 0;// [a/b/c,a/b/c/d] ===> [a/b/c/d]
            //del parent FullName
            const filtered = copy.filter(ele=>!(ele.fullName.length < child.FullName.length && new RegExp(ele.fullName).test(child.FullName)));
            results.push(...filtered);
            [evt.offsetX, evt.offsetY] = pos;
            findTargetRecursive(results,evt,child,checkFnc,_checkFilter);
            [evt.offsetX, evt.offsetY] = oldPos;
        }
    });

}


function addFocusGrp(evt,controller, fullName,offset){

    if(evt.type == "press")
        clearFocusGrp(controller,{type:"press"});


    const focusGrp = controller.getFocusGrp(evt.eventPhase);
    focusGrp.push({
        id:evt.pointerId,
        type: evt.type,
        target: fullName,
        buttons:evt.buttons,
        timestamp: evt.timestamp,
        offsetX:offset[0],
        offsetY:offset[1],
        originX:evt.originX,
        originY:evt.originY
    });



}
function updateFocusGrp(evt,controller,fullName,offset){
    const

        focusGrp = controller.getFocusGrp(evt.eventPhase),
        existEntry =  focusGrp.find(({type, target, buttons})=>type == evt.type && target == fullName && evt.buttons == buttons);//new RegExp(target).test(fullName)
    $assert(existEntry);
    existEntry.timestamp = evt.timestamp;
    existEntry.offsetX = offset[0];
    existEntry.offsetY = offset[1];

    existEntry.originX = evt.originX;
    existEntry.originY = evt.originY;
}

function convert2(evt, controller,fullName, toType){//mode = 'refreshPosition'

    evt =  new KeanuCtrlEvt(evt, controller,{mode:'serialize'});

    const   focusGrp = controller.getFocusGrp(evt.eventPhase),
            id = evt.pointerId,
            type = toType,
            target = fullName,
            buttons = evt.buttons,
            timestamp = evt.timestamp,
            originX = evt.originX,
            originY = evt.originY,
            finder = focusGrp.find(ele=>ele.id == id && ele.type == type && ele.target == target);

    let offsetX = evt.offsetX, offsetY = evt.offsetY;

    controller.constructor;
        const targetObj = $findByFullName(fullName);
    if(targetObj.transform){//mode == 'refreshPosition' && !(targetObj instanceof Controller)
        const   pos = [evt.offsetX, evt.offsetY],
                transform = targetObj.transform;
        Transform2D.multiplyInv(pos, transform, pos);
        [offsetX, offsetY] = pos;
    }

    if(finder){
        finder.buttons = buttons;
        finder.timestamp = timestamp;
        finder.offsetX = offsetX;
        finder.offsetY = offsetY;
        finder.originX = originX;
        finder.originY = originY;
    }else
        focusGrp.push({
            id, type, target, buttons, timestamp,
            offsetX, offsetY,originX,originY
        });

    if(toType == 'over'){

        const related = focusGrp.find(ele=>ele.id == id && ele.type == 'over' && ele.target != target);
        if(related){
            evt.relatedTarget = $findByFullName(related.target);
        }

        evt.type = 'over';
        notify(evt,targetObj,controller);

        if(related){
            const
                newTarget = related.target,
                oldTarget = getParentsOf(targetObj,
                    ele=>ele.Filters &&ele.Filters.includes('enter'), ele=>ele.Parent).shift();

            if(oldTarget){
                const isChild =  new RegExp(oldTarget.FullName).test(newTarget);
                    oldTarget.Children.reduce((acc, ele)=>acc=acc||ele.Filters.includes('enter'), false) == false;
                if(!isChild && oldTarget){
                    evt.type = 'enter';
                    notify(evt,oldTarget,controller);
                    evt.type = 'over';
                }
            }

        }


    }else if(toType == 'out'){

        const related = focusGrp.find(ele=>ele.id == id && ele.type == 'over' && ele.target != target);
        if(related){
            evt.relatedTarget = $findByFullName(related.target);
        }

        evt.type = 'out';
        notify(evt,targetObj,controller);

        if(related){
            const
                newTarget = related.target,
                oldTarget = getParentsOf(targetObj,
                        ele=>ele.Filters &&ele.Filters.includes('leave'), ele=>ele.Parent).shift();

            if(oldTarget){
                const isChild =  new RegExp(oldTarget.FullName).test(newTarget);
                    oldTarget.Children.reduce((acc, ele)=>acc=acc||ele.Filters.includes('leave'), false) == false;
                if(!isChild && oldTarget){
                    evt.type = 'leave';
                    notify(evt,oldTarget,controller);
                    evt.type = 'out';
                }
            }

        }
    }else {
        evt.type = toType;
        notify(evt,targetObj,controller);
    }

    afterCheck(evt, controller, fullName);
    focusGrpCleaner(evt, controller, fullName);


}



function checkDragStart(evt, controller){
    const
        focusGrp = controller.getFocusGrp(evt.eventPhase),
        downObj = focusGrp.find(ele=>ele.type == 'press'),
        moveObj = focusGrp.find(ele=>ele.type == 'move');

    const isDragStart = downObj&&moveObj &&
        downObj.buttons == moveObj.buttons &&
        moveObj.target == downObj.target;//moveObj.target != downObj.target&&

    if(isDragStart){
        const fullName = downObj.target,
            target = $findByFullName(fullName);
        return target.Filters.includes('dragstart');


    }else
        return false;
}

function convert2out(evt, controller, fullName,enterType = 'over'){
    const preMouseovers = controller.getFocusGrp(evt.eventPhase).filter(ele=>ele.type == enterType&& ele.target!=fullName);

    for(const {target} of preMouseovers)
        convert2(evt,controller,target, 'out');
}

// function convert2leave(evt, controller, fullName,enterType = 'move'){
//     const
//         isChild = target=>new RegExp(target).test(fullName),
//         preMouseEnters = controller.getFocusGrp(evt.eventPhase).filter(ele=>ele.type == enterType&& !isChild(ele.target));
//
//     for(const {target} of preMouseEnters)
//         convert2(evt,controller,target, 'leave');
// }


function leaveAll(evt,controller, enterType, leaveType) {
    const preMouseovers = controller.getFocusGrp(evt.eventPhase).filter(ele=>ele.type == enterType);
    for(const {target} of preMouseovers)
        convert2(evt,controller,target, leaveType);
}

function dispatch( evt,controller,fullName, doClean = true){
    const target = $findByFullName( fullName);
    if(target instanceof controller.constructor){
        const state = evt.eventPhase == KeanuCtrlEvt.PHASE.CAPTURING_PHASE?
            'capture':'bubble';
        _callbackRootFncs(evt, controller,state);
    } else
        notify(evt, target,controller);
    if(doClean){
        afterCheck(evt,controller, fullName);
        focusGrpCleaner(evt, controller, fullName);
    }
}
function checkDrag(evt, controller,fullName){
    const
        TOUCH_STATE = controller.constructor.TOUCH_STATE,

        isDragging = controller.touchState & TOUCH_STATE.drag,
        isMulti = controller.touchState & TOUCH_STATE.multi;
    if(!isMulti&&!isDragging && checkDragStart(evt,controller)){
        const
            Controller = controller.constructor,
            TOUCH_STATE = Controller.TOUCH_STATE;
        controller.touchState |= TOUCH_STATE.drag;
    }
    // else if(isMulti){
    //     const
    //         Controller = controller.constructor,
    //         TOUCH_STATE = Controller.TOUCH_STATE;
    //     controller.touchState &= ~TOUCH_STATE.drag;
    // }

    
}
function checkMoveOrDrag(evt, controller,fullName){

    const TOUCH_STATE = controller.constructor.TOUCH_STATE;
    const isDragging = controller.touchState & TOUCH_STATE.drag;


    if(isDragging){
        const dragstart = controller.getFocusGrp(evt.eventPhase).find(ele=>ele.type == 'dragstart'),
                downObj = controller.getFocusGrp(evt.eventPhase).find(ele=>ele.type == 'press'&&ele.target == fullName);
        if(dragstart)//convert dragstart 2 drag
            convert2(evt,controller,dragstart.target,'drag');
        else if(downObj){//convert press 2 dragstart
            $assert(downObj);
            convert2(evt,controller,downObj.target,'dragstart');
        }
        // else{//dragover, FullName is not exist in FocusGrp,
        //     // then it must be new element underneath dragstart element
        //     console.log('dragover');
        //     convert2(evt,controller,fullName,'dragover');
        // }

    }
    // else {

        const
            focusGrp = controller.getFocusGrp(evt.eventPhase),
            isExistOver =  focusGrp.find(({type, target, buttons})=>type == 'over' && target == fullName && buttons == evt.buttons);
        if(!isExistOver)
            convert2(evt,controller,fullName,'over');

        convert2out(evt,controller,fullName, 'over');
        dispatch(evt, controller, fullName);

    // }
    focusGrpCleaner(evt,controller,fullName);


}

function checkReleaseOrDragend(evt,controller,fullName){
    controller.getFocusGrp(evt.eventPhase);
        const TOUCH_STATE = controller.constructor.TOUCH_STATE;
    const isDragging = controller.touchState & TOUCH_STATE.drag;

    if(isDragging && evt.isPrimary) {
        controller.touchState &= ~TOUCH_STATE.drag;
        const dragstart = controller.getFocusGrp(evt.eventPhase).find(ele=>ele.type == 'dragstart');
        if(dragstart)
            convert2(evt,controller,dragstart.target,'dragend');

        convert2(evt,controller,fullName,'drop');
    }else {

        dispatch( evt, controller,fullName, false);//dispatch release

        seqInputDispatch(evt,controller);

        afterCheck(evt,controller, fullName);
        focusGrpCleaner(evt, controller, fullName);

    }
}

function dispatchEvt(evt, controller, Controller = controller.constructor){

    if(evt.type == 'drop'){
        controller.touchState &= ~Controller.TOUCH_STATE.drag;
    }

    if(evt.type == 'press')
        console.log();

    if(evt.type == 'release')
        console.log();

    if(evt.type == 'move')
        console.log();

    $assert(controller);
    $assert(checkStatus$1(controller.Status,common$1.setting.STATUS.active));

    const
        isTargetSearch = [
            "press", "release", //'click', 'dblclick',
            "move",
            'menu', 'drop', 'gesture',
            "over",//"out",
            'enter',//'leave',

        ].find(ele=>ele===evt.type);
    if(isTargetSearch){
        let results = [];
        findTargetRecursive(results, evt, controller,fullName=>beforeCheck(evt,controller,fullName));

        const oldX = evt.offsetX, oldY = evt.offsetY;
        //$assert(results.length == 1);
        if(!results.length) return;



        $assert(results[0]);
        const {fullName, offset} = results[0];

        evt.offsetX = offset[0];
        evt.offsetY = offset[1];

        $processEvt(evt,fullName,controller);
        evt.offsetX = oldX, evt.offsetY = oldY;

    }else if(evt.type == 'out'){//mouse out of canvas
        leaveAll(evt,controller,  'enter', 'leave');
        leaveAll(evt,controller,  "over", "out");

    }
}



function $convert2ctrlEvt(controller,evt){
    //init
    const ctrlEvt = new KeanuCtrlEvt(evt, controller);
    const emitter = ctrlEvt.initialize();
    return {ctrlEvt, emitter};
}
function $processEvt(evt, fullName,controller){
    // if(evt.eventPhase == 3) return;

    const
        focusGrp = controller.getFocusGrp(evt.eventPhase),
        offset = [evt.offsetX, evt.offsetY],
        isExist  = focusGrp.find(({id,type, target, buttons})=>{
        const
            result = type == evt.type && target == fullName && buttons == evt.buttons;
        if(__ua.sysFlag & common$1.system.SYS_FLAG.Mobile)
            return result && evt.pointerId == id;

        return result;
    });//new RegExp(target).test(fullName)


    if(isExist)
        updateFocusGrp(evt,controller,fullName,offset);
    else {
        addFocusGrp(evt,controller, fullName,offset);
    }
    if(evt.isPrimary && evt.type == "move")
        checkDrag(evt, controller);


    if(evt.type == "move")
        checkMoveOrDrag(evt, controller,fullName);
    else if(evt.type == "release"){
        checkReleaseOrDragend(evt,controller,fullName);
    }else
        dispatch(evt, controller,fullName);
}

const
  _convert2localEditorCoord = function(out, target,originPos){

        const editor = $findRoot(target),
          bounding = editor.getBoundingClientRect();
        out[0] = originPos[0] - bounding.x;
        out[1] = originPos[1] - bounding.y;
  },
    _isOutsideCanvas = function(target, ref){
        if(target instanceof HTMLBodyElement) return true;

        const editor = $findRoot(ref);
        $assert(editor.CanvasDiv);
        //not same canvas, or click on empty space(caught on window event)
        if(editor.CanvasDiv != target)
            return true;
        return false;
    },$screenCoord2Local = function(evt, ref){
        const editorPos = [evt.offsetX, evt.offsetY];

        if(_isOutsideCanvas(evt.target, ref))
            _convert2localEditorCoord(editorPos, ref, editorPos);
        [evt.localX, evt.localY] = _setLocalXY(ref, editorPos);



    }, $captureDeep = function (ctrlEvt, isCheckFilter = true) {
        const focusedWin = Keanu.editors.array.find(ele=>
            isImplement(ele,IWindow) &&
            ele.Controller.Status & common$1.setting.CTRL_STATUS.active
        );
        if(!focusedWin) return [];
        if(ctrlEvt.type == 'out') return [];

        const results = [], controller = focusedWin.Controller;
        $findTargetRecursive(results, ctrlEvt, controller ,fullName=>beforeCheck(ctrlEvt,controller,fullName),isCheckFilter?checkFilter:_=>true);
        return results;
    };

const $findTargetRecursive = findTargetRecursive;


function $isDragging(evt){
    const controller = $findRoot(evt.target).Controller,
        TOUCH_STATE = controller.constructor.TOUCH_STATE,
        isDragging = controller.touchState & TOUCH_STATE.drag;
    return !!isDragging;
}

class Base extends implement(IHierachy){

    get Name() {return this.name;}
    set Name(val) {

        this.name = val;
    }

    get Children(){return this.children;}
    get Parent(){return this.parent;}
    set Parent(val){this.parent=val;}

    appendChild(child) {
        $assert(child);
        uiAddChild.call(this, child);
    }

    insertChild(index,child) {
        $assert($isNumber$1(index));
        uiInsertChild.call(this, index,child);
    }
    removeChild(child) {

        $assert(child&&child.FullName);
        uiDelChild.call(this, child);
    }



    fullName = null;
    get FullName(){return this.fullName;}

    constructor(name='__test',params={}){
        super(name,params);

        // _class[this.constructor.name] = this;
        this.name = name;
        if(!name)
            throw new Error('empty Name');

        // try{
        // this.params = JSON.parse(JSON.stringify(params));
        // }catch (e) {
        //     debugger;
        // }

        this.params = params??{};
        // try{
        //     for(let key in params){
        //         if(params[key] instanceof Base)
        //             continue;
        //         // this.params = JSON.parse(JSON.stringify(params[key]));
        //         //TODO: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/create
        //
        //         $assert(params[key] !== undefined);
        //         this.params[key] = JSON.parse(JSON.stringify(params[key]));
        //
        //     }
        // }catch (err){
        //     debugger;
        //     $assert(false, {errorType:common.error.ERR_TYPE.internalErr, msg:'failed to initialize at paletteBase.js'});
        // }



        this.hash = hashCode(this.name);
        this.hashName = hashStr(this.hash);
        this.hashFloat = new Float32Array(this.hash.buffer)[0];


        this.children = createObjList();
        this.parent = null;


    }

    async delete(){

        //TO fire onControllerDetached ONLY once
        //detach curObj first
        await this.Parent.removeChild(this);

        //then detach children
        const children = this.Children.slice();
        for(let child of children)
            child.delete();

        this.parent = null;
        this.children = null;
        this.params = null;
    }


    initialize(){

        $assert(this);
        if(isImplement(this,ILoad))
            LoadManager.addInstance(this);


        // for(let child of this.children.array)
        //     child.initialize();
        // let root = helper.$findRoot(this);
        // if(root&&!window.Keanu.editors.exist(root.name))
        //     window.Keanu.editors.push(root);
    }


    registEvt(){
        const Children = this.Children;
        $assert(Children);
        for(let child of Children)
            child.registEvt();
    }
    initListeners(){
        const children = this.Children;
        $assert(children);
        for(let child of children.array)
            child.initListeners();
    }

    // hashStr(uint8){
    //     let result = '';
    //     for(let i in uint8){
    //         let hex = uint8[i].toString(16);
    //         result += hex;
    //     }
    //     return result;
    // };




}

let _map = {};
window.keyMap = _map;
class KeyMap{
    static get Value(){
        return _map;
    }
    static clear(){
        _map = {};
    }
    static keydown(evt){

        if(_map[evt.key]){
            if(_map['Meta'])//fix for mac Meta key
                //when Meta is pressed, no keyup evt for
                //any other key. so we manually clear _map
                $debounce(_=>{
                    for(const key in _map)
                        if(key != 'Meta')
                            delete _map[key];
                }, 100);
            return false
        }


        _map[evt.key] = true;
        return true;
    }

    static keyup(evt){
        //$assert(_map[evt.key]);
        delete _map[evt.key];
        return true;
    }

}

const _uiActionStack = [];
let curMapping = common$1.setting.KEYS.ALL_KEYS;
class ShortCutsMapping{
    static get UIActionStack() {return _uiActionStack;}

    static set(value){
        curMapping = value;
        return ShortCutsMapping;
    }
    static clear(){
        KeyMap.clear();
    }
    static checkKeyMap(evt){

        if(evt.type == 'keydown')
            return  KeyMap.keydown(evt);
        else  if(evt.type == 'keyup')
            return  KeyMap.keyup(evt);
    }
    static keydown(evt,callback){

        for(let cmdEntry of curMapping){
            const {cmd, target, type} = cmdEntry;
            if(!ShortCutsMapping.isShortCutOf(cmd))
                continue;

            if(cmdEntry.type & common$1.setting.KEYS_INTERACTION_TYPE.immediate){
                callback(type, cmd,target);
                return true;
            }else if(!ShortCutsMapping.UIActionStack.find(ele=>ele.cmd == cmd && ele.target == target)){
                ShortCutsMapping.UIActionStack.push({cmd, target});
                callback(type, cmd,target);
                return true;
            }


        }

        return false;
    }

    static keyup(evt, callback){
        for(let {cmd,target} of ShortCutsMapping.UIActionStack.slice()){
            if(ShortCutsMapping.isShortCutOf(cmd))
                continue;

            callback(cmd,target);
            //console.log('keyup clear',JSON.stringify(ShortCutsMapping.UIActionStack));
            ShortCutsMapping.UIActionStack.splice(
                ShortCutsMapping.UIActionStack.findIndex(
                    ele=>ele.cmd == cmd && ele.target == target
                ));
        }

    }
    static  isShortCutOf(type){
        const cmdEntry = curMapping.find(ele=>ele.cmd == type);
        if(!cmdEntry)
            return false;


        let isAllPressed = true;
        for(let key of cmdEntry.keys){

            let refValue;

            if(key.charAt(0) == '!'){
                refValue = true;
                key = key.substring(1);
            }

            if(key == 'Meta' && navigator.platform == 'Win32')
                key = 'Alt';



            if(
                // (typeof evt[key] != 'undefined' && evt[key] == refValue) ||
                // (typeof evt[key] == 'undefined' && (evt.code == key) == refValue)

                KeyMap.Value[key] == refValue

            ){
                isAllPressed = false;
                break;
            }
        }

        if(isAllPressed){
            const editors = Object.entries(Keanu.editors.objs),
                finder = editors.find(ele=>
                    ele[1].Controller.Status & common$1.setting.CTRL_STATUS.active &&
                    common$1.setting.TARGET_WINs[ele[0]] & cmdEntry.target);
            if(finder){
                const editor = finder[1];
                isAllPressed = editor.Controller.Status & common$1.setting.CTRL_STATUS.active;
            }else
                isAllPressed = false;
        }

        return isAllPressed;
    }
}

class KeyBoard{
    static  Controllers = [];
    static MODE = {none:0,initializing:1,listening:2,inputting:4, sysCapturing:8,appCapturing:16,processing:32, editing:128};//editing128 is from imputbox
    #mode = null;
    #key = '';
    #code = '';
    #handler = null;

    name = null;
    // controller = null;
    constructor(name, {controller}){
        // KeyBoard.Controllers.push(controller);
        // this.controller = controller;
        this.#mode = KeyBoard.MODE.listening;
        this.name = name;
    }
    onImmediate = async  cmd=>{
        console.log(`cmd:${cmd}`);
        await Event$1.Instance.emit(cmd,{writeHistory:false});
    }
    onUIActionStart(cmd){
        const win = IWindow.Windows.find(ele=>ele.Controller.Status & common$1.setting.CTRL_STATUS.active);
        if(win)
            Event$1.Instance.emit(common$1.setting.EVT_TYPES.onUIAction,win, ['start', cmd]);
    }
    onUIActionEnd(cmd){
        const win = IWindow.Windows.find(ele=>ele.Controller.Status & common$1.setting.CTRL_STATUS.active );
        if(win)
            Event$1.Instance.emit(common$1.setting.EVT_TYPES.onUIAction,win, ['end', cmd]);
    }


    onKeydownCallback = async (type, cmd,target)=>{


        this.#mode |= KeyBoard.MODE.processing;

        if(type & common$1.setting.KEYS_INTERACTION_TYPE.immediate){
            console.log('immediate start',JSON.stringify(cmd));
            await this.onImmediate(cmd);
            console.log('immediate fin',JSON.stringify(cmd));
        }else if(type & common$1.setting.KEYS_INTERACTION_TYPE.interaction){
            this.onUIActionStart(cmd);
        }


        this.#mode &= ~KeyBoard.MODE.processing;
    }

    keyboardListener(evt) {


        //evt.originalEvt.preventDefault();


        if (evt.isComposing)//https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/isComposing
            return;


        if(this.#mode & KeyBoard.MODE.processing){
            console.warn('old Event is still under processing, skipping current keyboardEvt now');
            // return;
        }


        if (evt.type == 'keydown') {
            if (this.#mode & KeyBoard.MODE.inputting) {//this.#mode =KeyBoard.MODE.inputting;

                this.#code += evt.code;
                this.#key += evt.key;
                if (this.#handler && typeof this.#handler.callback == 'function')
                    this.#handler.callback(evt.key);
            }else {
                if(!ShortCutsMapping.checkKeyMap(evt))
                    return;

                const isSysCaptured = ShortCutsMapping.set(common$1.setting.KEYS.SYS_KEYS).keydown(evt, this.onKeydownCallback);
                if(isSysCaptured)
                    this.#mode |= KeyBoard.MODE.sysCapturing;
                else {
                    const  isAppCaptured = ShortCutsMapping.set(common$1.setting.KEYS.APP_KEYS).keydown(evt, this.onKeydownCallback);
                    if(isAppCaptured)
                        this.#mode |= KeyBoard.MODE.appCapturing;
                }
            }




        } else if (evt.type == 'keyup') {
            if(!ShortCutsMapping.checkKeyMap(evt))
                return;

            if (!(this.#mode & KeyBoard.MODE.inputting)){
                ShortCutsMapping.set(common$1.setting.KEYS.SYS_KEYS).keyup(evt,this.onUIActionEnd);
                this.#mode &= ~KeyBoard.MODE.sysCapturing;
                this.#mode &= ~KeyBoard.MODE.appCapturing;
            }
        }

    }
    get Handler(){return this.#handler;}
    setHandler(focusObj,callback){
        $assert(focusObj);


        //clear old handler
        if(this.#handler&& this.#handler.focus.Status)
            this.clearHandler();




        this.Mode = KeyBoard.MODE.inputting;

        this.#handler = {callback:callback??null,focus:focusObj};

    }


    static clearKeyMap(){
        ShortCutsMapping.clear();
    }

    static clearHandlers(fullName4Exclude){
        // for(const controller of KeyBoard.Controllers){
        //     const keyboard = controller.keyboard;
        //     if(keyboard.Handler && keyboard.Handler.focus.FullName != fullName4Exclude){
        //         keyboard.clearHandler();
        //         return true;
        //     }
        // }

        const keyboard = Controller.keyboard;
        if(keyboard.Handler && keyboard.Handler.focus.FullName != fullName4Exclude){
            keyboard.clearHandler();
            return true;
        }

        return false;
    }

    clearHandler(){
        const handler = this.#handler;
        this.#handler = null;
        //clear old handler
        if(handler){//&& !(handler.focus.Status & common.setting.BASIC_STATUS.deleting)
            $assert(!(handler.focus.Status&common$1.setting.BASIC_STATUS.deleting));
            handler.focus.Mode &=  ~KeyBoard.MODE.editing;// = TextBox.MODE.editing
            this.Mode = KeyBoard.MODE.listening;
        }
    }

    set Mode(value){
        if(this.#mode!=KeyBoard.MODE.inputting && value == KeyBoard.MODE.inputting){
            value &= ~KeyBoard.MODE.listening;
            this.#key = '';
        }



        if(this.#mode!=KeyBoard.MODE.listening && value == KeyBoard.MODE.listening){
            value &= ~KeyBoard.MODE.inputting;
            this.#key = '';
        }


        this.#mode = value;
    }
    get Mode(){return this.#mode;}


    clear(){
        this.clearHandler();
    }

    delete(){

        // const index = KeyBoard.Controllers.findIndex(ele=>ele.name == this.controller.name);
        // KeyBoard.Controllers.splice(index,1);

        this.clear();

        this.#mode = null;
        this.#key = '';
        this.#code = '';
        this.#handler = null;
    }


}

class ControlFilterManager{

    target = null;
    constructor(target) {
        target.filterValue = 0;
        this.target = target;
    }

    get Value (){
        return this.target.filterValue;
    }
    set Value(val){
        this.target.filterValue = val;
    }


    clear=_=>{
        this.target.filterValue = 0;
    };


    includes = evtType=> this.Value & common$1.setting.CONTROL_FILTER_BITs[evtType]?true:false;

    add = evtType=> {
        return this.Value |= common$1.setting.CONTROL_FILTER_BITs[evtType];
    };


    //0b0101 ^ 0b0011 = 0b0111
    expand =  (filterObj, excludes = [])=> {
        let inputValue = filterObj.Value;
        for(const type of excludes){
            const mask = common$1.setting.CONTROL_FILTER_BITs[type];
            if( mask & inputValue)
                inputValue &= ~mask;
        }
        return this.Value |= inputValue;
    }

    print = (verbose = 0)=>{
        const results = [];
        for(const [key,value] of Object.entries(common$1.setting.CONTROL_FILTER_BITs)){
            if(verbose === 0){
                if(value&this.Value)
                    results.push(key);
            }else
                if(value&this.Value && this.target.controllableStore.find(ele=>ele.evtType === key))
                    results.push(key);
        }
        return results;
    }
}

function __findController(target){
    if(target.Controller instanceof Controller)
        return target.Controller;
    return __findController(target.parentElement);
}

const setting$1 =common$1.setting,
    STATUS = common$1.setting.STATUS;
setting$1.CLICK_DELAY;
// const _focusGrp = [];
let __SINGLETON = null;
class Controller extends implement(Base,IControllable, IConnection){


    static TOUCH_STATE = {init:0,press:1,move:2, multi:4, drag:8,  gesture:64, start:128,change:256};//,release:0//menu:128


    touchState = Controller.TOUCH_STATE.init;

    filters = 0;
    #children = null;
    #parent = null;
    #evtStack = [];
    #mode = 0;
    #listenerTable = {
        canvas:{
            bubble:new Map(),
            capture:new Map(),
        }, window:{
            bubble:new Map(),
            capture:new Map(),
        }};

    static sharedController = new Controller('shared',{status:STATUS.active|STATUS.visible|STATUS.creating|STATUS.layoutable});
    focusGrp = {bubble:[], capture:[]};
    getFocusGrp(phase){
        if($isNumber$1(phase))
            return this.focusGrp[(phase===1?'capture':'bubble')];
        else if(typeof phase === 'string')
            return this.focusGrp[phase];
    }

    timestamp = null;
    //controlables = null;
    offsetX = null;
    offsetY = null;
    get FullName (){

        let result = getParentsOf(this);
        result.unshift(this);
        return result.map(ele=>ele.Name).reverse().join('/');
    }



    controllerDiv = null;
    filterManager = null;
    constructor(name='__test',params={}){
        super(name,params);
        this.name = name;
        this.evtPool = {};
        this.status = //STATUS.active

            params.status??
            STATUS.visible|STATUS.creating|STATUS.layoutable;

        this.timestamp = Date.now();
        this.filterManager = new ControlFilterManager(this);

        if(params.async)
            this.#mode = setting$1.CONTROLLER_MODE.async;

        this.controllerDiv = params.div?params.div:document.getElementById('controller');

        // this.sendingControllerData = params?params.sendingControllerData:false;
        this.stopPropagation = params&&params.stopPropagation?true:false;
        this.preventDefault =  params&&params.preventDefault?true:false;


        this.history = params.history?params.history:[];



        this.initConnection(hierarchyConnection);

        const refresh = this.refresh, init = this.initialize;
        this.refresh = _=>{

            if(!(this.status & common$1.setting.STATUS.active))
                return;

            if(this.status & common$1.setting.BASIC_STATUS.deleting)
                return;
            if(this.status & common$1.setting.BASIC_STATUS.creating)
                return;
            if(this.status & common$1.setting.BASIC_STATUS.loading)
                return;

            return refresh.call(this);
        };

        this.initialize = async _=>{
            await init.call(this);


            this.status &= ~common$1.setting.BASIC_STATUS.creating;
        };


    };

    __DELAY_RESET = false;
    static DELAY_RESET_BEGIN(controller){
        $assert(controller&&controller.refresh);
        controller.__DELAY_RESET = true;
        __SINGLETON = controller;
    }
    static DELAY_RESET_END(){
        __SINGLETON.__DELAY_RESET = false;

        resetFilter(__SINGLETON,Controller);
        __SINGLETON = null;
    }
    clearFocusGrp(){
        this.getFocusGrp('capture').length = 0;
        this.getFocusGrp('bubble').length = 0;
    }
    clear(){
        this.clearFocusGrp();
        this.clearConnection();

    }
    delete(){
        for(let evtType in this.EvtPool)
            this.parent.removeEventListener(evtType,evt=>{this.listen(evt);});

        this.keyboard.delete();
        this.filterManager = null;

        this.controllerDiv = null;
        this.inputs = null;
        this.outputs = null;

        this.history = null;

        this.filters = null;
        this.EvtPool = null;
        this.#children = null;
    }
    get EvtStack(){return this.#evtStack;}
    flushAsyncStack(){
        for(let ctrlEvt of this.#evtStack)
            // this.dispatchPointerEvt(ctrlEvt);
            dispatchEvt(ctrlEvt, this);
        this.#evtStack.length = 0;
    }

    static rootWindowHandler(evt){
        // if(evt.type == 'pointerup') debugger;
        const controller = Controller.sharedController;
        if(!checkStatus$1(controller.Status,common$1.setting.STATUS.active))
            return;


        //TODO: sharedController cannot be record
        // if(checkStatus(controller.Mode, common.setting.CONTROLLER_MODE.recording))
        //     Controller.recordEvt(evt, controller);



        const {ctrlEvt, emitter} = $convert2ctrlEvt(controller, evt);
        $processEvt(ctrlEvt, controller.FullName,controller);   //process routine
        emitter.emit();                                         //emit zoom/scroll/menu
    }
    static recordEvt(evt,controller){
        let ctrlEvt = null;
        if(evt instanceof PointerEvent || evt instanceof MouseEvent)
            ctrlEvt = KeanuCtrlEvt.serialize(new KeanuCtrlEvt(evt, this,{mode:'serialize'}));
        else // keyboard
            ctrlEvt = KeyBoardCtrlEvt.serialize(new KeyBoardCtrlEvt(evt));

        controller.recordEvt(ctrlEvt);
    }
    static listenHandler(evt, controller = __findController(evt.target)){
        // if(evt.type != 'pointermove')
        // console.log(evt.type, evt.eventPhase);
        $assert(controller);


        if(!checkStatus$1(controller.Status,common$1.setting.STATUS.active))
            return;

        // const isOutside = (evt.offsetX<0||evt.offsetY<0||evt.offsetX>controller.Width || evt.offsetY>controller.Height);
        // offsetXY doesn't work with customEvt dispatch in emulation

        const {x,y} = evt.target.getBoundingClientRect(),
            offset = [evt.clientX-x, evt.clientY-y];
        const isOutside = (offset[0]<0||offset[1]<0||offset[0]>controller.Width || offset[1]>controller.Height);
        if(evt.type != 'pointerout' && isOutside)
            return;

        $assert(!(this.StatusOfMasked & common$1.setting.BASIC_STATUS.creating));


        if(checkStatus$1(controller.Mode, common$1.setting.CONTROLLER_MODE.recording))
            Controller.recordEvt(evt, controller);

        const {ctrlEvt, emitter} = $convert2ctrlEvt(controller, evt);
        if(controller.Mode & common$1.setting.CONTROLLER_MODE.async)
            return controller.EvtStack.push(ctrlEvt);
        else
            dispatchEvt(ctrlEvt, controller);  //process routine

        emitter.emit();  //emit zoom/scroll/menu

    };

    get Boundary(){return [0,0,this.controllerDiv.width,this.controllerDiv.height]}



    set Mode (val){
        this.#mode = val;
    }
    get Mode (){return this.#mode;}


    get Filters(){
        return this.filterManager;
    }

    get EvtPool(){return this.evtPool;}

    // focusGrp = [];
    set Status(val){
        const mask = common$1.setting.STATUS.active,
            isRefreshing =  (val&mask) != (this.status&mask);
        this.status = val;
        if(!checkStatus$1(this.status,mask))
            KeyBoard.clearKeyMap();

        if(isRefreshing)
            this.refresh();

    }
    get Status(){return this.status;}

    static keyboard = null;
    async initialize(){

        await super.initialize();

        if(Controller.keyboard == null){
            Controller.keyboard = new KeyBoard('keyboard',{controller:this});
            window.addEventListener('keydown', evt=>{
                const win = document.activeElement;
                if(!isImplement(win,IWindow))//win instanceof UIWindow
                    return;
                const controller = win.Controller;
                Controller.dispatchKeyboardEvt(evt,controller);
            });
            window.addEventListener('keyup', evt=> {
                const win = document.activeElement;
                if(!isImplement(win,IWindow))
                    return;
                const controller = win.Controller;
                Controller.dispatchKeyboardEvt(evt,controller);
            });
        }
        // Event.Instance.onUnicon(common.setting.EVT_TYPES.onPopupMenu, function(evt, state){
        //     debugger;
        //     if(state == 'open'){
        //         const controller = $findRoot(evt.publisher).Controller;
        //         controllerHelper.clearFocusGrp(controller);//clear all
        //     }else if(state == 'close'){
        //
        //     }
        // });
    }
    static dispatchKeyboardEvt(evt, controller){
        $assert(controller);
        const win = controller.parent;
        if(win.Status & common$1.setting.CTRL_STATUS.active)
            Controller.keyboard.keyboardListener(new KeyBoardCtrlEvt(evt));

    }

    recordEvt(evt){
        $assert($isNumber$1(this.frmIndex));
        if(!this.history[this.frmIndex])
            this.history[this.frmIndex] = [];
        this.history[this.frmIndex].push(evt);
    }


    // dispatchPointerEvt(ctrlEvt){
    //
    //     if(checkStatus(this.Status,Controller.STATUS.active)) {
    //
    //         let isPreparing = false;
    //         this.Children.forEach((uiChild)=> {
    //             if(!interfaces.isImplement(uiChild,IControllable))
    //                 return true;//continue;
    //
    //
    //             // if (common.checkStatus(uiChild.Status, Controller.STATUS.preparing))
    //             //     console.log(uiChild.name, 'is preparing');
    //             // isPreparing |= common.checkStatus(uiChild.Status, Controller.STATUS.preparing);
    //
    //         });
    //
    //         if(isPreparing)//skip when one child is preparing
    //             return;
    //
    //         controllerHelper.dispatchEvt(ctrlEvt, this);
    //     }
    //
    //
    // };


    async appendChild(child){
        $assert(child);
        uiAddChild.call(this, child);
        // const decendents = depthFirstSearch(child,
        //     ele=> !checkStatus(ele.Status, common.setting.STATUS.deleting));

        const controller = this;
        await Event$1.Instance.emit(common$1.setting.EVT_TYPES.onControllerAttached, child, [controller]);


    };
    async insertChild(index,child) {
        $assert(child instanceof Controllable && $isNumber$1(index));
        uiInsertChild.call(this, index,child);

        // const decendents = depthFirstSearch(child,
        //     ele=> !checkStatus(ele.Status, common.setting.STATUS.deleting));

        // for(const decendent of decendents)
        //     Event.Instance.emit(common.setting.EVT_TYPES.onControllerAttached, decendent, [this,decendent]);


        const controller = this;
        await Event$1.Instance.emit(common$1.setting.EVT_TYPES.onControllerAttached, child, [controller]);
    }
    async removeChild(child){
        $assert(child);
        uiDelChild.call(this, child);
        // const decendents = depthFirstSearch(child,
        //     ele=> !checkStatus(ele.Status, common.setting.STATUS.deleting));
        // for(const decendent of decendents)
        //     Event.Instance.emit(common.setting.EVT_TYPES.onControllerDetached,decendent, [this, decendent,this.Parent,decendents]);
        await Event$1.Instance.emit(common$1.setting.EVT_TYPES.onControllerDetached,child, [this, child]);

    }

    startRecord(){
        this.frmIndex = 0;
        this.clearFocusGrp();
        if(!checkStatus$1(this.Mode, setting$1.CONTROLLER_MODE.recording)){
            this.Mode |= setting$1.CONTROLLER_MODE.recording;
            this.updateFrmInterval = window.setInterval(_=>{
                this.frmIndex++;
            },1000/60);
        }
    }
    stopRecord(){
        this.Mode &= ~setting$1.CONTROLLER_MODE.recording;
        window.clearInterval(this.updateFrmInterval);
        this.frmIndex = 0;
        this.clearFocusGrp();
        this.updateFrmInterval = null;
        return this.history;
    }



    saveRecord(){
        // const json = KeanuCtrlEvt.serialize(this.history);

        const json = JSON.stringify(this.history);
        console.log(json);
        downloadURL(json, 'mouse.sim');
    }

    startEmulation(history = this.history, fps = 60){

        const ui = this.Parent;
        ui.Status &= ~common$1.setting.STATUS.visible; //set invisible allows emulator to handle rendering
        this.frmIndex = 0;
        this.clearFocusGrp();
        this.Mode &= ~setting$1.CONTROLLER_MODE.recording;
        this.Mode |= setting$1.CONTROLLER_MODE.emulating;




        this.updateFrmInterval = $animate(steps=>{

            const data = history[this.frmIndex];
            this.parent.Title.text = `emulating:${this.frmIndex}`;
            if(data)
                for (const dataIndex in data){

                    ui.drawUI();
                    const canvas = this.parent.firstChild;
                    $assert(this.parent&&canvas.constructor.name == 'HTMLCanvasElement');


                    const {evt} = data[dataIndex];
                    if(evt.rawData && evt.rawData.dragInfo){

                        const isNOTSameController = JSON.parse(evt.rawData.dragInfo).source != this.parent.name;
                        if(isNOTSameController){
                            this.touchState |= Controller.TOUCH_STATE.drag;
                            window.__dragData.raw = evt.rawData;
                            const dragInfo = JSON.parse(evt.rawData.dragInfo);
                            const editor = Keanu.editors.objs[dragInfo.source];
                            window.__dragData.controller = editor.Controller;
                        }
                    }
                    const customEvt = this.genEvent(evt);
                    customEvt.frmIndex = this.frmIndex;

                    if(customEvt instanceof KeyboardEvent)
                        Controller.dispatchKeyboardEvt(customEvt);
                    else
                        //Controller.listenHandler(customEvt, this);
                        canvas.dispatchEvent(customEvt);

                    const {x,y} = canvas.getBoundingClientRect();
                    const origin = [customEvt.clientX-x,customEvt.clientY-y];

                    this.debugMouseDraw(ui.ctx,this.frmIndex,...origin);

                }
            else
                ui.drawUI();

            this.frmIndex++;
            if(this.frmIndex == history.length){
                this.frmIndex = 0;
                this.clearFocusGrp();
            }
        },1000/fps);

    }

    stopEmulation(frm){

        window.clearInterval(this.updateFrmInterval);
        this.frmIndex = 0;
        this.clearFocusGrp();
        this.Mode &= ~setting$1.CONTROLLER_MODE.recording;
        this.Mode |= setting$1.CONTROLLER_MODE.emulating;

        const ui = this.Parent;
        ui.Status |= common$1.setting.STATUS.visible;

        if($isNumber$1(frm)){
            this.frmIndex = frm;
            ui.Status &= ~common$1.setting.STATUS.visible;//set invisible allows emulator to handle rendering
            const data = this.history[frm];
            if(data && data.length>0){
                const {evt} = data[0],
                    type = evt.type == 'keydown' || evt.type == 'keyup' ? 'keyboard':'mouse',
                    customEvt = this.genEvent(evt,type);

                customEvt.frmIndex = this.frmIndex;

                if(type == 'keyboard')
                    this.dispatchKeyboardEvt(customEvt);
                else
                    // this.dispatchPointerEvt(customEvt);
                    dispatchEvt(customEvt, this);
                ui.drawUI();
                if(type == 'keyboard')
                    this.debugKeyBoardDraw(ui.ctx, customEvt.type, customEvt.key);
                else

                    this.debugMouseDraw(ui.ctx,frm,evt.offsetX,evt.offsetY);
            }else
                ui.drawUI();
        }

    }

    debugMouseDraw(ctx,frmIndex, x,y){
        ctx.fillStyle = 'rgba(200,0,0,0.8)';
        ctx.font = '20px Verdana';
        ctx.fillText(frmIndex, x+20, y);

        ctx.beginPath();
        ctx.arc(x,y,5,0,2*Math.PI);
        ctx.closePath();
        ctx.fill();

        if(window.__emulatingGhostImg)
            ctx.drawImage(window.__emulatingGhostImg, x,y);
    }


    debugKeyBoardDraw(ctx, type, key){
        ctx.fillStyle = 'black';
        ctx.font = '20px Verdana';
        ctx.fillRect(0,0,100,30);
        ctx.fillText(`${type}:${key}`, 5, 15);
    }



    genEvent(evt){

        let customEvent;
        $assert(evt);

        switch (evt.klass){
            case 'PointerEvent':
                customEvent = new PointerEvent(evt.type,evt);
                break;
            case 'MouseEvent':
                customEvent = new MouseEvent(evt.type,evt);
                break;
            case 'WheelEvent':
                customEvent = new WheelEvent(evt.type,evt);
                break;
            case 'KeyboardEvent':
                customEvent = new KeyboardEvent(evt.type,evt);
                break;

            default:
                $assert(true);

        }

        return customEvent;
    }

    updateEventListenerFilter(target, Controller = this.constructor){

        updateFilter(target.Parent,Controller);
    }


    registEventListener(obj,paramsGrp,  binder = this.parent){
        $assert(binder);
        const
            listener = isImplement(binder,IWindow) ? 'canvas':'window',
            table = this.#listenerTable[listener], newTypes = new Set();



        for(let {evtType, fnc, isCapture} of paramsGrp) {
            if(typeof(isCapture) == 'object' )
                isCapture = !!isCapture.capture;

            const register = table[isCapture?'capture':'bubble'];
            newTypes.add(evtType);
            $updateEventRegister(evtType,obj,register,binder,isCapture, 'add', Controller);

        }

        if(newTypes.size)//&& obj.Status& common.setting.STATUS.active
            registFilter(this,newTypes, obj,Controller);

    };

    unregistEventListener(obj,paramsGrp, binder = this.parent,updateFilter = true){
        $assert(paramsGrp&&paramsGrp.length);

        const
            listener = isImplement(binder, IWindow)? 'canvas':'window',
            table = this.#listenerTable[listener];



        for(let {evtType, fnc, isCapture} of paramsGrp) {
            if(typeof(isCapture) == 'object')
                isCapture = isCapture.capture ? true : false;

            const register = table[isCapture?'capture':'bubble'];
            $updateEventRegister(evtType,obj,register,binder,isCapture, 'remove',Controller);
        }


        if(updateFilter)
            resetFilter(this,Controller);
    }

    static addEventListener(evtType,fnc,optional = false){
        const isCapture = optional === true || optional.capture === true?true:false;
        const controller = Controller.sharedController;
        addEventListener(controller ,evtType, fnc, isCapture);
        controller.registEventListener(controller,[{evtType,fnc,isCapture}], window);
    };
    static removeEventListener(evtType,fnc,optional = false){
        const isCapture = optional === true || optional.capture === true?true:false;
        const controller = Controller.sharedController;
        removeEventListener(controller, evtType, fnc,isCapture);
        controller.unregistEventListener(controller,[{evtType,fnc,isCapture}], window);
    };

    static checkEventListener(evtType,fnc){
        const controller = Controller.sharedController;
        return checkEventListener(controller, evtType, fnc);
    };
    refresh(){
        //this.controlables = depthFirstSearch(this,condition);
        resetFilter(this,Controller);
    }



}

// http://service-jap4xjac-1302931958.gz.apigw.tencentcs.com/release/sts


class TencentCloudCOS {
    #region;
    #bucket;
    #cosHelper;
    #bucketRootURL;

    cache = {};
    constructor(setting) {
        this.#region = setting.region;//;
        this.#bucket = setting.bucket;//;
        this.#bucketRootURL = this.#bucket + '.cos.' + this.#region + '.myqcloud.com';
        const cos = new COS({

            SecretId: 'AKID7HBqEPSFxs3yd3oiom5xc3FC3z8D91YF',
            SecretKey: 'mLfLvjJg492j9LNINKAtcLo10NSbUBNK'
        });

        this.#cosHelper = cos;
    }

    get Bucket() {
        return this.#bucket;
    }

    get Region() {
        return this.#region;
    }



    upload(filePath, fileBlob = null, callback) {
        return new Promise((resolve, reject) => {
            let fileName = filePath.substr(1);

            let params =
                fileBlob == null//if it is folder
                    ? {
                        Bucket: this.#bucket,
                        Region: this.#region,
                        Key: fileName + "/",//folder path
                        Body: "",
                    } : {
                        Bucket: this.#bucket,
                        Region: this.#region,
                        Key: fileName,
                        Body: fileBlob,
                        ContentType: fileBlob.type??'application/octet-stream',

                        // onProgress: function (progressData) {
                        //     if (callback) {
                        //         callback(progressData);
                        //     } else {
                        //         console.log(JSON.stringify(progressData));
                        //     }
                        // },
                    };

            this.#cosHelper.putObject(params, (err, data) => {
                if (err) reject(err);
                else resolve(data);
            });
        });
    }
    getCacheID(path, versionId){
        return path+'|'+versionId;
    }


    download(path, versionId, callback) {
        const cacheID = this.getCacheID(path,versionId);
        if(this.cache[cacheID])
            return Promise.resolve(this.cache[cacheID]);
        else
            return new Promise(resolve=>
                this.#cosHelper.getObject({
                    Bucket: this.#bucket,
                    Region: this.#region,
                    Key: path,
                    VersionId: versionId,
                    DataType: 'blob',
                    onProgress: info => callback(path, info),
                    //Sign: false,
                }).then(res => {
                    const blob = res.Body;
                    this.cache[cacheID] = blob;
                    return resolve(blob);
                }));

    }

    listFiles(prefix) {
        return new Promise((resolve, reject) => {
            this.#cosHelper.getBucket(
                {
                    Bucket: this.#bucket,
                    Region: this.#region,
                    Prefix: prefix, // like 'a/', ends up with slash
                },
                (err, data) => {
                    if (err) reject(err, err.stack);
                    else {

                        // if (file.Key.endsWith("/") && file.Key.slice(0, -1) === src) return;
                        const result = [];
                        data.Contents.forEach(file=>{
                            debugger;
                            if (!file.Key.endsWith("/"))//&& file.Key.slice(0, -1) === src
                                result.push(file);
                        });
                        resolve(result);
                    }
                }
            );
        });
    }


    moveFile(srcPath, dstPath) {
        srcPath = srcPath.startsWith('/')?srcPath.substring(1,srcPath.length):srcPath;
        return this.#cosHelper.putObjectCopy({
            Bucket: this.#bucket,
            Region: this.#region,
            Key: dstPath,
            CopySource: `${this.#bucketRootURL}/${srcPath}`})
        .then(({Location,VersionId})=>
            Promise.resolve({
                path:Location.substring(this.#bucketRootURL.length,Location.length),
                version:VersionId
            }));
    }



    delete(filePath, versionId = null) {
        return new Promise(async (resolve, reject) => {
            let fileName = filePath.substr(1);
            if (fileName.includes(".")) {
                let params = {
                    Bucket: this.#bucket,
                    Region: this.#region,
                    Key: fileName,
                };
                if (versionId) params["VersionId"] = versionId;
                this.#cosHelper.deleteObject(params, (err, data) => {
                    if (err) reject(err, err.stack);
                    else {
                        resolve(data);
                    }
                });
            } else {
                // delete folder
                let files = await this.listFiles(fileName);
                let deleteObjects = files.map((file) => {
                    return {
                        Key: file.Key,
                    };
                });
                let params = {
                    Bucket: this.#bucket,
                    Region: this.#region,
                    Objects: deleteObjects,
                    Quiet: false,
                };

                this.#cosHelper.deleteMultipleObject(params, (err, data) => {
                    if (err) reject(err, err.stack);
                    else resolve(data);
                });
            }
        });
    }
}

class UploadSetting {

    store = null;
    constructor(cloudSettings){
        if(cloudSettings.vendor === 'tencent')
            this.store = new TencentCloudCOS(cloudSettings);
        else if(cloudSettings.vendor === 'amazon')
            this.store = new S3Singleton(cloudSettings);
    }


    get Store(){

        const
            id = window.config.project,
            {download,upload} = this.store;

        return {
            download:(path,version)=> download.call(this.store,id,path,version),
            upload:(path,blob) => upload.call(this.store,id,path,blob),
        }
    }

    get Stack(){return stack;}
}

/*
*  Copyright (c) 2015 The WebRTC project authors. All Rights Reserved.
*
*  Use of this source code is governed by a BSD-style license
*  that can be found in the LICENSE file in the root of the source
*  tree.
*/

function getSupportedMimeTypes(possibleTypes) {
    return possibleTypes.filter(mimeType => {
        return MediaRecorder.isTypeSupported(mimeType);
    });
}
function createVideo(){
    const video = document.createElement('video');
    video.style['position'] = 'absolute';
    video.style['bottom'] = '1px';

    video.width = 200;
    video.height = 100;
    video.setAttribute("controls", "controls");
    document.body.appendChild(video);
    return video;
}

const INIT_RECORDER = async  (setting)=>{
    window.recorder = null;
    window.initRecord =  async function(){
        const video = createVideo();
        //RECORDER=====================
        video.autoplay = true;
        video.muted = true;
        video.playsinline = true;
        window.recorder = new Recorder();
        await recorder.initialize();
        video.srcObject = window.recorder.streamSrc;
    };
    await initRecord();

    window.startRecord =  async function(){
        if(window.recorder == null ) return;

        Event$1.Instance.clear();
        console.log('startRecord');
        return window.recorder.startRecord();
    };

    function upload(file){
        // const root = $getFileEntry($getProjFolder());
        // const validName = $getValidName(root, file.name, $OUTLINE_RENAME_CHECKER);
        // const path = `${root.Path}/${validName}`;

        const path = `${$PROJ_PATH(window.config.project)}/${file.name}`;
        const {Store} = new UploadSetting(setting);
        return Store.upload(path, file);
    }

    let fileName = null;
    window.stopRecord =  async function(){
        if(window.recorder == null ) return;

        fileName = Date.now().toString();
        const   mp4Name =  `${fileName}.mp4`,
            historyFileName =  `${fileName}.history`;
        return window.recorder.stopRecord()
            .then( _=> upload(new File(window.recorder.blobs, mp4Name) ))
            .then(_=>Event$1.Instance.save('history'))
            .then(history=>  $JSON2File(history,historyFileName))
            .then(file=>upload(file))
            .then(_=>{
                const url = new URL(window.location.href);
                const params = new URLSearchParams(url.search);
                params.set('replay', fileName);
                console.log(`${url.origin}${url.pathname}?${params.toString()}`);
                // window.open(`${url.origin}${url.pathname}?${params.toString()}`)
            })
    };

    window.replay = function(){
        if(fileName == null) return;
        const url = new URL( window.location.href);
        url.searchParams.delete('record');
        url.searchParams.set('replay', fileName);
        window.open(url, '_blank');

    };
};
const INIT_REPLAY = (setting, replayName)=>{


    const   {Store} = new UploadSetting(setting),
            projPath = $PROJ_PATH(config.project),
            videoURL = `${projPath}/${replayName}.mp4`,
            historyURL = `${projPath}/${replayName}.history`;

    const video = createVideo();
    // video.src = videoURL;

    return Store.download(videoURL)
        .then(videoBlob=>{
            const blobURL =  URL.createObjectURL(videoBlob);
            const source = document.createElement('source');
            source.setAttribute('src', blobURL);
            video.appendChild(source);

            return Store.download(historyURL)
                .then(res=>res.text())
                .then(history=>{

                    const {history:stackHistory} = JSON.parse(history);

                    const timer = {current:0, index:0},
                        evtCore =  Event$1.Instance;


                    const LOCKER_REPLAY = `replay.lock`;



//https://developer.mozilla.org/en-US/docs/Web/API/Canvas_API/Manipulating_video_using_canvas
//https://jsfiddle.net/3qro8ebc/


                    let videoTime;
                    video.ontimeupdate = async _=>{

                        videoTime = video.currentTime;


                        const release = await lock$1(LOCKER_REPLAY);

                        if(timer.current > videoTime);


                        timer.current = videoTime;

                        await evtCore.replayHistory(timer,stackHistory);

                        release();

                    };


                    video.onseeking = (event) => {
                        $debounce(async _=>{
                            if(timer.current < videoTime) return;

                            const release = await lock$1(LOCKER_REPLAY);
                            timer.current = videoTime;
                            timer.index = 0;

                            await evtCore.clear();

                            await evtCore.emit(common$1.setting.EVT_TYPES.onClear);
                            release();


                        }, 200);
                    };
                })
        })



};
class Recorder{
    static CODEC =  [
        'video/mp4;codecs=h264,aac',
        'video/webm;codecs=h264,opus',
        'video/webm;codecs=vp9,opus',
        'video/webm;codecs=vp8,opus',
    ];
    streamSrc = null;
    options = null;
    codecs = null;
    mediaRecorder = null;
    blobs = [];
    constructor() {

    }
    async initialize(){
        this.options = {};
        const setting = $readFileDataValue(`${window.config['projPath']}|record`);
        if(setting.video)
            this.options.video = {
                width: 200, height: 100
            };
        if(setting.audio)
            this.options.audio =  {
                echoCancellation: {exact:true}//hasEchoCancellation
            };
        this.streamSrc = await navigator.mediaDevices.getUserMedia(this.options);
        this.codecs = getSupportedMimeTypes(Recorder.CODEC);


        //has to be empty on() in order to save onRecord into History
        Event$1.Instance.on(common$1.setting.EVT_TYPES.onRecord,_=>console.log());
    }
    startRecord(mimeType = this.codecs[0]){
        this.blobs.length = 0;
        try {
            this.mediaRecorder = new MediaRecorder(this.streamSrc, {mimeType});
        } catch (e) {
            console.error('Exception while creating MediaRecorder:', e);
            return;
        }        Event$1.Instance.emit(common$1.setting.EVT_TYPES.onRecord,['start', this.streamSrc]);
        this.mediaRecorder.ondataavailable = evt=>{
            if (evt.data && evt.data.size > 0) {
                this.blobs.push(evt.data);
            }
        };
        this.mediaRecorder.start();

    }
    stopRecord() {
        return new Promise(resolve=>{
            this.mediaRecorder.stop();
            this.mediaRecorder.onstop = (event) => resolve();
        })
    }
    saveRecord(name='unnamed',mimeType = 'application/octet-stream'){
        downloadURL(this.blobs,`${name}.mp4`,{type: mimeType});
    }

}

class Graphics {

    gl = null;
    canvas;
    constructor( width=400, height=300,canvas = typeof OffscreenCanvas !== 'undefined'?new OffscreenCanvas(width,height):document.createElement('canvas')) {
        this.report = {};
        this.canvas = canvas;
        canvas.width = width;
        canvas.height = height;
        this.gl = canvas.getContext('webgl', {stencil: false, alpha: false, preserveDrawingBuffer: true});

        this.gl.viewportWidth = width;
        this.gl.viewportHeight = height;

        $assert(this.gl);

        //enable int32 index array
        var ext = this.gl.getExtension("OES_element_index_uint");
        if (!ext)
            this.report.OES_element_index_uint = false;
        else
            this.report.OES_element_index_uint = true;

        ext = this.gl.getExtension("ANGLE_instanced_arrays");
        if (!ext)
            this.report.ANGLE_instanced_arrays = false;
        else
            this.report.ANGLE_instanced_arrays = true;
    };
    delete(){
        this.gl = null;
    }
}

let _graphic;
class GLFramework{
    static get Materials(){return window.__materials;}
    static get Graphics(){return _graphic;}
    constructor(canvas ) {
        _graphic = new Graphics(canvas);
    }

}

class Transform3D extends implement(IConnection,ISerializable){

    static serialize(transform){};
    static deserialize(bson){};


    #globalPosition =  [0,0];
    #updateCallback = null;
    set UpdateCallback(value){
        $assert(typeof value == 'function');
        this.#updateCallback = value;
    }
    globalMatrix =  [1,0,0,     0,1,0,      0,0,1,      0,0,0]; //3x4
    localMatrix =   [1,0,0,     0,1,0,      0,0,1,      0,0,0]; //3x4
    rotationMatrix = [1,0,0,    0,1,0,      0,0,1]              //3x3
    quat = [0,0,0,1];

    pivot = [0,0,0];
    position = [0,0,0];
    rotation = [0,0,0];
    quat = [0,0,0,1];
    scale = [1,1,1];
    constructor(name='__test',def={}){
        super();
        this.name = name;



        this.initConnection(transformConnection);
        this.#updateCallback = def&&def.updateCallback?def.updateCallback:null;
    };
    delete(){
        this.name = null;
        this.position = null;
        this.#globalPosition =  null;

        this.globalMatrix =  null;
        this.localMatrix =    null;
        this.pivot =  null;
        this.rotation =  null;
        this.quat =  null;
        this.scale =  null;

        //this.#inputs =  null;
        this.#updateCallback =  null;


    }



    set Pivot(value){

        $assert(value instanceof  Array && value.length == 3);
        this.pivot = value.slice();
        this.update();

    };
    get Pivot(){
        return this.pivot;
    }


    //[T][+p][RS][-P]
    //move position to compensate pivot
    insertPivot(pivot){
        const mat = this.localMatrix,
            pdx = pivot[0],
            pdy = pivot[1],
            pdz = pivot[2],

            dx =  mat[0]*-pdx + mat[3]*-pdy + mat[6]*-pdz + pdx,
            dy =  mat[1]*-pdx + mat[4]*-pdy + mat[7]*-pdz + pdy,
            dz =  mat[2]*-pdx + mat[5]*-pdy + mat[8]*-pdz + pdz;

        this.position[0] = mat[9] - dx;
        this.position[1] = mat[10] - dy;
        this.position[2] = mat[11] - dz;

        this.Pivot = pivot;
    }

    move(value){
        $assert(value instanceof Array);
        this.position[0] += value[0];
        this.position[1] += value[1];
        this.position[2] += value[2];
        this.update();
    }
    set Position(value){
        $assert(value instanceof Array);

        this.position[0] = value[0];
        this.position[1] = value[1];
        this.position[2] = value[2];

        this.update();
    };
    get Position(){return this.position;}
    get GlobalPosition(){
        this.#globalPosition[0] = this.globalMatrix[9],
        this.#globalPosition[1] = this.globalMatrix[10],
        this.#globalPosition[2] = this.globalMatrix[11];
        return this.#globalPosition;

        // return [this.globalMatrix[4], this.globalMatrix[5]];
    }



    set Scale(val){this.scale = val;
        this.update();}
    get Scale(){return this.scale;}

    set Rotation(val){
        this.rotation = val;
        fromEuler(this.quat, ...this.rotation);
        fromQuat(this.rotationMatrix,this.quat);

        this.update();
    }
    get Rotation(){return this.rotation;}

    clone(transform){
        this.position = transform.position.slice();
        this.scale = transform.scale.slice();
        this.rotation = transform.rotation.slice();
        this.quat = transform.quat.slice();
        this.transform.pivot.slice();
    }


    get Matrix(){

        return this.globalMatrix;
    };
    get Matrix4(){

        const mat= this.globalMatrix;
        return [
            mat[0], mat[1], mat[2], 0,
            mat[3], mat[4], mat[5], 0,
            mat[6], mat[7], mat[8], 0,
            mat[9], mat[10], mat[11], 1,
        ]
    };

    get LocalMatrix(){return this.localMatrix;}


    set LocalMatrix(value){

        let i = value.length;
        while(i--) this.localMatrix[i] = value[i];

        Transform3D.set(this, value);
        this.update();
    }
    clear(){
        this.position[0] = this.position[1] = this.position[2] = 0;
        this.pivot[0] = this.pivot[1] = this.pivot[2] = 0;
        this.scale[0] = this.scale[1] = this.scale[2] =  1;

        this.rotation = 0;
        this.q = create$2();

        this.localMatrix = [1,0,0,     0,1,0,      0,0,1,      0,0,0]; //3x4
        this.globalMatrix = [1,0,0,     0,1,0,      0,0,1,      0,0,0]; //3x4
        this.update();

    }
    //https://gamedev.stackexchange.com/questions/61473/combining-rotation-scaling-around-a-pivot-with-translation-into-a-matrix
    // [T]*[+p]*[R]*[S]*[-p]
    update(){ //localUpdate = true

        const localMat = this.getConnection(ConnectionType.inputs, 'localMatrix');
        if(localMat.length){
            this.LocalMatrix = localMat;
        } else { // if(localUpdate)
            const mat = this.localMatrix, rotMat = this.rotationMatrix,
                px = this.pivot[0], py = this.pivot[1], pz = this.pivot[2],
                tx = this.position[0], ty  = this.position[1], tz = this.position[2],
                sx = this.scale[0],  sy = this.scale[1], sz = this.scale[2];

            //[RS] = [R]*[S]
            mat[0] = rotMat[0]*sx;    mat[3] = rotMat[3]*sy;    mat[6] = rotMat[6]*sz;
            mat[1] = rotMat[1]*sx;    mat[4] = rotMat[4]*sy;    mat[7] = rotMat[7]*sz;
            mat[2] = rotMat[2]*sx;    mat[5] = rotMat[5]*sy;    mat[8] = rotMat[8]*sz;

            // [T]*[+p]*[RS]*[-p]
            mat[9] = mat[0]*-px + mat[3]*-py + mat[6]*-pz + px + tx;
            mat[10] = mat[1]*-px + mat[4]*-py + mat[7]*-pz + py + ty;
            mat[11] = mat[2]*-px + mat[5]*-pz + mat[8]*-pz + pz + tz;

        }


        let obj = this.getConnection(ConnectionType.inputs,'object'),
            parent = obj&&obj.Parent&&obj.Parent.transform?obj.Parent:null,
            children = obj&&obj.Children?obj.Children:[];


        if(parent)
            multiply$1(this.globalMatrix,parent.transform.globalMatrix,this.localMatrix);
        else
            copy(this.globalMatrix,this.localMatrix);

        for(let child of children){

            $assert(!(child.Status & common$1.setting.STATUS.creating), {errorType:common$1.error.ERR_TYPE.internalErr,
                msg:`${this.name} child transform update() failed, object is uninitialized`});
            $assert( !(child.status & common$1.setting.STATUS.deleting), {errorType:common$1.error.ERR_TYPE.internalErr,
                msg:`${this.name} child transform update() failed, object is deleted`});

            multiply$1(child.transform.globalMatrix,this.globalMatrix,child.transform.localMatrix);
            child.transform.update(false);
        }

        if(this.#updateCallback)
            this.#updateCallback(this);
    }



    lookAt(position,target, up){
        const tmp = create$5();
        lookAt(tmp,position,target,up,false, 'z');

        this.LocalMatrix = tmp;
    };


    //https://www.gamedev.net/forums/topic/441695-transform-localMatrix-decomposition/

    //R*S
    // R0S0     R2S1
    // R1S0     R3S1
    static set(out,inputMat){
        $assert(inputMat.length == 16 || inputMat.length == 12);
        const mat = inputMat.slice();
        if(inputMat.length == 16)
            fromMat4(mat, inputMat);

        out.position = [mat[9],mat[10],mat[11]];
        out.scale = [
            Math.sqrt(mat[0]*mat[0]+mat[1]*mat[1]+mat[2]*mat[2]),
            Math.sqrt(mat[3]*mat[3]+mat[4]*mat[4]+mat[5]*mat[5]),
            Math.sqrt(mat[6]*mat[6]+mat[7]*mat[7]+mat[8]*mat[8]),
        ];
        out.rotationMatrix[0] = mat[0]/out.scale[0];
        out.rotationMatrix[1] = mat[1]/out.scale[0];
        out.rotationMatrix[2] = mat[2]/out.scale[0];


        out.rotationMatrix[3] = mat[3]/out.scale[1];
        out.rotationMatrix[4] = mat[4]/out.scale[1];
        out.rotationMatrix[5] = mat[5]/out.scale[1];


        out.rotationMatrix[6] = mat[6]/out.scale[2];
        out.rotationMatrix[7] = mat[7]/out.scale[2];
        out.rotationMatrix[8] = mat[8]/out.scale[2];

        fromMat3(out.quat, out.rotationMatrix);

        out.pivot = [0,0,0];
        out.localMatrix = mat.slice();
    }


    static multiply(out, a,  b, mode = 'boundary'){
        const mat = a.Matrix?a.Matrix:a;
        $assert(mat.length == 6 && b && (b.length == 2 || b.length==4||b.length==6));
        $assert(mode == 'boundary' || mode == 'aabb');

        let x = b[0], y = b[1]; b[2];

        if(b.length == 3)
            out[0] = mat[0] * x + mat[3] * y + mat[6] * y + mat[9],
            out[1] = mat[1] * x + mat[4] * y + mat[7] * y + mat[10],
            out[2] = mat[2] * x + mat[5] * y + mat[8] * y + mat[11];
        else if(b.length == 6){//if b is aabb [lowerx, lowery, lowerz, upperx, uppery, upperz]

            const outX = [], outY = [], outZ = [],
                pos = [0,0,0];
            //z=0
            transformMat3d(pos,[b[0],b[1],b[2]], mat);
            outX.push(pos[0]);
            outY.push(pos[1]);
            outZ.push(pos[2]);


            transformMat3d(pos,mode == 'boundary'? [b[0],b[1]+b[4],b[2]]:[b[0],b[4],b[2]], mat);
            outX.push(pos[0]);
            outY.push(pos[1]);
            outZ.push(pos[2]);


            transformMat3d(pos,mode == 'boundary'? [b[0]+b[3],b[1]+b[4],b[2]]:[b[3],b[4],b[2]], mat);
            outX.push(pos[0]);
            outY.push(pos[1]);
            outZ.push(pos[2]);


            transformMat3d(pos,mode == 'boundary'? [b[0]+b[3],b[1],b[2]]:[b[3],b[1],b[2]], mat);
            outX.push(pos[0]);
            outY.push(pos[1]);
            outZ.push(pos[2]);

            //z=z
            transformMat3d(pos,mode == 'boundary'?[b[0],b[1],b[2]+b[5]]:[b[0],b[1],b[5]], mat);
            outX.push(pos[0]);
            outY.push(pos[1]);
            outZ.push(pos[2]);


            transformMat3d(pos,mode == 'boundary'? [b[0],b[1]+b[4],b[2]+b[5]]:[b[0],b[4],b[5]], mat);
            outX.push(pos[0]);
            outY.push(pos[1]);
            outZ.push(pos[2]);


            transformMat3d(pos,mode == 'boundary'? [b[0]+b[3],b[1]+b[4],b[2]+b[5]]:[b[3],b[4],b[5]], mat);
            outX.push(pos[0]);
            outY.push(pos[1]);
            outZ.push(pos[2]);


            transformMat3d(pos,mode == 'boundary'? [b[0]+b[3],b[1],b[2]+b[5]]:[b[3],b[1],b[5]], mat);
            outX.push(pos[0]);
            outY.push(pos[1]);
            outZ.push(pos[2]);


            out[0] = Math.min(...outX);
            out[1] = Math.min(...outY);
            out[2] = Math.min(...outZ);
            out[3] = Math.max(...outX);
            out[4] = Math.max(...outY);
            out[5] = Math.max(...outZ);

            if(mode == 'boundary')
                out[3] -= out[0], out[4] -= out[1],out[5] -= out[2];

        }else if(b.length == 12){
            $assert(out.length == 12);
            multiply$1(out,mat,b);

        }

    };


    static inverse(mat, a){
        $assert(a instanceof Transform3D);

        const rotMat = a.rotationMatrix,
            tx = a.position[0], ty = a.position[1], tz = a.position[2],
            sx = a.scale[0], sy = a.scale[1],  sz = a.scale[2],
            px = a.pivot[0], py = a.pivot[1],  pz = a.pivot[2];

        //([T]*[+p]*[RS]*[-p])^-1 = [p] ([RS]T) [-p] [-T]

        //[RS]T = [ST]*[RT]
        mat[0] = rotMat[0]/sx;    mat[3] = rotMat[1]/sx;  mat[6] = rotMat[2]/sx;
        mat[1] = rotMat[3]/sy;    mat[4] = rotMat[4]/sy;  mat[7] = rotMat[5]/sy;
        mat[2] = rotMat[6]/sz;    mat[5] = rotMat[7]/sz;  mat[8] = rotMat[8]/sz;

        //[-p] [-T]
        const ptInvx = -tx-px, ptInvy = -ty-py, ptInvz = -tz-pz;

        //[p] ([RS]T) [-p] [-T]
        mat[9] = mat[0] * ptInvx + mat[3] * ptInvy + mat[6] * ptInvz + px;
        mat[10] =mat[1] * ptInvx + mat[4] * ptInvy + mat[7] * ptInvz + px;
        mat[11] =mat[2] * ptInvx + mat[5] * ptInvy + mat[8] * ptInvz + px;
    }

    static multiplyInv(out, a,b, mode = 'boundary'){

        const mat = [];
        Transform3D.inverse(mat, a);
        $assert(mat instanceof Array && mat.length == 12);
        $assert(mode == 'boundary' || mode == 'aabb');
        Transform3D.multiply(out, mat, b, mode);
    }
}

class Element3d
    extends implement(Base,IConnection,IElement){


    transform = null;
    status = null;

    graphics = null;



    constructor(name='__test',params={}){
        super(name,params);

        this.initConnection(hierarchyConnection);

        this.transform = new Transform3D(this.name+'-transform');
        this.transform.setConnection(ConnectionType.inputs,'object',this);
        this.status = common$1.setting.BASIC_STATUS.creating|common$1.setting.BASIC_STATUS.clippingBoundary|common$1.setting.BASIC_STATUS.visible;


        const init = this.initialize, del = this.delete;

        this.initialize = async _=>{
            await init.call(this);
            this.status &= ~common$1.setting.BASIC_STATUS.creating;
        };
        this.delete = async _=>{
            $assert(!(this.status & common$1.setting.BASIC_STATUS.deleting), {msg:`${this.FullName} ${this.name} delete twice`});
            // $assert(this.FullName != null);
            this.status |= common$1.setting.BASIC_STATUS.deleting;
            await del.call(this);
            this.status = common$1.setting.BASIC_STATUS.deleted;
        };



    }


    get Status(){
        return super.Status;
    }
    set Status(value){

        this.status = value;
    }

    async initialize(){
        await super.initialize();


        if($isNumber$1(this.params.status)&&(this.params.status &  common$1.setting.STATUS.visible) == 0)
            this.status &= ~common$1.setting.STATUS.visible;

        if(this.params.position) this.transform.Position = this.params.position;


    }


    delete(){

        this.transform.delete();
        this.transform = null;

        this.graphics = null;
        //this.offset = null;
        this.boundary = null;

        this.clearConnection();
        super.delete();

    }


}

class Camera3d extends implement(Element3d,ICamera, IConnection){
    matrix = null;
    projectionMat = null;
    viewMatrix = null;

    get Matrix(){return this.matrix;};

    get ViewMatrix(){return this.viewMatrix;};
    get ProjectionMatrix(){return this.projectionMat;};


    constructor(name='__test',params) {
        super(name,params);
        this.initConnection(cameraConnection);
    };
    delete(){

        this.projectionMat = null;
        this.viewMatrix = null;
    }
    get ViewMatrix4(){

        const mat= this.viewMatrix;
        return [
            mat[0], mat[1], mat[2], 0,
            mat[3], mat[4], mat[5], 0,
            mat[6], mat[7], mat[8], 0,
            mat[9], mat[10], mat[11], 1,
        ]
    };


    update(){

        this.fov = this.params.fov??Math.PI*0.3333;
        this.aspect = this.params.aspect??4/3;//this.width/this.height;
        this.near = this.params.near??0.1;
        this.far = this.params.far??1000;
        this.projectionMat = perspective(this.projectionMat, this.fov, this.aspect, this.near, this.far);
    }

    async initialize(){
        await super.initialize();
        this.matrix = create$5();
        this.projectionMat = create$5();
        this.viewMatrix = create$6();
        this.update();

        // // this.setConnection(ConnectionType.outputs,'localMatrix',this.Matrix);
        // //inv scale
        // this.transform = new Transform3D(this.name+'-transform',{
        //     updateCallback:()=>{
        //         $assert(this.transform.Matrix4.length == 16);
        //         Transform3D.inverse(this.viewMatrix, this.transform);
        //
        // }});
        // this.transform.setConnection(ConnectionType.inputs,'object',this);

        this.transform.UpdateCallback = ()=>{
                $assert(this.transform.Matrix4.length == 16);

                //wrt to camera.Matrix
                //Transform3D.inverse(this.viewMatrix, this.transform);
                invert$1(this.viewMatrix, this.transform.globalMatrix);

        };
    }

    lookAt(position,target, up){
        const tmp = create$5();
        lookAt(tmp,position,target,up);

        this.transform.LocalMatrix = tmp;

    };


}

class CameraVR extends implement(Element3d, IConnection){

    left = null;
    right = null;
    disBetweenEyes = null;
    focusDis = null;
    toeInAdjust = null;
    constructor(name='__test',params) {
        super(name,params);

    };

    async initialize() {
        await super.initialize();
        this.left = new Camera3d('left', this.params);
        this.right = new Camera3d('right', this.params);

        this.left.initialize();
        this.right.initialize();


        await this.appendChild(this.left);
        await this.appendChild(this.right);

        this.disBetweenEyes = this.params.disBetweenEyes??0.11;
        this.focusDis = this.params.focusDis?? 0.35;
        this.toeInAdjust =   (degree2Rad(90)-Math.atan(this.focusDis/(0.5*this.disBetweenEyes)));
        this.setCamDistance(this.disBetweenEyes, this.focusDis);
    }

    setCamDistance = function(disBetweenEyes = 0.07,focusDis = 0.18){
        this.disBetweenEyes = disBetweenEyes;
        this.focusDis = focusDis;
        this.toeInAdjust = focusDis==0?0:
            (degree2Rad(90)-Math.atan(focusDis/(0.5*disBetweenEyes)));
        this.left.transform.Position = [-0.5*disBetweenEyes,0,0];
        this.left.transform.Rotation = [0,-this.toeInAdjust,0];
        this.right.transform.Position  = [0.5*disBetweenEyes,0,0];
        this.right.transform.Rotation = [0,this.toeInAdjust,0];
    }


    delete(){

        this.left = null;
        this.right = null;
        this.disBetweenEyes = null;
        this.focusDis = null;
        this.toeInAdjust = null;
    }


    lookAt(position,target, up){
        const tmp = create$5();
        lookAt(tmp,position,target,up);

        this.transform.LocalMatrix = tmp;

    };


}

class Shader{

    source = null;
    shaders = null;

    constructor(name,source) {
        this.name = name;
        this.source = source;
    }
    delete(){
        this.source = null;
        this.shaders = null;
    }

    initialize({gl} = GLFramework.Graphics){
        const shaders = this.preprocess(this.source);
        this.create(gl,shaders);
    }

    create(gl,shaders){
        this.fragment = gl.createShader(gl.FRAGMENT_SHADER);
        this.vertex = gl.createShader(gl.VERTEX_SHADER);
        this.fragSrc = shaders.fragment;
        this.vertSrc = shaders.vertex;
        this.compile(gl);
    }
    clone(){
        return new Shader(this.name, source, {
            vertex: this.vertex.source,
            fragment: this.fragment.source,
        });
    }



    compile(gl,params){
        var params = params || {};
        var directives = [
            '#version 100',
            //'#extension GL_EXT_draw_buffers:require',
            'precision mediump float;'
        ];

        for(var i in (params.defines || [])){
            directives.push('#define ' + params.defines[i]);
        }
        directives = directives.join('\n') + '\n';

        var shaders = [this.fragment, this.vertex];
        var src = [this.fragSrc,this.vertSrc];
        for(var i in shaders){

            var shader = shaders[i];
            var source = src[i];
            for(var name in params.values || {}){
                var re = new RegExp('#define ' + name + ' \\w+', 'm');
                source = source.replace(re, '#define ' + name + ' ' + params.values[name]);
            }
            gl.shaderSource(shader, directives + source);
            gl.compileShader(shader);
            if(!gl.getShaderParameter(shader, gl.COMPILE_STATUS)){
                console.log({
                    type: 'shader compile',
                    error: gl.getShaderInfoLog(shader),
                    name: this.name
                });
                throw new Error('shader compile failed');
            }
        }
    };
}

window.__textures = {};
class Texture2D {
    texture = null;
    name = null;
    params = null;
    generateMipMap = null;
    path = null;
    image = null;
    textureSetting = null;
    type = "2DTexture";
    constructor(name, params={}){
        this.name = name;
        this.params = params;
    }
    delete() {
        delete __textures[this.name];
        this.texture = null;
        this.name = null;
        this.generateMipMap = null;
        this.type = null;
        this.image = null;
        this.textureSetting = null;
    }



    initialize(graphics = GLFramework.Graphics) {//type,width,height


        this.generateMipMap = this.params.generateMipMap??false;
        this.path = this.params.path??null;
        $assert(this.params.image instanceof Image || this.params.image instanceof HTMLCanvasElement);
        this.image = this.params.image;

        this.width = this.params.width??512;
        this.height = this.params.height??512;
        this.textureSetting = this.params.textureSetting??{
            wrapS:'CLAMP_TO_EDGE',
            wrapT:'CLAMP_TO_EDGE',
            scaleDown:'NEAREST',
            scaleUp:'NEAREST'
        };


        const gl = graphics.gl;
        __textures[this.name] = {img:this.image, name:this.name};


        this.texture = gl.createTexture();
        this.setTextureParams(graphics);

    };


    //https://open.gl/textures
    setTextureParams ({gl} = GLFramework.Graphics) {
        $assert(this.texture);
        gl.bindTexture(gl.TEXTURE_2D, this.texture);
        gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);


        //WARPPing
        //doesnt work with non-power of 2
        //gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.REPEAT);
        //gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.REPEAT);

        //work with non-power of 2
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl[this.textureSetting.wrapS]);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl[this.textureSetting.wrapT]);



        if (this.generateMipMap)
            gl.generateMipmap(gl.TEXTURE_2D);

        //FILTERing
        //gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
        //gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_NEAREST);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl[this.textureSetting.scaleDown]);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl[this.textureSetting.scaleUp]);

        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, this.image);



        gl.bindTexture(gl.TEXTURE_2D, null);
    };

}

class Texture3D extends implement(Texture2D){

    type = "3DTexture";
    constructor(name, params={}) {
        super(name, params);
    }

    //https://open.gl/textures
    //https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/texImage2D
    //TODO: need optimize to webGL2
    setTextureParams ({gl} = GLFramework.Graphics) {
        gl.bindTexture(gl.TEXTURE_CUBE_MAP, this.texture);
        gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);
        gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
        gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MAG_FILTER, gl.NEAREST);


        const canvas = document.createElement("canvas");
        canvas.width = 512;
        canvas.height = 512;
        const ctx = canvas.getContext("2d");


        ctx.drawImage(this.image, 1024, 512, 512, 512, 0, 0, 512, 512);
        gl.texImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, canvas);

        ctx.drawImage(this.image, 0, 512, 512, 512, 0, 0, 512, 512);
        gl.texImage2D(gl.TEXTURE_CUBE_MAP_NEGATIVE_X, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, canvas);

        ctx.drawImage(this.image, 512, 1024, 512, 512, 0, 0, 512, 512);
        gl.texImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_Y, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, canvas);

        ctx.drawImage(this.image, 512, 0, 512, 512, 0, 0, 512, 512);
        gl.texImage2D(gl.TEXTURE_CUBE_MAP_NEGATIVE_Y, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, canvas);

        ctx.drawImage(this.image, 512, 512, 512, 512, 0, 0, 512, 512);
        gl.texImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_Z, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, canvas);


        ctx.drawImage(this.image, 1536, 512, 512, 512, 0, 0, 512, 512);
        gl.texImage2D(gl.TEXTURE_CUBE_MAP_NEGATIVE_Z, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, canvas);

        gl.bindTexture(gl.TEXTURE_CUBE_MAP, null);


    };

}

window.__materials = {};
class Material{
    dataLocation = {attributes:{},uniforms:{}};
    textures = {};
    gl = null;
    attributes = {};
    uniforms = {};
    shader = null;
    shaderProgram = null;
    constructor(name,params) {
        this.shader = params.shader??null;

    }
    set Shader(sh){this.shader = sh;}
    initialize({gl}=GLFramework.Graphics){

        this.vertex = this.shader.vertex;
        this.fragment = this.shader.fragment;

        this.attributes = JSON.parse(JSON.stringify(this.shader.attributes));
        this.uniforms = JSON.parse(JSON.stringify(this.shader.uniforms));



        this.shaderProgram = gl.createProgram();
        gl.attachShader(this.shaderProgram, this.vertex);
        gl.attachShader(this.shaderProgram, this.fragment);

        gl.linkProgram(this.shaderProgram);

        if (!gl.getProgramParameter(this.shaderProgram, gl.LINK_STATUS)) {
            alert("Could not initialise shaders");
        }

        for(const attr in this.attributes){
            this.dataLocation.attributes[attr] = gl.getAttribLocation(this.shaderProgram,attr);
        }

        for(const name in this.uniforms)
            this.dataLocation.uniforms[name] = gl.getUniformLocation(this.shaderProgram,name);

    }
    delete(){
        this.dataLocation =null;
        this.textures=null;
        this.gl=null;

        this.shader = null;
        this.shaderProgram = null;
    }

    setTexture(key, texture){
        $assert(texture instanceof Texture2D);
        $assert(this.uniforms[key]);
        this.textures[key] = texture;
    };

    drawHandler = null;
    draw({gl} = GLFramework.Graphics, cam, transform){

        gl.useProgram(this.shaderProgram);

        if(this.drawHandler)
            this.drawHandler();
        else {


            gl.bindTexture(gl.TEXTURE_2D, null);
            gl.bindTexture(gl.TEXTURE_CUBE_MAP, null);
            for(const [key,value] of Object.entries(this.textures)){
                const texIndex = this.uniforms[key].value;

                gl.activeTexture(gl[`TEXTURE${texIndex}`]);
                let TYPE;
                if(value.type == "2DTexture")
                    TYPE = gl.TEXTURE_2D;
                else if(value.type == "3DTexture")
                    TYPE = gl.TEXTURE_CUBE_MAP;
                else
                    $assert(false);
                gl.bindTexture(TYPE, value.texture);
            }

        }


        for(var name in this.uniforms){
            const data =this.uniforms[name];

            if(data.type=="bool" || data.type=="int" || data.type == 'sampler2D' || data.type == 'samplerCube')
                gl.uniform1i(this.dataLocation.uniforms[name], data.value);
            else if(data.type=="float")
                gl.uniform1f(this.dataLocation.uniforms[name], data.value);
            else if(data.type=="vec2")
                gl.uniform2f(this.dataLocation.uniforms[name], data.value[0],data.value[1]);
            else if(data.type=="vec3")
                gl.uniform3f(this.dataLocation.uniforms[name], data.value[0], data.value[1],data.value[2]);
            else if(data.type=="vec4")
                gl.uniform4f(this.dataLocation.uniforms[name], data.value[0], data.value[1],data.value[2],data.value[3]);
        }


        //camera
        if(this.dataLocation.uniforms["uPMatrix"]&&cam)
            gl.uniformMatrix4fv(this.dataLocation.uniforms["uPMatrix"], false, cam.projectionMat);

        if(this.dataLocation.uniforms["uVMatrix"]&&cam)
            gl.uniformMatrix4fv(this.dataLocation.uniforms["uVMatrix"], false, cam.ViewMatrix4);

        if(this.dataLocation.uniforms["uMMatrix"])
            gl.uniformMatrix4fv(this.dataLocation.uniforms["uMMatrix"], false, transform.Matrix4);



        if(this.dataLocation.uniforms["uNMatrix"]){
            //transform
            //http://stackoverflow.com/questions/5255806/how-to-calculate-tangent-and-binormal
            //http://www.lighthouse3d.com/tutorials/glsl-tutorial/the-normal-matrix/

            // mat4.multiply(tmpMat4, cam.GetViewMatrix(), this.worldMatrix);
            // mat4.invert(tmpMat4,tmpMat4);
            // mat3.fromMat4(tmpMat3,tmpMat4);
            // mat3.transpose(tmpMat3,tmpMat3);

            //((camMat * worldMat)^-1)^T
            //(worldMat^-1 * camMat^T)^T
            //camMat * ((RS)^-1)^T
            //camMat * R * S^-1
            const tmpMat3 = create$7(),
                viewMat3 = create$7();
            fromMat4$1(viewMat3,cam.viewMatrix);
            multiply$2(tmpMat3, viewMat3, transform.rotationMatrix);

            let [sx, sy, sz]  = transform.scale;
            const sxInv = sx==0?Math.maxInt:1/sx,
                syInv = sy==0?Math.maxInt:1/sy,
                szInv = sz==0?Math.maxInt:1/sz;
            tmpMat3[0]*=sxInv;
            tmpMat3[4]*=syInv;
            tmpMat3[8]*=szInv;

            gl.uniformMatrix3fv(this.dataLocation.uniforms["uNMatrix"], false, tmpMat3);
        }
    };

}

function quad(width, height, z = 0){

    width = width||1;
    height = height||1;

    const data = {};

    data.vertice = [-0.5*width,0.5*height,z,
        -0.5*width,-0.5*height,z,
        0.5*width,0.5*height,z,
        0.5*width,-0.5*height,z];
    data.uvs =[0.0, 1.0,
        0.0, 0.0,
        1.0, 1.0,
        1.0, 0.0];

    data.indice = [0,1,2,1,3,2];
    data.normals = [0,0,1,
        0,0,1,
        0,0,1,
        0,0,1];

    return data;
}

function obj2JSON (text){
    var vertexArray = [],
        normalArray = [],
        textureArray = [],
        indexArray = [],mats = [],
        activeIndex = -1;
    var
        isLargeModel = false;

    var vertex = [ ];
    var normal = [ ];
    var texture = [ ];
    var facemap = {};
    var min=[0,0,0],max=[0,0,0];
    var index = 0;
    var refreshArray = function(){
        //if(refreshFaceMap)
        facemap = {};
        indexArray.push([]);normalArray.push([]);textureArray.push([]);vertexArray.push([]);
        activeIndex++;
        index =0;
    };
    var setPointData = function(i){
        if(activeIndex==-1)
            activeIndex =0;

        if (!(array[i] in facemap)) {//check if it is new entry
            var f = array[i].split("/");
            var vtx, nor, tex;

            if (f.length == 1) {
                vtx = parseInt(f[0]) - 1;
                nor = vtx;
                tex = vtx;
            }
            else if (f.length = 3) {
                vtx = parseInt(f[0]) - 1;
                tex = parseInt(f[1]) - 1;
                nor = parseInt(f[2]) - 1;
            }
            else {
                return null;
            }



            // do the vertices
            var x = 0, y=0,z=0;
            if (vtx * 3 + 2 < vertex.length) {
                x = vertex[vtx*3];
                y = vertex[vtx*3+1];
                z = vertex[vtx*3+2];
            }else {
                console.log("Error in parsing Obj file");

            }
            try{
                vertexArray[activeIndex].push(x);
                vertexArray[activeIndex].push(y);
                vertexArray[activeIndex].push(z);
            }catch(e){

                console.log('aa');
            }

            if(x<min[0]) min[0] = x;
            else if(x>max[0]) max[0]=x;

            if(y<min[1]) min[1] = y;
            else if(y>max[1]) max[1]=y;

            if(z<min[2]) min[2] = z;
            else if(z>max[2]) max[2]=z;

            // do the textures
            x = 0;
            if (tex * 2 + 1 < texture.length) {
                x = texture[tex*2];
                y = texture[tex*2+1];
            }
            textureArray[activeIndex].push(x);
            textureArray[activeIndex].push(y);

            // do the normals
            x = 0;
            if (nor * 3 + 2 < normal.length) {
                x = normal[nor*3];
                y = normal[nor*3+1];
                z = normal[nor*3+2];
            }
            normalArray[activeIndex].push(x);
            normalArray[activeIndex].push(y);
            normalArray[activeIndex].push(z);
            facemap[array[i]] = index++;

        }
        indexArray[activeIndex].push(facemap[array[i]]);
    };


    var lines = text.split("\n"),oldArrayHeader='';
    for (var lineIndex in lines) {
        var line = lines[lineIndex].replace(/[ \t]+/g, " ").replace(/\s\s*$/, "");

        // ignore comments
        if (line[0] == "#")
            continue;

        var array = line.split(" ");
        if (array[0] == "v") {
            // vertex
            vertex.push(parseFloat(array[1]));
            vertex.push(parseFloat(array[2]));
            vertex.push(parseFloat(array[3]));
        }
        else if (array[0] == "vt") {
            // normal
            texture.push(parseFloat(array[1]));
            texture.push(parseFloat(array[2]));
        }
        else if (array[0] == "vn") {
            // normal
            normal.push(parseFloat(array[1]));
            normal.push(parseFloat(array[2]));
            normal.push(parseFloat(array[3]));
        }
        else if (array[0] == "usemtl") {//having mtl tag or no tag (using last mat)
            mats.push(array[1]);
            refreshArray();
        }else if((oldArrayHeader=='vn'&&array[0]=='f')){

            mats.push(mats[mats.length-1]);
        }
        else if (array[0] == "f") {

            if(vertexArray.length==0)
                refreshArray();

            // face
            if (array.length > 5) {
                console.log("*** Error: face '"+line+"' not handled");
                continue;
            }else if(array.length==4){//f point1 point2 point3

                isLargeModel =
                    index+3>65534? 1:0;	//0-65534 totally 65535
                //indice can be devided by 3
                if(isLargeModel){
                    mats.push(mats[mats.length-1]);
                    refreshArray();
                }

                setPointData(1);
                setPointData(2);
                setPointData(3);
            }else if(array.length==5){//f point1 point2 point3 point4

                isLargeModel =
                    index + 4>65534? 1:0;	//0-65534 totally 65535
                                             //indice can be devided by 3
                if(isLargeModel){
                    mats.push(mats[mats.length-1]);
                    refreshArray();
                }

                setPointData(1);
                setPointData(2);
                setPointData(4);

                setPointData(2);
                setPointData(3);
                setPointData(4);
            }

        }

        oldArrayHeader = array[0];
    }//end of loop

    const result = {};
    result["vertice"] = vertexArray;
    result["normals"] = normalArray;
    result["uvs"] = textureArray;
    result["indice"] = indexArray;
    result["min"] = min;result["max"] = max;
    result["mats"] = mats;
    return result;

}

class Shape {
    static RENDERSTATE = {triangle:1,line:2};
    verticeBuffer = null;
    uvsBuffer = null;
    normalsBuffer = null;
    indiceBuffer = null;

    vertice = null;
    uvs = null;
    normals = null;
    indice = null;

    constructor(name, params={}) {
        this.data = params.data??{vertice:[],indice:[],normals:[],uvs:[]};
        this.state = params.state?? Shape.RENDERSTATE.triangle;
        this.shapeSetting = params.shapeSetting??{
            type:'STATIC_DRAW',
        };

    };

    initialize({gl} = GLFramework.Graphics) {


        this.verticeBuffer = gl.createBuffer();
        this.uvsBuffer = gl.createBuffer();
        this.normalsBuffer = gl.createBuffer();
        this.indiceBuffer = gl.createBuffer();
        this.Data = this.data;
        this.update({gl});
    };

    set Data(data){
        this.vertice = new Float32Array(data.vertice);
        if(data.indice)
            this.indice = new Uint16Array(data.indice);
        if(data.normals)
            this.normals = new Float32Array(data.normals);
        if(data.uvs)
            this.uvs = new Float32Array(data.uvs);

        // if(data.max&&data.min){
        //     this.max = data.max;
        //     this.min = data.min;
        //
        //     this.boundingBox = new BoundingBox(this.name+'BBox',this.min,this.max);
        // }
    };

    update({gl} = GLFramework.Graphics) {
        gl.bindBuffer(gl.ARRAY_BUFFER, this.verticeBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, this.vertice, gl[this.shapeSetting.type]);
        this.verticeBuffer.itemSize = 3;
        this.verticeBuffer.numItems = this.vertice.length / 3;

        if (this.normals) {
            gl.bindBuffer(gl.ARRAY_BUFFER, this.normalsBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, this.normals, gl[this.shapeSetting.type]);
            this.normalsBuffer.itemSize = 3;
            this.normalsBuffer.numItems = this.normals.length / 3;
        }
        if (this.indice) {
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indiceBuffer);
            gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, this.indice, gl[this.shapeSetting.type]);
            this.indiceBuffer.itemSize = 1;
            this.indiceBuffer.numItems = this.indice.length;
        }

        if (this.uvs) {
            gl.bindBuffer(gl.ARRAY_BUFFER, this.uvsBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, this.uvs, gl[this.shapeSetting.type]);
            this.uvsBuffer.itemSize = 2;
            this.uvsBuffer.numItems = this.uvs.length / 2;
        }
    }



    draw(graphics, material) {

        $assert(this.vertice);
        const gl = graphics.gl;


        if (this.shapeSetting.type == 'DYNAMIC_DRAW')
            this.update(graphics);


        for(const [key,value] of Object.entries(material.dataLocation.attributes)){
            gl.enableVertexAttribArray(value);
            const keyBufferName = `${key}Buffer`;
            $assert(this[keyBufferName]);
            gl.bindBuffer(gl.ARRAY_BUFFER, this[keyBufferName]);
            gl.vertexAttribPointer(value, this[keyBufferName].itemSize, gl.FLOAT, false, 0, 0);
        }


        if (this.state == Shape.RENDERSTATE.triangle) {
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indiceBuffer);
            gl.drawElements(gl.TRIANGLES, this.indiceBuffer.numItems, gl.UNSIGNED_SHORT, 0);
        }

    };

}
//Shape = Shape;

const setting = {
    vertex:
        `attribute vec3 vertice;
        attribute vec2 uvs;
        attribute vec3 normals;
    
        uniform bool uFlipY;
    
        uniform mat4 uMMatrix;
        uniform mat4 uVMatrix;
        uniform mat4 uPMatrix;
        uniform mat3 uNMatrix;
    
        varying vec2 vTextureCoord;
        varying vec3 vTransformedNormal;
        varying vec4 vPosition;
        
        
        void main(void) {
            vPosition = uVMatrix*uMMatrix * vec4(vertice, 1.0);
            gl_Position = uPMatrix * vPosition;
            
            
            vTextureCoord = uvs;
            if(uFlipY)	{
                    vTextureCoord.t = 1.0 - vTextureCoord.t;
            }
    
            vTransformedNormal = uNMatrix * normals;
        }`,

    fragment:
        `precision mediump float;
    
        varying vec2 vTextureCoord;
        varying vec3 vTransformedNormal;
        varying vec4 vPosition;
    
        uniform sampler2D uDiffColTex;
        uniform sampler2D uAlphaTex;
    
    
        uniform float uAlphaMultiplier;
        uniform int uSpriteIndex;
        uniform int uSpriteN;
    
        void main(void) {
            
            vec4 fragmentColor,alphaColor;
    
            if(uSpriteIndex >=0 ){
                float delta = 1.0/float(uSpriteN);
                int rowIndex, colIndex;
    
                rowIndex = uSpriteIndex/uSpriteN;
                colIndex = uSpriteIndex - rowIndex*uSpriteN;
                rowIndex = uSpriteN-rowIndex-1;
    
                fragmentColor = texture2D(uDiffColTex, vec2((float(colIndex)+vTextureCoord.s)*delta,
                                                           (float(rowIndex)+vTextureCoord.t)*delta));
                alphaColor = texture2D(uAlphaTex, vec2((float(colIndex)+vTextureCoord.s)*delta,
                                                         (float(rowIndex)+vTextureCoord.t)*delta));
            }else{
                fragmentColor = texture2D(uDiffColTex, vec2(vTextureCoord.s,vTextureCoord.t));
                alphaColor = texture2D(uAlphaTex, vec2(vTextureCoord.s,vTextureCoord.t));
            }
    
            gl_FragColor = vec4(fragmentColor.rgb*alphaColor.r, alphaColor.r);
            gl_FragColor = vec4(fragmentColor.rgb, 1.0);
    //         gl_FragColor = vec4(1.0,0.0,0.0,1.0);
        }`,
    init: {
        uFlipY: 0,
        uAlphaMultiplier: 1.0,

        uSpriteIndex: -1,
        uSpriteN: 7,

        uDiffColTex: 0,
        uAlphaTex: 2
    }
};

console.log(`Fragment shader source: ${setting}`);
const COS_PREFIX = 'https://keanu-engine-1302931958.cos.ap-beijing.myqcloud.com/public';

function loadObj(){

    return new Promise(resolve=>{
            Promise.all([
                fetch(COS_PREFIX+"/keanu3d-webgl/shaders/flat.shader").then(resp => resp.text()),
                fetch(COS_PREFIX+"/keanu3d-webgl/Lao3D/lady/3.jpg").then(resp => resp.blob()).then(blob2Img),
                fetch(COS_PREFIX+"/keanu3d-webgl/Lao3D/lady/lady.obj").then(resp => resp.text()),
            ]).then(([shaderTxt, image, objModel])=>{

                const     transform = new Transform3D();
                const shader = new Shader('flat', shaderTxt);
                shader.initialize(GLFramework.Graphics);
                const material = new Material("quad",
                    {shader});
                material.initialize(GLFramework.Graphics);

                const tex = new Texture2D('lady',{image});
                tex.initialize(GLFramework.Graphics);
                material.setTexture('uDiffColTex',tex);
                // gl.enable(gl.CULL_FACE);
                // gl.cullFace(gl.FRONT_AND_BACK);

                const shapeData = obj2JSON(objModel),shapes=[];

                for(let i in shapeData.indice){
                    const data = {
                            indice:shapeData.indice[i],
                            vertice:shapeData.vertice[i],
                            uvs:shapeData.uvs[i],
                            normals:shapeData.normals[i]
                        },
                        shape = new Shape('lady',{data});
                    shape.initialize(GLFramework.Graphics);
                    shapes.push(shape);
                }
                resolve({shapes, transform, material});
            });
    });
}


async function testObj(cam){
    const {shapes, transform, material} = await loadObj();

    let rotY = 0;
    function draw(){

        const {gl} = GLFramework.Graphics;
        gl.clearColor(0,0,0,1);
        gl.clearDepth(1);
        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
        gl.enable(gl.DEPTH_TEST);

        transform.Rotation = [0,rotY+=0.8,0];
        transform.Position = [0,0,10];

        material.draw(GLFramework.Graphics, cam, transform);
        for(const shape of shapes)
            shape.draw(GLFramework.Graphics, material);

        requestAnimationFrame(draw);
    }
    draw();

}

function genQuadEnv(){


    return Promise.all([
        fetch(COS_PREFIX+"/keanu3d-webgl/shaders/quadEnv.shader").then(resp => resp.text()),
        fetch(COS_PREFIX+"/keanu3d-webgl/Env/skybox_texture.jpg").then(resp => resp.blob()).then(blob2Img),
    ]).then(([shaderTxt,image])=> {

        const shader = new Shader('quadEnv', shaderTxt);
        shader.initialize(GLFramework.Graphics);
        const material = new Material("quadEnv",
            {shader});
        material.initialize(GLFramework.Graphics);


        const tex = new Texture3D('env',{image});
        tex.initialize(GLFramework.Graphics);
        material.setTexture('uEnvTex',tex);


        //quad
        const shape = new Shape('quad', {data: quad(2, 2, 0)});
        shape.initialize(GLFramework.Graphics);

        return Promise.resolve({shape,material});
    });

}

function genEditorsSprite(){
    return Promise.all([
        fetch(COS_PREFIX+"/keanu3d-webgl/shaders/sprite.shader").then(resp => resp.text()),
    ]).then(([shaderTxt])=> {

        const transforms = [], shapes = [], materials = [], textures = [];

        for(let i=0;i<2;i++)
            for(const editor of Keanu.editors.array){
                const transform = new Transform3D();
                const shader = new Shader('quad', shaderTxt);
                shader.initialize(GLFramework.Graphics);
                const material = new Material("quad",
                   {shader});
                material.initialize(GLFramework.Graphics);

                const canvas = editor.CanvasDiv,
                    tex = new Texture2D('lady',{image:canvas});
                tex.initialize(GLFramework.Graphics);
                material.setTexture('uDiffColTex',tex);


                //quad
                const shape = new Shape('quad', {data: quad(10, 10, 0)});
                shape.initialize(GLFramework.Graphics);

                textures.push(tex);
                transforms.push(transform);
                shapes.push(shape);
                materials.push(material);
            }

        for(let i =0; i<transforms.length;i++){
            const delta = degree2Rad(360/transforms.length),
                radius = 15,
                x = radius*Math.cos(delta*i),
                z = radius*Math.sin(delta*i);
            transforms[i].lookAt([x,0,z], [0,0,0], [0,1,0]);
        }

        return Promise.resolve({textures,transforms,shapes,materials});


    });
}

function drawEditors(cam,env,editorSprite,girl){
    const {gl} = GLFramework.Graphics;


    gl.clearColor(0,0,0,1);
    gl.clearDepth(1);
    gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);


    if(cam instanceof CameraVR){

        gl.viewport(0, 0, gl.viewportWidth * 0.5, gl.viewportHeight);
        _drawEditors(gl,cam.left,env,editorSprite);


        gl.viewport(gl.viewportWidth * 0.5, 0, gl.viewportWidth * 0.5, gl.viewportHeight);
        _drawEditors(gl,cam.right,env,editorSprite);

    }else
        _drawEditors(gl,cam,env,editorSprite,girl);

    requestAnimationFrame(_=>drawEditors(cam,env,editorSprite,girl));
}

let rotY = 0;
function _drawEditors(gl, cam, env, editorSprite,girl=null){

    const {textures,transforms,shapes, materials} = editorSprite;
    gl.disable(gl.DEPTH_TEST);
    env.material.draw(GLFramework.Graphics, cam, null);
    env.shape.draw(GLFramework.Graphics, env.material);


    gl.enable(gl.DEPTH_TEST);
    for(let i=0;i<shapes.length;i++){
        const   transform = transforms[i],
            shape = shapes[i],
            material = materials[i],
            texture = textures[i];

        texture.setTextureParams();

        material.setTexture('uDiffColTex',texture);
        material.draw(GLFramework.Graphics, cam, transform);
        shape.draw(GLFramework.Graphics, material);
    }

    if(girl){

        girl.transform.Rotation = [0,rotY+=0.8,0];
        girl.transform.Position = [8,0,10];

        girl.material.draw(GLFramework.Graphics, cam, girl.transform);
        for(const shape of girl.shapes)
            shape.draw(GLFramework.Graphics, girl.material);
    }
}

async function testEditor(cam){

    // await delay(2000);

    const girl = await loadObj(),
        editorSprite =  await genEditorsSprite(),//{textures,transforms,shapes, materials}
        env = await genQuadEnv();

    drawEditors(cam, env,editorSprite,girl);
}
function permission () {

    const done =btn=>{
        document.body.removeChild(btn);
        for(const win of Keanu.editors.array)
            win.style['top'] = '-200%';

    };

    const btn = document.createElement('button');
    btn.style['width'] = '200px';
    btn.style['height'] = '100px';
    btn.style['position'] = 'absolute';
    btn.style['bottom'] = '1px';

    document.body.appendChild(btn);


    return new Promise(resolve=>{
        if(typeof DeviceMotionEvent != 'undefined'&&DeviceMotionEvent.requestPermission)
            btn.addEventListener( "touchend", _=>{
                console.log('asdfasdfasdfasdfasdf');
                // debugger;
                DeviceMotionEvent.requestPermission()
                    .then( response => {
                        // (optional) Do something after API prompt dismissed.
                        if ( response == "granted" ){
                            done(btn);
                            return resolve();
                        }
                    })
                    .catch( console.error );
            } );
        else {
            done(btn);
            return resolve();
        }
    })



}

// https://developer.mozilla.org/en-US/docs/Web/API/Device_orientationevents/Orientation_and_motion_data_explained

//alpha     0 (inclusive) to 360 (exclusive)
//beta  -180 (inclusive) to 180 (exclusive)
//gamma  -90 (inclusive) to 90 (exclusive)

function accMeter(cam, mode = 'landscape', browser = 'chrome' ){
    const originCam = [0,0,0],  radiusCam = 10;
    window.addEventListener("deviceorientation", function(event) {

        let yaw = event.alpha;
        if (browser == "chrome")
            yaw = event.gamma> 0? yaw+180:yaw;
        else
            yaw += 180;


        let target = [originCam[0] + radiusCam * Math.sin(degree2Rad(yaw)),
            0,
            originCam[2] + radiusCam * Math.cos(degree2Rad(yaw)),];


        let pitch = event.gamma;
        if (browser == "chrome"){
            pitch = pitch>0? 90-pitch : pitch;
            pitch = pitch<0? -pitch-90 : pitch;
            pitch = pitch < -90 ? -90 : pitch;
            pitch = pitch > 90 ? 90 : pitch;

        }else {
            pitch *= -1;
            pitch = pitch < 0 ? 0 : pitch;
            pitch = pitch > 180 ? 180 : pitch;
            pitch -= 90;
        }
        target[1] += radiusCam*Math.sin(degree2Rad(pitch));

        cam.lookAt(originCam,target,[0,1,0]);

        console.log(event.absolute,`${parseInt(event.alpha)}, ${parseInt(pitch)}, ${parseInt(yaw)}`);

    }, true);
}

async function test3D(width = document.body.clientWidth, height= document.body.clientHeight){


    const glCanvas = document.createElement("canvas");

    glCanvas.width = width, glCanvas.height = height;
    document.body.appendChild(glCanvas);
    window.GLFramework = new GLFramework(glCanvas);

    const cam = new Camera3d('cam',{aspect:glCanvas.width/glCanvas.height});
    cam.initialize();

    cam.transform.Position = [0,0,20];

    testObj(cam);
    // testSprite(cam);
    // testQuadEnv(cam);
    //testAccMeter(cam);

}

async function testVR(width = document.body.clientWidth, height= document.body.clientHeight){

    await permission();


    const glCanvas = document.createElement("canvas");


    glCanvas.style['position'] = 'absolute';
    glCanvas.style['transform-origin'] = 'top left';
    {
        glCanvas.width = height;
        glCanvas.height = width;
        glCanvas.style['transform'] = `translate(${glCanvas.height}px,0) rotate(90deg)`;
    }


    document.body.appendChild(glCanvas);
    window.GLFramework = new GLFramework(glCanvas);

    let cam;
    if (window.config['glasses']){
        cam = new CameraVR('cam',{aspect:0.5*glCanvas.width/glCanvas.height});
        cam.initialize();
        debugger;
        cam.transform.Position = [0,0,15];

    }else {
        cam = new Camera3d('cam',{aspect:glCanvas.width/glCanvas.height});
        cam.initialize();
        cam.transform.Position = [0,0,15];
    }

    accMeter(cam);
    testEditor(cam);
}

/**
 * Draws a rounded rectangle using the current state of the canvas.
 * If you omit the last three params, it will draw a rectangle
 * outline with a 5 pixel border radius
 * @param {CanvasRenderingContext2D} ctx
 * @param {Number} x The top left x coordinate
 * @param {Number} y The top left y coordinate
 * @param {Number} width The width of the rectangle
 * @param {Number} height The height of the rectangle
 * @param {Number} [radius = 5] The corner radius; It can also be an object
 *                 to specify different radii for corners
 * @param {Number} [radius.tl = 0] Top left
 * @param {Number} [radius.tr = 0] Top right
 * @param {Number} [radius.br = 0] Bottom right
 * @param {Number} [radius.bl = 0] Bottom left
 * @param {Boolean} [fill = false] Whether to fill the rectangle.
 * @param {Boolean} [stroke = true] Whether to stroke the rectangle.
 */
function roundRect(
    ctx,
    x,
    y,
    width,
    height,
    radius = 5,
    fill = false,
    stroke = true
) {
    if (typeof radius === 'number') {
        radius = {tl: radius, tr: radius, br: radius, bl: radius};
    } else {
        radius = {...{tl: 0, tr: 0, br: 0, bl: 0}, ...radius};
    }
    ctx.beginPath();
    ctx.moveTo(x + radius.tl, y);
    ctx.lineTo(x + width - radius.tr, y);
    ctx.quadraticCurveTo(x + width, y, x + width, y + radius.tr);
    ctx.lineTo(x + width, y + height - radius.br);
    ctx.quadraticCurveTo(x + width, y + height, x + width - radius.br, y + height);
    ctx.lineTo(x + radius.bl, y + height);
    ctx.quadraticCurveTo(x, y + height, x, y + height - radius.bl);
    ctx.lineTo(x, y + radius.tl);
    ctx.quadraticCurveTo(x, y, x + radius.tl, y);
    ctx.closePath();
    if (fill) {
        ctx.fill();
    }
    if (stroke) {
        ctx.stroke();
    }
}



function strokeOutline(ctx, width,height,strokeColor,lineWidth){

    //stroke outline
    ctx.beginPath();
    ctx.moveTo(0,0);
    ctx.lineTo(width,0);
    ctx.lineTo(width,height);
    ctx.lineTo(0,height);
    ctx.closePath();
    ctx.strokeStyle = strokeColor;
    ctx.lineWidth = lineWidth;
    ctx.stroke();



}

const ACTIVE_MASK = common$1.setting.CTRL_STATUS.active,
    VISIBLE_MASK = common$1.setting.BASIC_STATUS.visible,
    LAYOUTABLE_MASK = common$1.setting.UI_STATUS.layoutable,
    DELETING_MASK = common$1.setting.BASIC_STATUS.deleting,
    CREATING_MASK = common$1.setting.BASIC_STATUS.creating;

const
    AND_MASKS = [ACTIVE_MASK, VISIBLE_MASK, LAYOUTABLE_MASK],
    OR_MASKS = [DELETING_MASK,CREATING_MASK];


function _applyMasks(obj,hierachyList){
    let status = obj.Status;
    for(const mask of AND_MASKS){
        const  isCurMaskActive = hierachyList
            .reduce((acc, curObj) =>
                    acc &&= checkStatus$1(curObj.Status, mask),
                true);

        if(isCurMaskActive === false)
            status &= ~mask;
    }
    for(const mask of OR_MASKS){
        const  isCurMaskActive = hierachyList
            .reduce((acc, curObj) =>
                    acc ||= checkStatus$1(curObj.Status, mask),
                false);

        if(isCurMaskActive === true)
            status |= mask;
    }


    return status;
}
//ITransform2D
class Element2d extends implement(Base,IConnection,IElement){


    transform = null;
    status = null;

    ctx = null;



    constructor(name='__test',params={}){
        super(name,params);

        this.initConnection(hierarchyConnection);

        this.transform = new Transform2D(this.name+'-transform');
        this.transform.setConnection(ConnectionType.inputs,'object',this);

        this.status = common$1.setting.BASIC_STATUS.creating|common$1.setting.BASIC_STATUS.clippingBoundary|common$1.setting.BASIC_STATUS.visible;


        const init = this.initialize, del = this.delete;

        this.initialize = async _=>{
            await init.call(this);
            this.status &= ~common$1.setting.BASIC_STATUS.creating;
        };
        this.delete = async _=>{
            $assert(!(this.status & common$1.setting.BASIC_STATUS.deleting), {msg:`${this.FullName} ${this.name} delete twice`});
            // $assert(this.FullName != null);
            this.status |= common$1.setting.BASIC_STATUS.deleting;
            await del.call(this);
            this.status = common$1.setting.BASIC_STATUS.deleted;
        };



    }


    get StatusOfMasked(){

        const results = [this];
        findParentsOf(results, this);
        if(isImplement(results[results.length-1],IWindow))
            results.pop();//pop uiWindow
        return _applyMasks(this, results.reverse());

    }

    get Status(){
        return this.status;

    }
    set Status(value){


        const win = $findRoot(this);
        //if(this.status & common.setting.STATUS.creating) debugger;
        if(isImplement(win,IWindow) && !(this.status & common$1.setting.STATUS.creating)){
            if(checkStatus$1(value, common$1.setting.BASIC_STATUS.animation)) {

                win.Status |=  common$1.setting.BASIC_STATUS.animation;
            }else {
                const win = $findRoot(this);
                $assert(win);
                win.Status |=  common$1.setting.BASIC_STATUS.rendering;
                win.status &=  ~common$1.setting.BASIC_STATUS.animation;
            }
        }


        this.status = value;
    }

    async initialize(){
        await super.initialize();

        $assert(this.params);
        if($isNumber$1(this.params.status)&&(this.params.status &  common$1.setting.STATUS.visible) == 0)
            this.status &= ~common$1.setting.STATUS.visible;


        if($isNumber$1(this.params.status)&&(this.params.status &  common$1.setting.STATUS.clippingBoundary) == 0)
            this.status &= ~common$1.setting.STATUS.clippingBoundary;

        if(this.params.position) this.transform.Position = this.params.position;


    }


    async delete(){

        this.transform.delete();
        this.transform = null;

        this.ctx = null;
        //this.offset = null;
        this.boundary = null;

        this.clearConnection();
        await super.delete();

    }


}

let Controllable$1 = class Controllable extends implement(Element2d, IControllable, ISelectable) {

    filters = 0;

    boundary = [0,0,0,0];
    selectedColor = 'rgba(100,0,0,1)';

    filterManager = null;
    controllableStore = [];

    controller = null;

    get Width(){return this.boundary[2];}
    set Width(value){this.boundary[2] =  value;}

    get Height(){return this.boundary[3];}
    set Height(value){this.boundary[3] = value;}

    get Status(){return super.Status;}
    set Status(val){
        const mask = common$1.setting.STATUS.active,
            isRefreshing = this.controller && (val&mask) != (this.status&mask);
        super.Status = val;
        if(isRefreshing){
            this.controller.refresh();
        }
    }

    isSelected = false;
    constructor(name='__test', params={}) {
        super(name, params);
        this.aabb = null;

        this.evtPool = {};

        this.filterManager = new ControlFilterManager(this);
        this.status |= common$1.setting.STATUS.active;


    }

    async initialize() {
        await super.initialize();
        this.aabb = [0, 0, 0, 0];
        this.filters=0;


        this.Width = this.params.width??editorSetting.setting.MIN_WIDTH;
        this.Height = this.params.height??editorSetting.setting.MIN_HEIGHT;

        if($isNumber$1(this.params.status)&&(this.params.status &  common$1.setting.STATUS.active) == 0)
            this.status &= ~common$1.setting.STATUS.active;



       Event$1.Instance.onUnicon(common$1.setting.EVT_TYPES.onControllerAttached, function (evt, controller){
            const target = evt.publisher;
            $assert(Array.isArray( target.controllableStore));
            target.controller = controller;


            //CHECK
            const storeCheck = [];
            for(const key in target.EvtPool){
                for(const {fnc, caller} of target.EvtPool[key].bubble)
                    storeCheck.push({evtType:key,fnc,isCapture:false});
                for(const {fnc, caller} of target.EvtPool[key].capture)
                    storeCheck.push({evtType:key,fnc,isCapture:true});
            }
            for(const {evtType, fnc, isCapture=false} of target.controllableStore)
                $assert(storeCheck.find(ele=> ele.evtType == evtType && ele.isCapture == isCapture && ele.fnc.toString() == fnc.toString()));



            // controller.registEventListener(target,target.controllableStore);
            const leafs = depthFirstSearch(target);
            for(const leaf of leafs){
                $assert(!(leaf.StatusOfMasked & common$1.setting.BASIC_STATUS.deleting));
                controller.registEventListener(leaf,leaf.controllableStore);
            }

            controller.updateEventListenerFilter(target);
        });


       Event$1.Instance.onUnicon(common$1.setting.EVT_TYPES.onControllerDetached, function(evt, controller){
            const target =  evt.publisher;
            target.controller = null;

            $assert(Array.isArray( target.controllableStore));


            const leafs = depthFirstSearch(target);
            for(const leaf of leafs){
                if(leaf.controllableStore.length)
                    controller.unregistEventListener(leaf,leaf.controllableStore);
            }

            resetFilter(controller,Controller);

        });

    }
    async delete() {
        // const controller = helper.$findParentByType(this,Controller);
        // for(let evtType in this.EvtPool)
        //     controller.unregistEventListener(evtType,this);




        await super.delete();
        this.controllableStore = null;
        this.filterManager = null;
        this.evtPool = null;
        this.aabb = null;
        this.filters=0;

        Event$1.Instance.remove({subscriber:this});
    }

    //IControllable  =============================================
    get Filters(){

        return this.filterManager;
    }
    get EvtPool() {
        return this.evtPool;
    };
    // get AABB(){
    //     Transform.multiply(this.aabb, this.transform, this.boundary);
    //     this.aabb[2] += this.aabb[0];
    //     this.aabb[3] += this.aabb[1];
    //     for(let child of this.Children.array) {
    //         let tmp = child.AABB;
    //         if(!tmp){//skip NodeEntry, only deal with Connector
    //             continue;
    //         }
    //         //extends AABB based on its children Connectors
    //         this.aabb[0] = this.aabb[0]<tmp[0]?this.aabb[0]:tmp[0];
    //         this.aabb[1] = this.aabb[1]<tmp[1]?this.aabb[1]:tmp[1];
    //         this.aabb[2] = this.aabb[2]>tmp[2]?this.aabb[2]:tmp[2];
    //         this.aabb[3] = this.aabb[3]>tmp[3]?this.aabb[3]:tmp[3];
    //     }
    //
    //
    //     return this.aabb;
    // }
    get Boundary() {
        $assert(this.boundary);
        return this.boundary;
    }

    set Boundary(val){
        this.boundary = val;
    }


    async appendChild(child) {
        super.appendChild(child);
        const controller = $findParentByType(this, Controller);
        if(controller) {
            // const decendents = depthFirstSearch(child,
            //     ele=> !checkStatus(ele.Status, common.setting.STATUS.deleting));
            //
            // for(const decendent of decendents)

            await Event$1.Instance.emit(common$1.setting.EVT_TYPES.onControllerAttached, child, [controller]);
        }
    }
    async insertChild(index,child) {
        super.insertChild(index,child);

        const controller = $findParentByType(this, Controller);
        if(controller) {
            // const decendents = depthFirstSearch(child,
            //     ele=> !checkStatus(ele.Status, common.setting.STATUS.deleting));
            //
            // for(const decendent of decendents)


            await Event$1.Instance.emit(common$1.setting.EVT_TYPES.onControllerAttached, child, [controller]);
        }
    }
    async removeChild(child) {
        super.removeChild(child);


        const controller = $findParentByType(this, Controller);
        if(controller){
            // const decendents = depthFirstSearch(child);
            // for(const decendent of decendents)
            //     Event.Instance.emit(common.setting.EVT_TYPES.onControllerDetached,decendent, [controller,decendent,this,decendents]);


            await Event$1.Instance.emit(common$1.setting.EVT_TYPES.onControllerDetached,child, [controller]);

        }
    }

    #registEvent(evtType, fnc, isCapture = false){
        const store = {evtType, fnc, isCapture, controller:null};
        this.controllableStore.push(store);
        return store;
    }

    #unregistEvent(evtType, fnc){
        this.controllableStore.filter(ele=>!(ele.evtType == evtType && ele.fnc == fnc));
    }
    checkEventListener(evtType,fnc){
        return checkEventListener(this,evtType,fnc);
    }
    addEventListener(evtType, fnc, isCapture = false) {


        const store = this.#registEvent(evtType, fnc, isCapture);
        addEventListener( this, evtType, fnc,isCapture);


        const  controller = $findParentByType(this, Controller);
        if(controller){
            store.controller = $findParentByType(this, Controller).FullName;
            controller.registEventListener(this,[{evtType,fnc,isCapture}]);
        }
    }
    removeEventListener(evtType, fnc,isCapture = false) {


        this.#unregistEvent(evtType, fnc, isCapture);
        removeEventListener(this, evtType, fnc);
        const controller = $findParentByType(this, Controller);

        $assert(controller,{
            errorType:common$1.error.ERR_TYPE.internalErr,
            msg:'cannot removeEventListener with isolated component'
        });

        controller.unregistEventListener(this,[{evtType,fnc,isCapture}]);

        resetFilter(controller,Controller);
    }


    //ISelectable  =============================================

    get IsSelected(){return this.isSelected};
    set IsSelected(value){this.isSelected=value;};

    get SelectedColor(){return this.selectedColor;};
    set SelectedColor(value){this.selectedColor = value;};
};

class Component extends implement(Controllable$1,ILayoutComponent, IDrawable){

    color = null;
    originColor = null;
    alpha = 1;
    get Alpha(){return this.alpha;}
    set Alpha(val){this.alpha = val;}
    strokeColor = null;
    lineWidth = null;

    renderIndex = 0;
    drawHandler = null;
    ratio = 1.33;

    get Ratio(){return this.ratio;}
    set Ratio(val){this.ratio = val;}

    get DrawHandler(){return this.drawHandler;}
    get Color(){return this.color;}
    set Color(value){

        if(this.color == null)
            this.originColor = value;
        this.color = value;
    }


    get Width(){return super.Width;}
    set Width(val){
        super.Width = val;
    }
    get Height(){return super.Height;}
    set Height(val){
        super.Height = val;
    }


    // preferredSize = null;
    // get PreferredSize(){return this.preferredSize;}
    // set PreferredSize(val){this.preferredSize = val;}

    margin = {left:0,right:0,top:0,bottom:0};
    get Margin(){return this.margin;};
    set Margin(val){
        setCSSData(this,'margin', val);
    }

    padding = {left:0,right:0,top:0,bottom:0};
    get Padding(){return this.padding;};
    set Padding(val){
        setCSSData(this,'padding', val);
    }

    layoutMode  = null;
    get LayoutMode(){ return this.layoutMode;}
    set LayoutMode(val){
        const LAYOUT_MODE = ILayoutComponent.LAYOUT_MODE;

        if((val & LAYOUT_MODE.ANCHOR_HORIZONTAL_MASK) == 0)
            val |= LAYOUT_MODE.center;

        if((val & LAYOUT_MODE.ANCHOR_VERTICAL_MASK) == 0)
            val |= LAYOUT_MODE.middle;

        this.layoutMode = val;
    }


    constructor(name='__test',params={}){
        super(name,params);


        this.status |= common$1.setting.STATUS.layoutable;
    }



    async initialize(){
        await  super.initialize();

        this.Color = this.params.color??editorSetting.setting.COMPONENTS.color;
        this.strokeColor = this.params.strokeColor??editorSetting.setting.COMPONENTS.strokeColor;//editorSetting.setting.WINDOW.outlineStrokeColor
        this.lineWidth = this.params.lineWidth??editorSetting.setting.COMPONENTS.lineWidth; //editorSetting.setting.WINDOW.outlineStrokeWidth

        this.marginColor = this.params.marginColor??'rgba(0,0,0,0)';

        this.preferredSize = this.params.preferredSize ??null;

        this.Ratio = this.params.ratio??1.33;
        this.LayoutMode = this.params.layoutMode??ILayoutComponent.LAYOUT_MODE.center|ILayoutComponent.LAYOUT_MODE.middle;
        this.Margin = this.params.margin ?? {left:0, top:0, right:0, bottom:0};

        // this.Width = this.params.width??editorSetting.setting.MIN_WIDTH - this.margin.left - this.margin.right;
        // this.Height = this.params.height??editorSetting.setting.MIN_HEIGHT - this.margin.top - this.margin.bottom;

        if($isNumber$1(this.params.status)&&(this.params.status &  common$1.setting.STATUS.layoutable) == 0)
            this.status &= ~common$1.setting.STATUS.layoutable;
    }

    draw(ctx,cam){
        ctx.fillStyle = this.color;
        ctx.fillRect(this.boundary[0],this.boundary[1],this.boundary[2],this.boundary[3]);
        if(this.drawHandler)
            this.drawHandler(ctx,cam);

        strokeOutline(ctx, this.Width,this.Height,this.strokeColor, this.lineWidth);
    }
}

const LAYOUT_MODE = common$1.setting.LAYOUT_MODE;

function initialize(layout){

    layout.Status |= common$1.setting.STATUS.clippingWindow;
    layout.LayoutMode = layout.params.layoutMode ?? LAYOUT_MODE.vertical|LAYOUT_MODE.resizeX|LAYOUT_MODE.resizeY;

    layout.color = layout.params.color?? editorSetting.setting.COMPONENTS.layout.color;
    layout.strokeColor = layout.params.strokeColor??editorSetting.setting.COMPONENTS.layout.strokeColor;
    layout.lineWidth = layout.params.lineWidth??editorSetting.setting.COMPONENTS.layout.lineWidth;
}
function refresh(layout, children = layout.Children){


    children = children.filter(ele=>!(ele.StatusOfMasked & common$1.setting.STATUS.deleting));

    const MODE = LAYOUT_MODE;
        layout.boundary;

    const   array = children.filter(ele=>
        isImplement(ele, ILayoutComponent)&&
        checkStatus$1(ele.Status, common$1.setting.STATUS.layoutable));


    let  value = 0 ,fullWidth = layout.Width,fullHeight = layout.Height,
        scaleDown = 1, averageSize = 0;


    if(layout.LayoutMode & MODE.vertical)
        [scaleDown,averageSize] = calculateCurLayoutSize(true, array,fullWidth, fullHeight);

    else if(layout.LayoutMode & MODE.horizontal)
        [scaleDown,averageSize]  = calculateCurLayoutSize(false,array, fullWidth, fullHeight);

    else
        $assert(false, {errorType:common$1.error.ERR_TYPE.internalErr, msg:'layout must be either vertical or horizontal'});



    if(array.length == 1){

        const comp = array[0];

        const isFixSize =
                !(comp.LayoutMode&LAYOUT_MODE.resizeX) &&!(comp.LayoutMode&LAYOUT_MODE.expandX) &&
                !(comp.LayoutMode&LAYOUT_MODE.resizeY) && !(comp.LayoutMode&LAYOUT_MODE.expandY),
            hasSpace = fullHeight>0&&fullWidth>0;


        if(isFixSize && hasSpace){
            const offsetX = calculateAnchor( layout.boundary,comp.boundary, comp.layoutMode & LAYOUT_MODE.ANCHOR_HORIZONTAL_MASK, comp.Margin),
                offsetY = calculateAnchor( layout.boundary,comp.boundary, comp.layoutMode & LAYOUT_MODE.ANCHOR_VERTICAL_MASK, comp.Margin);
            comp.UIPosition = [offsetX,offsetY];
        }


        if(isImplement(comp, ILayout))
            comp.refresh();

        if(comp.LayoutMode&LAYOUT_MODE.resizeX)
            comp.Width = fullWidth;

        if(comp.LayoutMode&LAYOUT_MODE.resizeY)
            comp.Height = fullHeight;

    }else

        for (let i in  array) {
            const comp = array[i],
                pos = comp.UIPosition;
            $assert(pos);

            // if(isExpandTest){
            //     debugger;
            //     if(layout.LayoutMode & MODE.expandX)
            //         boundary[2] = comp.boundary[2];
            //     if(layout.LayoutMode & MODE.expandY)
            //         boundary[3] = comp.boundary[3];
            // }


            //{Width:fullWidth,Height:fullHeight},
            // has to be {Width:fullWidth,Height:fullHeight}, to call setter
            const
                isVertical = layout.LayoutMode & MODE.vertical,
                otherSideKey = isVertical?'Width':'Height',
                otherSideResize = isVertical?MODE.resizeX:MODE.resizeY,
                size = {Width:fullWidth,Height:fullHeight};

            if(comp.LayoutMode&otherSideResize){
                const margin = isVertical?(comp.Margin.left+comp.Margin.right):(comp.Margin.top+comp.Margin.bottom);
                comp[otherSideKey] = size[otherSideKey]-margin;
            }

            value = stackingLayout(value, layout, comp, averageSize, scaleDown);



            if(isImplement(comp, ILayout))
                // if(!(comp.LayoutMode & MODE.expandX) && !(comp.LayoutMode & MODE.expandY))
                comp.refresh();

            $assert($isNumber$1(comp.Boundary[3])&&$isNumber$1(comp.Boundary[2]));
            value += layout.LayoutMode&MODE.vertical ?
                comp.Boundary[3]:comp.Boundary[2];

        }




    // if(layout.RefreshDoneHandlers&&layout.RefreshDoneHandlers.length)
    //     for(const {caller,fnc} of layout.RefreshDoneHandlers){
    //         debugger;
    //         fnc.call(caller);
    //     }


    const renderable =
        depthFirstSearch(layout,
            ele=>   ele.FullName != layout.FullName &&
                            checkStatus$1(ele.Status, common$1.setting.STATUS.visible) &&
                            !checkStatus$1(ele.Status, common$1.setting.STATUS.clippingWindow));//add descendents


    renderable.push(... children.filter(ele=>
                                checkStatus$1(ele.Status, common$1.setting.STATUS.clippingWindow)&&//add direct child
                                checkStatus$1(ele.Status, common$1.setting.STATUS.visible)));


    layout.Renderables.length = 0;
    layout.Renderables.push(... renderable.filter(ele=>isImplement(ele, IDrawable)).sort((a,b)=>a.RenderIndex-b.RenderIndex));


}
function  draw(layout, ctx,cam){

    ctx.fillStyle = layout.color;//layout.bgColor;
    ctx.fillRect(layout.boundary[0],layout.boundary[1],layout.boundary[2],layout.boundary[3]);

    const boundary = [0,0,0,0];

    Transform2D.multiply(boundary, layout.transform.globalMatrix, layout.boundary);
    layout.Renderables.forEach(child => {
        const childBoundary = [0,0,0,0];
        Transform2D.multiply(childBoundary, child.transform.globalMatrix, child.boundary);


        if(!$isBoundaryOverlap(boundary, childBoundary))
            return true; //continue


        if(child.name == 'drag1')
            console.log();

        child.preDraw(ctx, cam);
        child.draw(ctx, cam);
        child.postDraw(ctx, cam);

    });


    strokeOutline(ctx, layout.Width,layout.Height,layout.strokeColor, layout.lineWidth);


}




function calculateAnchor(containerBoundary,targetBoundary,anchor= LAYOUT_MODE.center|LAYOUT_MODE.middle,
                                padding={left:0,top:0,right:0,bottom:0}){



    const
        paddingBound = [padding.left, padding.top, padding.right, padding.bottom],
        direction = (anchor & LAYOUT_MODE.ANCHOR_HORIZONTAL_MASK) ? 'x':'y',
        startIndex = direction == 'x'?0:1,
        POS_LAYOUT = {
            x:[LAYOUT_MODE.left, LAYOUT_MODE.center, LAYOUT_MODE.right],
            y:[LAYOUT_MODE.top, LAYOUT_MODE.middle, LAYOUT_MODE.bottom],
        },
        boundary = containerBoundary.slice();

    boundary[startIndex] += paddingBound[startIndex];
    boundary[startIndex+2] -= paddingBound[startIndex]+paddingBound[startIndex+2];


    let offset;
    if(anchor&POS_LAYOUT[direction][0]){
        offset = boundary[startIndex];
    }else if(anchor&POS_LAYOUT[direction][1]){
        offset =  boundary[startIndex]+boundary[startIndex+2]*0.5 - targetBoundary[startIndex+2]*0.5;
        // offset = -boundary[startIndex+2]*0.5 + targetBoundary[startIndex+2]*0.5 + boundary[startIndex];
    }else if(anchor&POS_LAYOUT[direction][2]){
        offset =  boundary[startIndex+2] - targetBoundary[startIndex+2];
    }else
        $assert(false,{errorType:common$1.error.ERR_TYPE.internalErr,
            msg:'layoutMode is uninitialized',data:{stack:new Error().stack}});

    $assert($isNumber$1(offset));
    return offset;
}
const MODE$1 = common$1.setting.LAYOUT_MODE;
function expandRule(curNode){
    //curNode cannot be resizable
    if(curNode.LayoutMode & MODE$1.expandX)
        curNode.Children.forEach(ele=>ele.LayoutMode &= ~MODE$1.resizeX);

    if(curNode.LayoutMode & MODE$1.expandY)
        curNode.Children.forEach(ele=>ele.LayoutMode &= ~MODE$1.resizeY);
}

function stackingLayout(value,parent, child, averageSize,scaleDown){
    const
        layoutMode = parent.LayoutMode,
        boundary = parent.boundary,
        isVertical = layoutMode & MODE$1.vertical,
        alongSideResize = isVertical?MODE$1.resizeY:MODE$1.resizeX,
        alongSideKey = isVertical?'Height':'Width', // has to be Height and Width, to call setter
        anchorMask = isVertical? MODE$1.ANCHOR_HORIZONTAL_MASK:MODE$1.ANCHOR_VERTICAL_MASK,
        lockSize = isVertical?(child.Width / child.Ratio):
                                (child.Ratio * child.Height);


    if(child.LayoutMode&alongSideResize) {
        if (child.LayoutMode & MODE$1.lockRatio)
            child[alongSideKey] = lockSize;
        else if (child.PreferredSize == null)
            child[alongSideKey] = averageSize;
        else
            child[alongSideKey] = scaleDown * child.PreferredSize;
    }

    let offset = 0;
    const otherSizeExpand = isVertical?layoutMode&MODE$1.expandX:layoutMode&MODE$1.expandY;
    if(!otherSizeExpand)
        offset = calculateAnchor(boundary,child.boundary, child.layoutMode & anchorMask, child.Margin);

    value += isVertical?child.Margin.top:child.Margin.left;
    if(child.LayoutMode&MODE$1.ignoreTranslate)
        child.transform.update();
    else
        child.UIPosition = isVertical?[offset, value]:[value,  offset];


    value += isVertical?child.Margin.bottom:child.Margin.right;
    return value;
}

function calculateCurLayoutSize(isVertical,children, width, height){
    const childFixed = children.filter(ele=> !(ele.LayoutMode& (isVertical?MODE$1.resizeY:MODE$1.resizeX))),
        childExpandable =  children.filter(ele=>isImplement(ele, ILayout) &&
                                (ele.LayoutMode & MODE$1.expandX || ele.LayoutMode & MODE$1.expandY));

    for(const child of childExpandable){
        expandRule(child);

        if(child.LayoutMode & MODE$1.expandX) {
            if(child.LayoutMode & MODE$1.resizeY)
                child.Height = height;
            //child.Width = width; //tmp value
            child.refresh(child.Children, true);
            child.expand(['x']);
        }
        if(child.LayoutMode & MODE$1.expandY){
            if(child.LayoutMode & MODE$1.resizeX)
                child.Width = width;
            //child.Height = height; //tmp value
            child.refresh(child.Children, true);
            child.expand(['y']);
        }

    }

    const
        isRatioFixed = curEle =>curEle.LayoutMode&(isVertical?MODE$1.resizeX:MODE$1.resizeY) && (curEle.LayoutMode&MODE$1.lockRatio),
        ignoredFixedLength = childFixed.reduce((acc, curEle) => acc +
                            (
                                isRatioFixed(curEle)?
                                    (isVertical?width:height)/curEle.Ratio:
                                    (isVertical?curEle.Height:curEle.Width)
                            ),0),
        ignoredMarginLength = children.reduce((acc, curEle) => acc +
            (isVertical?(curEle.Margin.top + curEle.Margin.bottom):(curEle.Margin.left + curEle.Margin.right)),0);


    let length = (isVertical?height:width) - ignoredFixedLength - ignoredMarginLength; // - Spacing*(children.length-1)
    length = length.clamp(0,Math.maxInt);
    const totalPreferredSize =   children.filter(ele=>ele.LayoutMode&(isVertical?MODE$1.resizeY:MODE$1.resizeX))
        .reduce((acc, curEle) => acc + (curEle.PreferredSize?curEle.PreferredSize:0),0);

    const scaleDown = totalPreferredSize &&  totalPreferredSize>length ?
                    length/totalPreferredSize:1,

        numOfAutoSizedEle = isVertical?
            children.filter(ele=>(ele.LayoutMode&MODE$1.resizeY) && ele.PreferredSize == null ).length:
            children.filter(ele=>(ele.LayoutMode&MODE$1.resizeX) && ele.PreferredSize == null ).length,

        averageSize  = numOfAutoSizedEle?(length-totalPreferredSize*scaleDown)
                .clamp(0,Math.maxInt)/numOfAutoSizedEle:0;
    return [scaleDown, averageSize];
}

let __curLayout = null;
class Layout extends implement(Component,ILayout,IDrawable){


    static async create(contentLayout, mode=Layout.LAYOUT_MODE.create, fnc=_=>{}){
       const prevLayout = __curLayout;
        __curLayout = contentLayout;
        const begin =_=>{
            const children = depthFirstSearch(contentLayout,
                ele=> ele instanceof Layout,
                ele=> ele.getConnection(ConnectionType.outputs,'children'));


            if(mode & Layout.LAYOUT_MODE.create)
                for(const child of children)
                    child.LayoutMode |= Layout.LAYOUT_MODE.create;
            else if(mode & Layout.LAYOUT_MODE.update)
                    for(const child of children)
                        child.LayoutMode |= Layout.LAYOUT_MODE.update;
            else
                $assert(false, {errorType:common$1.error.ERR_TYPE.paramsErr, msg:'params mode has to be either LAYOUT_MODE.create or LAYOUT_MODE.update'});

        };


        const end = _=>{
            const children = depthFirstSearch(contentLayout,
                ele=> ele instanceof Layout,
                ele=> ele.getConnection(ConnectionType.outputs,'children')
            );

            for(const child of children)
                if(contentLayout.LayoutMode & Layout.LAYOUT_MODE.create)
                    child.LayoutMode &= ~Layout.LAYOUT_MODE.create;
                else if(contentLayout.LayoutMode & Layout.LAYOUT_MODE.update)
                    child.LayoutMode &= ~Layout.LAYOUT_MODE.update;


            const curEditor = $findRoot(contentLayout);
            curEditor.refresh();
        };


        begin();
        await fnc();
        end();
        __curLayout = prevLayout;
        return contentLayout;
    }




     static beginInit(contentLayout, mode=Layout.LAYOUT_MODE.create){
         // __INIT = true;
        $assert(__curLayout == null);
        // if(!contentLayout){
        //     debugger;
        //     // contentLayout = window.Keanu.editors.objs[getSourceClassNm()].Content;
        // }

        __curLayout = contentLayout;
        $assert(__curLayout);


         const children = depthFirstSearch(__curLayout,
             ele=> ele instanceof Layout,
             ele=> ele.getConnection(ConnectionType.outputs,'children')
         );
        if(mode & Layout.LAYOUT_MODE.create)
            for(const child of children)
                child.LayoutMode |= Layout.LAYOUT_MODE.create;
        else if(mode & Layout.LAYOUT_MODE.update)
            for(const child of children)
                child.LayoutMode |= Layout.LAYOUT_MODE.update;
        else
            $assert(false, {errorType:common$1.error.ERR_TYPE.paramsErr, msg:'params mode has to be either LAYOUT_MODE.create or LAYOUT_MODE.update'});

        return __curLayout;
    }
    static get CurLayout(){return __curLayout;}

    static endInit(){

        $assert(__curLayout);

        const children = depthFirstSearch(__curLayout,
            ele=> ele instanceof Layout,
            ele=> ele.getConnection(ConnectionType.outputs,'children')
        );

        for(const child of children)
            if(__curLayout.LayoutMode & Layout.LAYOUT_MODE.create)
                child.LayoutMode &= ~Layout.LAYOUT_MODE.create;
            else if(__curLayout.LayoutMode & Layout.LAYOUT_MODE.update)
                child.LayoutMode &= ~Layout.LAYOUT_MODE.update;


        const curEditor = $findRoot(__curLayout);
        curEditor.refresh();
        __curLayout = null;

    }
    static get CurLayout(){
        return __curLayout;
    }
    static exist = function(name){
        const children = __curLayout.getConnection(ConnectionType.outputs,'children'),
            existEle = children.find(ele=>ele.name == name);
        return existEle?true:false;
    }


    static clear = function(children){
        if(children&&!Array.isArray(children))
            children = [children];
        children = children??__curLayout.getConnection(ConnectionType.outputs,'children');
        for(const child of children){
            child.parent.removeChild(child);
            Layout.clearHierachy(child);
        }
    }

    static  begin =async function(name = 'layout', params={color:editorSetting.setting.COMPONENTS.layout.color,layoutMode:Layout.LAYOUT_MODE.vertical|Layout.LAYOUT_MODE.resizeX|Layout.LAYOUT_MODE.resizeY}){
        const classProto = this.prototype.constructor;
        if(__curLayout == null){
            const validName = name;

            const layout = new classProto(validName,params);
            await layout.initialize();


            layout.LayoutMode |= Layout.LAYOUT_MODE.create;
            //layout.ContentLayout = this or childLayout
            __curLayout = layout.ContentLayout;
            __curLayout.LayoutMode |= Layout.LAYOUT_MODE.create;
            return layout;
        }


        const children = __curLayout.getConnection(ConnectionType.outputs,'children'),
            existEle = children.find(ele=>ele.name == name);
        if(__curLayout.LayoutMode & Layout.LAYOUT_MODE.create&&!existEle){


            const validName = $getValidName(__curLayout, name);

            $assert(validName == name,
                {path:null,errorType:common$1.error.ERR_TYPE.guiErr,
                msg:'layout name clash',data:{layoutParent:__curLayout.FullName, layoutName:name}});



            const layout = new classProto(validName,params);
            await __curLayout.appendChild(layout);
            await layout.initialize();


            Layout.linkHierachy(__curLayout, layout.ContentLayout);

            layout.LayoutMode |= Layout.LAYOUT_MODE.create;
            //layout.ContentLayout = this or childLayout
            __curLayout = layout.ContentLayout;
            __curLayout.LayoutMode |= Layout.LAYOUT_MODE.create;
            return layout;
        }else {

            if (existEle && existEle instanceof classProto) { //return Textbox

                __curLayout = existEle;
                $assert(__curLayout);
                return __curLayout;
            } else {
                $assert(false,
                    {path:__curLayout.FullName,errorType:common$1.error.ERR_TYPE.guiErr,
                        msg:`cannot find ${name}`,data:{children:__curLayout.Children.map(ele=>ele.FullName), layoutName:name}});

                debugger;
                // console.error('cannot find ', name, 'among ', __curLayout.Children);



            }
        }


    }

    static end = function(){
        $assert(__curLayout);
        __curLayout.LayoutMode &= ~Layout.LAYOUT_MODE.create;
        const result = __curLayout;
        let parent = __curLayout.getConnection(ConnectionType.inputs,'parent');
        if(parent)
            $assert(isImplement(parent , ILayout));
        __curLayout =  parent;
        //
        // if( __INIT){
        //     $assert(__curLayout);
        //     __INIT = false;
        // }
        return result;
    }


    static set CurLayout(val){__curLayout=val;}
    static get CurLayout(){return __curLayout;}







    // get Spacing(){return 0;}




    renderIndex = 0;
    renderables = [];
    get Renderables(){return this.renderables};

    minSize = null;
    maxSize = null;


    get Width(){
        return this.boundary[2];
    }
    get Height(){
        return this.boundary[3];
    }



    set Width(val){

        this.boundary[2] = val;
    }

    set Height(val){
        this.boundary[3] = val;
    }

    // get Status(){
    //     return this.status;
    // }
    //
    // set Status(val){this.status = val;}


    constructor(name='unnamed', params={layoutMode:Layout.LAYOUT_MODE.vertical|Layout.LAYOUT_MODE.resizeX|Layout.LAYOUT_MODE.resizeY}){
        super(name,params);

    }

    async initialize(){
        await super.initialize();
        await initialize(this);
    }

    refresh(children = this.Children){
        const win = $findRoot(this);
        if(win && win.__DELAY_REFRESH)
            return;
        $assert(!(this.StatusOfMasked & common$1.setting.STATUS.deleted));
        refresh(this,children);
    }


    expand(direction = ['x','y']){
        // const [,,width,height] = this.boundary;
        // this.boundary = [0,0,0,0];
        // if(this.LayoutMode & Layout.LAYOUT_MODE.expandX)
        //     direction.push('x');
        //
        // if(this.LayoutMode & Layout.LAYOUT_MODE.expandY)
        //     direction.push('y');


        if(direction.includes('x'))
            this.boundary[2] = 0;

        if(direction.includes('y'))
            this.boundary[3] = 0;

        // refreshBoundary(this, target=>{
        //     if(!checkStatus(target.Status, common.setting.BASIC_STATUS.visible))
        //         return false;
        //     return true;
        // },direction, {depth:1});

        refreshBoundary(this,
            target=>checkStatus$1(target.Status, common$1.setting.STATUS.layoutable),
            direction, {depth:1});
    }

    resize(size=[this.Width,this.Height]){
        [this.Width,this.Height] = size;
    }

    async clear(){

        let children = this.Children.slice();
        for (let i = children.length - 1; i >= 0; i--)
            await children[i].delete();

    }

    async delete(){
        await super.delete();
    }



    draw(ctx,cam){
        draw(this,ctx,cam);
    }





}

class Label extends implement(Component){

    static MODE = {
        initializing:1, omit:2, omitting:1024,
    }


    mode = null;
    get Mode(){return this.mode;}
    set Mode(val){

        if(val & Label.MODE.initializing){

            this.mode = this.resetMode(val);
            if(this.Text)
                this.initText();
        }else
            this.mode = val;
    }
    resetMode(value){
        for (let key in Label.MODE)
            if (/ing$/.test(key))
                value &= ~Label.MODE[key];

        if(value & Label.MODE.omit)
            if(this.Text&&this.setOmitText())
                value |= Label.MODE.omitting;

        return value;
    }

    color = null;
    get Color(){return this.color;}
    set Color(value){this.color = value;}


    text = null;
    omitText = null;
    get Text(){
        if(this.mode & Label.MODE.omitting)
            return this.omitText;
        else
            return this.text;
    }

    set Text(value){

        if(this.text == value)
            return;


        // this.oldText = this.text;
        this.text = value.toString();

        if(this.mode&Label.MODE.autoExtend) {
            this.Width = this.measureText(this.ctx, this.text)[2] + this.margin.right + this.margin.left;
        }

        //if(this.Mode)
            this.Mode |= Label.MODE.initializing;

    }


    setOmitText(){

        $assert(this.Text);
        if(this.Text.length==0)
            return false;

        const measureBox = this.measureText(this.ctx,this.text),
            MARGIN = this.margin.left + this.margin.right;
        if(measureBox[2]>this.Width - MARGIN){
            const widthLimit = this.Width - MARGIN,
                pool = [], dotsTxt = '...';
            for(let i=0;i<this.text.length;i++)
                pool.push(this.text.slice(0,i)+dotsTxt);

            for(const txt of pool){
                this.omitText = txt;
                if(this.measureText(this.ctx, this.omitText)[2]>widthLimit){
                    break;
                }
            }
            return true;
        }else {
            this.omitText = this.text;
            return false;
        }

    }

    initText(){

        if(this.Text){
            let measureBox;

            measureBox = this.measureText(this.ctx,this.Text);

            // this.textOffset = this.calculateAnchor(measureBox,this.layoutMode);

            const   offsetX = calculateAnchor(this.boundary,measureBox, this.layoutMode & Layout.LAYOUT_MODE.ANCHOR_HORIZONTAL_MASK, this.Padding),
                offsetY = calculateAnchor(this.boundary,measureBox, this.layoutMode & Layout.LAYOUT_MODE.ANCHOR_VERTICAL_MASK, this.Padding);
            this.textOffset = [offsetX, offsetY];
        }else
            this.textOffset[0] = this.textOffset[1] = 0;

    }




    get Width(){return super.Width;}
    set Width(val){
        super.Width = val;
        if(this.text)
            this.Mode |= Label.MODE.initializing;
    }

    get Height(){return super.Height;}
    set Height(val){
        super.Height = val;
        if(this.text)
            this.Mode |= Label.MODE.initializing;
    }


    textOffset = [0,0];
    fontParams =  JSON.parse(JSON.stringify(editorSetting.setting.WINDOW.fontParams));
    constructor(name='__test',params={}){
        super(name,params);
        this.status |= common$1.setting.BASIC_STATUS.visible;
    }



    async initialize(ctx){


        this.ctx = ctx?? getBackupCanvas().getContext('2d');
        $assert(this.ctx);
        await super.initialize();

        this.fontParams = this.params.fontParams ?? this.fontParams;
        this.Mode = this.params.mode|Label.MODE.initializing ?? Label.MODE.initializing; //init mode
        this.Text = this.params.text ?? this.name;//set Text first



        this.Color = this.params.color?? editorSetting.setting.COMPONENTS.color;



    }

    delete(){

        this.color = null;
        this.textOffset = null;
        this.omitText = null;
        super.delete();
    }

    measureText(ctx, text, range = [0, text?text.length:0], font = this.Font){
        $assert(text!= undefined);

        $assert(ctx);

        ctx.textBaseline = 'top';
        ctx.font = font;

        if(typeof text === 'number' )
            text = text.toString();

        // const lowerRange = range[0]<range[1]?range[0]:range[1],
        //     highRange = range[0]>range[1]?range[0]:range[1];

        const [lowerRange, highRange] = range;
        const   diffText = ctx.measureText(text.slice(0,lowerRange)),
                fullText = ctx.measureText(text.slice(0,highRange)),
                // height =fullText.fontBoundingBoxAscent + fullText.fontBoundingBoxDescent;


            height =fullText.actualBoundingBoxAscent + fullText.actualBoundingBoxDescent;


        // top: pos[1] - metrics.actualBoundingBoxAscent,
        // right: pos[0] + metrics.actualBoundingBoxRight,
        // bottom: pos[1] + metrics.actualBoundingBoxDescent,
        // left: pos[0] - metrics.actualBoundingBoxLeft

        let result =  [
            diffText.width,//diffText.actualBoundingBoxRight,
            0, //-fullText.fontBoundingBoxAscent,
            fullText.width-diffText.width,
            height
        ];


        return result;//result.map(ele=>Math.floor(ele));
    }






    get Font(){


        return (this.fontParams.bold?'bold ':'') + this.fontParams.size + "px "+ this.fontParams.font;
    }

    drawText(ctx, txt = 'test',offset,
             fontParams = this.fontParams){
        ctx.fillStyle = fontParams.color;

        ctx.font =  this.Font;

        $assert(offset&&$isNumber$1(offset[0])&&$isNumber$1(offset[1]));

        ctx.save();
        ctx.textBaseline = 'top';
        ctx.translate(offset[0], offset[1]);
        ctx.fillText(txt, 0,0);

        // const bound = this.measureText(this.ctx, this.text);
        // ctx.strokeRect(...bound);

        ctx.restore();
    }



    draw(ctx,cam){
        this.ctx = ctx;
        ctx.fillStyle = this.color;
        ctx.fillRect(this.boundary[0],this.boundary[1],this.boundary[2],this.boundary[3]);


        // const measureBox = this.measureText(this.ctx,this.Text);
        // measureBox[0] = this.textOffset[0];
        // measureBox[1] = this.textOffset[1];
        // ctx.fillStyle = 'red';
        // ctx.fillRect(...measureBox)

        this.drawText(ctx, this.Text,this.textOffset);

        strokeOutline(ctx, this.Width,this.Height,this.strokeColor, this.lineWidth);
    }
}

const DEFAULT$4 = ILayoutComponent.LAYOUT_MODE.vertical|ILayoutComponent.LAYOUT_MODE.resizeX|ILayoutComponent.LAYOUT_MODE.expandY;
class FoldableLayout extends implement(Layout,IData){//


    static  begin(name = 'foldableLayout', params={layoutMode:DEFAULT$4}) {
        return Layout.begin.call(FoldableLayout,name,params);
    }
    static clear = function(){
        const
            title = Layout.CurLayout.titleLayout,
            children = Layout.CurLayout.getConnection(ConnectionType.outputs,'children');

        return Layout.clear(children.filter(ele=>ele.FullName!== title.FullName));
    }

    constructor(name='__test',params={layoutMode:FoldableLayout.LAYOUT_MODE.vertical}) {
        super(name, params);
    }


    #path = null;
    get Path(){return this.#path;}
    set Path(value){this.#path = value;}


    get LayoutMode(){return super.LayoutMode;}
    set LayoutMode(value){
        const parentWindow = getParentsOf(this,parent=> isImplement(parent, IWindow)).shift();

        if(value&FoldableLayout.LAYOUT_MODE.folding && !( super.LayoutMode&FoldableLayout.LAYOUT_MODE.folding)){
            this.Children.filter(ele=>ele.FullName!== this.titleLayout.FullName)
                .forEach(ele=>{
                    ele.Status &= ~common$1.setting.STATUS.visible;
                    ele.Status &= ~common$1.setting.STATUS.active;
                    ele.Status &= ~common$1.setting.UI_STATUS.layoutable;
                });

            parentWindow.refresh();

        }else if(!(value&FoldableLayout.LAYOUT_MODE.folding) && super.LayoutMode&FoldableLayout.LAYOUT_MODE.folding){
            this.Children.ter(ele=>ele.FullName!=this.titleLayout.FullName)
                .forEach(ele=>{
                    ele.Status |= common$1.setting.STATUS.visible;
                    ele.Status |= common$1.setting.STATUS.active;
                    ele.Status |= common$1.setting.UI_STATUS.layoutable;
                });

            parentWindow.refresh();
        }




        super.LayoutMode = value;

    }

    async initialize(){
        await  super.initialize();
        this.LayoutMode = this.params.layoutMode ?? DEFAULT$4;
        const titleColor = this.params.titleColor ?? editorSetting.setting.COMPONENTS.titleLayout.titleColor,
            fontParams = this.params.fontParams ?? editorSetting.setting.COMPONENTS.titleLayout.fontParams;
        this.titleLayout = new Layout(this.name+'_titleLayout', {
            color:titleColor,
            layoutMode:Layout.LAYOUT_MODE.horizontal|Layout.LAYOUT_MODE.resizeX,
            height:editorSetting.setting.COMPONENTS.foldableLayout.titleHeight,
        });
        await this.appendChild(this.titleLayout);
        await this.titleLayout.initialize();
        // Layout.linkHierachy(this, this.titleLayout);


        this.title = new Label(this.name + '_title', {fontParams,text:this.name, layoutMode:Layout.LAYOUT_MODE.resizeX|Layout.LAYOUT_MODE.middle});

        await this.titleLayout.appendChild(this.title);
        await this.title.initialize();
        // Layout.linkHierachy(this.titleLayout, this.title);
        this.title.addEventListener('click',evt=>{
            // if(evt.buttons != common.setting.MOUSE_BUTTONS.leftBtn)
            //     return;
            this.LayoutMode ^= Layout.LAYOUT_MODE.folding;
        });
    }
    async clear(){
        const children = this.Children.slice().filter(ele=>ele.FullName!== this.titleLayout.FullName);
        for (let i = children.length - 1; i >= 0; i--)
            await children[i].delete();

    }

}

function findDraggableChild(target){
    const targetLayout = $findParentByType(target, DraggableLayout);
    let result = null;
    for(let child of targetLayout.Children){
        if(new RegExp(child.FullName).test(target.FullName))
            result = child;
    }
    return result;
}

const DEFAULT$3 = Layout.LAYOUT_MODE.vertical|Layout.LAYOUT_MODE.resizeX|Layout.LAYOUT_MODE.expandY;

class DraggableLayout extends implement(FoldableLayout){
    static  begin(name = 'draggableLayout', params={layoutMode:DEFAULT$3}) {
        return Layout.begin.call(DraggableLayout,name,params);
    }
    order = null;
    originColor = null;
    #clickingTarget = null;

    onOrderChange =_=>{};
    onSelectChange =_=>{};
    constructor(name='unnamed', params){
        super(name, params);
    }
    onSelect(child){
        console.log(child.FullName, 'white');
        child.color = editorSetting.setting.INSPECTOR.autoTileLayout.selectedColor;
    }
    onSelectCancel(child){
        child.color = child.originColor;
    }
    async initialize() {
        await  super.initialize();

        this.originColor = this.color;

        const release = evt => {
            if(draggingTarget == null)
                return;

            clearInterval(interval);

            const emptyIndex = order.findIndex(ele=>ele == null);
            // draggingTarget.transform.Position[0] = 0;
            draggingTarget.Status |= common$1.setting.STATUS.visible;


            order[emptyIndex] = draggingTarget;
            this.Children.values = [this.Children[0], ...order];//[label, ...order]
            this.onOrderChange(this.Children.map(ele=>ele.name));
            this.refresh();
            __setSel(draggingTarget);

            draggingTarget = null;

            Controller.removeEventListener('release', release);
        };
        let draggingTarget = null, localstart = [0,0], originPoint = [0,0], order = [], originalPositions = [], interval;


        const __setSel= target=>{

            if(this.#clickingTarget)
                this.onSelectCancel(this.#clickingTarget);

            this.#clickingTarget = target;
            this.onSelect(this.#clickingTarget);
        };
        this.addEventListener('click',evt=>{

            if(evt.target instanceof Label)
                return evt.preventDefault();

            const target = findDraggableChild(evt.target);
            $assert(target);
            __setSel(target);

            this.onSelectChange(target);

        });

        this.addEventListener('dragstart', evt => {

            //$clearGhostImg(evt, );

            if(evt.target instanceof Label)
                return evt.preventDefault();

            draggingTarget = findDraggableChild(evt.target);
            draggingTarget.Status &= ~common$1.setting.STATUS.visible;
            this.refresh(); //stop rendering draggingTarget



            const controller = $findParentByType(this, Controller);
            $setGhostImg(draggingTarget, controller);

            [originPoint[0],originPoint[1]] = draggingTarget.transform.Position;
            localstart[0] = evt.localX;
            localstart[1] = evt.localY;

            const label = this.Children[0],
                children = this.Children.filter(ele=>ele != label);

            order = children.slice();
            originalPositions = children.map(ele=>ele.transform.Position.slice());
            let index = order.findIndex(ele=>ele&&ele.FullName == draggingTarget.FullName);
            order[index] = null;

            interval = $animate(_=>this.update(order, originalPositions));



            Controller.addEventListener('release', release);

        });




        this.addEventListener('drag', evt => {

            const draggable = findDraggableChild(evt.target),
                deltaX = evt.localX - localstart[0],
                deltaY = evt.localY - localstart[1];

            draggable.transform.Position = [originPoint[0]+deltaX, originPoint[1]+deltaY];
            draggable.transform.update();


        });



        this.addEventListener('over', evt => {

            if(!$isDragging(evt)) return;

            const targetLayout = evt.target instanceof  DraggableLayout?
                evt.target:findDraggableChild(evt.target);



            const index = order.findIndex(ele=>ele&&ele.FullName == targetLayout.FullName),
                emptyIndex = order.findIndex(ele=>ele == null);

            if(index == -1 || !order.length)
                return;


            if(emptyIndex<index){
                order[emptyIndex] = order[emptyIndex+1];
                order[emptyIndex+1] = null;
            }else {

                order[emptyIndex] = order[emptyIndex-1];
                order[emptyIndex-1] = null;

            }




        });

    }

    update(order, targetPositions){
        for(let i=0; i<order.length;i++){
            const child = order[i];
            if(child == null)
                continue;

            child.transform.Position[1] += (targetPositions[i][1] - child.transform.Position[1])/16;
        }

        this.transform.update();

    }


}

class TitleBar extends implement(Label, IDraggable){
    fontParams =  JSON.parse(JSON.stringify(editorSetting.setting.WINDOW.titleBar.fontParams));
    titleColor = null;
    constructor(name='__test',params={}){
        super(name,params);
    }

    async initialize() {
        await  super.initialize();

        this.titleColor = this.color;
        this.layoutMode |= Label.LAYOUT_MODE.resizeX;
    }

    delete(){
        super.delete();
    }



    draw(ctx,cam){
        if(this.Status & common$1.setting.BASIC_STATUS.error){
            this.color = 'red';
        }else
            this.color = this.titleColor;
        super.draw(ctx,cam);
    }
}

//https://stackoverflow.com/questions/48498581/textcontent-empty-in-connectedcallback-of-a-custom-htmlelement
class HTMLBaseElement extends implement(HTMLElement) {

    constructor(...args) {
        // const self = super(...args)
        // self.parsed = false // guard to make it easy to do certain stuff only once
        // self.parentNodes = [];
        // return self
        super(...args);

        // _class[this.constructor.name] = this;
        this.parentNodes = [];
    }
    delete(){

        this.parentNodes = null;

    }

    setup() {
        // collect the parentNodes
        let el = this;
        while (el.parentNode) {
            el = el.parentNode;
            this.parentNodes.push(el);
        }
        // check if the parser has already passed the end tag of the component
        // in which case this element, or one of its parents, should have a nextSibling
        // if not (no whitespace at all between tags and no nextElementSiblings either)
        // resort to DOMContentLoaded or load having triggered
        if ([this, ...this.parentNodes].some(el=> el.nextSibling) || document.readyState !== 'loading') {
            this.childrenAvailableCallback();
        } else {
            this.mutationObserver = new MutationObserver(() => {
                debugger;
                if ([this, ...this.parentNodes].some(el=> el.nextSibling) || document.readyState !== 'loading') {
                    this.childrenAvailableCallback();
                    this.mutationObserver.disconnect();
                }
            });

            this.mutationObserver.observe(this, {childList: true});
        }
    }
}
const ro = new ResizeObserver(async entries=>{

    console.log('===========================');
    for(let entry of entries){
        $assert(entry.target.handleResize);
        console.log(entry.target.name,'resize');
        await entry.target.handleResize(entry);
    }
});

class ContainerElement  extends implement(HTMLBaseElement, IContainer,IHierachy)  {


    // Specify observed attributes so that
    // attributeChangedCallback will work
    static get observedAttributes() {
        return ['c', 'l'];
    }
    #parent = null;
    #children = null;

    status = null;


    set  Status(value){

        this.status = value;
    };
    create(value){
        if(checkStatus$1(this.status, ContainerElement.STATUS.creating) &&
            !checkStatus$1(value, ContainerElement.STATUS.creating)) {
            return Event$1.Instance.emit(common$1.setting.EVT_TYPES.onCreate, this, [this.constructor.name],{writeHistory:false,upload:false})
                .then(_ => {
                    this.status &= ~ContainerElement.STATUS.creating;
                    this.status |= IContainer.STATUS.rendering;
                    this.resize([this.clientWidth,this.clientHeight]);
                    this.drawUI();
                }).catch(kErr => {
                    console.error("onCreated failed", kErr);
                });
        }
    }

    get Status(){return this.status;}
    get FullName(){return this.name;}
    get Name (){return this.name;};

    __DELAY_REFRESH= false;

    constructor(name='__test',params={}) {
        super();

        // this['klass'] = 'window';
        this.name = name;
        this.params = params;
        this.status = IContainer.STATUS.creating|IContainer.STATUS.visible | IContainer.STATUS.active;
        this.#children = createObjList();

        if(params.id)
            this['id'] = params.id;
        // if(params.klass)
        //     this['klass'] = params.klass;



        this.hash = hashCode(this.name);
        this.hashName = hashStr(this.hash);
        this.hashFloat = new Float32Array(this.hash.buffer)[0];

    }

    get Parent(){return this.#parent;}
    get Children(){return this.#children;}
    set Parent(val){this.#parent = val;}
    set Children(val){this.#children = val;}

    delete(){
        this.name = null;
        this.params = null;
        this.#children = null;
        this.#parent = null;

        super.delete();
    }
    set Style(value){
        for(let name in value)
            this.style[name] = value[name];
    }

    async init(){

        $assert(this);
        if(isImplement(this,ILoad))
            LoadManager.addInstance(this);
    }
    registEvt(){
        $assert(this.Controller.Children);
        for(let child of this.Controller.Children)
            child.registEvt();
    }
    initListeners(){
        $assert(this.Controller.Children);
        for(let child of this.Controller.Children)
            child.initListeners();
    }

    connectedCallback() {
        // when connectedCallback has fired, call super.setup()
        // which will determine when it is safe to call childrenAvailableCallback()

        ro.observe(this);
        this.Style = this.params.style;
        this.style['position'] = 'absolute';
        this.style['resize'] = 'both';
        this.style['image-rendering']= 'pixelated';


        super.setup();


    }


    childrenAvailableCallback() {
        // when setup is done, make this information accessible to the element
        // this is useful e.g. to only ever attach event listeners to child
        // elements once using this as a guard;

        return  this.create()
            .then(_=>Event$1.Instance.emit(common$1.setting.EVT_TYPES.onInitialized,this, [this.constructor.name],{writeHistory:false,upload:false}))
            .then(_=>Promise.resolve(this.initialized()))


    }
    static jobs = [];

    resize(size){
    }

    async onCreate(){

        try{
            await this.init();
            this.registEvt();
            this.initListeners();
        }catch(err){
            debugger;
            console.log(err);
            $assert(false, {
                err,
                errorType:common$1.error.ERR_TYPE.internalErr,
                msg:`${this.name} onCreate() failed`
            });
        }

        return Promise.resolve();
    }
    async handleResize(entry){
        $assert(!checkStatus$1(this.status, IContainer.STATUS.creating));
        this.resize([entry.target.clientWidth,entry.target.clientHeight]);
        await this.refresh();
    }




    // Fires when an instance was inserted into the document.
    attachedCallback() {};
    // Fires when an instance was removed from the document.
    detachedCallback() {};
    // Fires when an attribute was added, removed, or updated.
    attributeChangedCallback(attr, oldVal, newVal) {};
}
customElements.define('base-element', ContainerElement);

function $drawErrCell({mode,cellSize,numOfGrids},ctx,col,row,fillStyle){

    ctx.fillStyle = fillStyle;

    $drawCell({mode,cellSize,numOfGrids},ctx,col,row,'fill');
}

function $drawCell(
    {mode= common$1.setting.CANVAS_MODE.regular,cellSize,numOfGrids=[10,10]},
    ctx,col,row, fillMode = 'fill', width = 1, height = 1){
    $assert(mode&&cellSize&&numOfGrids);
    const   p0 = [col,      row],
        p1 = [col+width,   row],
        p2 = [col+width,   row+height],
        p3 = [col,          row+height];
    if(mode & common$1.setting.CANVAS_MODE.isometric){
        const widthGrids = numOfGrids[0];
        $gridIndex2isoScreenPos(p0, p0.slice(), cellSize, widthGrids);
        $gridIndex2isoScreenPos(p1, p1.slice(), cellSize, widthGrids);
        $gridIndex2isoScreenPos(p2, p2.slice(), cellSize, widthGrids);
        $gridIndex2isoScreenPos(p3, p3.slice(), cellSize, widthGrids);
    }else if(mode & common$1.setting.CANVAS_MODE.regular){
        $gridIndex2regularScreenPos(p0, p0.slice(), cellSize);
        $gridIndex2regularScreenPos(p1, p1.slice(), cellSize);
        $gridIndex2regularScreenPos(p2, p2.slice(), cellSize);
        $gridIndex2regularScreenPos(p3, p3.slice(), cellSize);
    }

    ctx.beginPath();
    ctx.moveTo(...p0);
    ctx.lineTo(...p1);
    ctx.lineTo(...p2);
    ctx.lineTo(...p3);
    ctx.closePath();
    if(fillMode == 'fill')
        ctx.fill();
    else
        ctx.stroke();
}

function $genAutoTileImg(source, srcIndex){
    return new Promise(res=>{
        const
            tileData = $getAttr$1(source),
            cellSize = $getNumber(tileData['cellSize']),//$readFileDataValue(`${source}|cellSize`),
            srcX = srcIndex[0]*cellSize,
            srcY = srcIndex[1]*cellSize,
            img = tileData['~rawImg'];
        $assert(img,{path:`${source}|source`});
        return $imgCrop(img, srcX, srcY, cellSize,cellSize).then(canvas=>{
            res(canvas);
        });
    })
}


function $screenPos2RegularIndex(out, pos, cellSize){
    $assert(pos);
    const x = pos[0], y = pos[1];
    [out[0], out[1]]=  [Math.floor(x/cellSize),Math.floor(y/cellSize)];

    $assert($isNumber$1(out[0]));
}

function iso2LocalGrid(out, input, cellSize,numOfGrids){

    const trans = local2isoTrans(cellSize,cellSize);
    invert$3(trans, trans.slice());

    const offsetX = numOfGrids[0]*cellSize*0.5;
    // input[0] -= offsetX;
    transformMat2(out, [input[0]-offsetX, input[1]], trans);
}
function $screenPos2isoIndex(out, pos, cellSize,numOfGrids){
    $assert(pos);
    const localGrid = [0,0];
    iso2LocalGrid(localGrid, pos, cellSize, numOfGrids);
    const [x,y] = localGrid;
    [out[0], out[1]]=  [Math.floor(x),Math.floor(y)];
    out[0].clamp(0,numOfGrids[0]);
    out[1].clamp(0,numOfGrids[1]);

    $assert($isNumber$1(out[0]));
}






// export function $saveChunk(){
//
// }
// export function $saveChunk_sortingGrid(out, paletteData){
//     paletteData['~chunk'] = {};
//     const chunk = paletteData['~chunk'],
//         contents = paletteData['contents'];
//     out.length = 0;
//     const arr = [];
//     for(const indexKey in contents){
//         const [col, row] = $getNumber(indexKey.split(','));
//         if(!arr[col])
//             arr[col] = [];
//         arr[col][row] = contents[indexKey];
//         const boundary = contents[indexKey]['boundary'];
//         if(boundary[2]>1||boundary[3]>1)
//             chunk[indexKey] = boundary;
//     }
//
//
//     genDiagonal(N).forEach(([col,row]) => {
//         if(arr[col]&&arr[col][row])
//             out.push({index:[col,row],data:arr[col][row]});
//     });
// }



// Col 2     deltaY +1       S 1x1
// Col 4     deltaY +2       S 2x2
// Col 8     deltaY +4       S 4x4
function  $isoBottomOffsetY(numOfGridsInX,numOfGridsInY){
    const col =  numOfGridsInX*2,
        row = numOfGridsInY*2,
        offsetY = col/2;
    return (row-offsetY)/row;
    // return numOfGridsInX;
}
function $gridIndex2isoScreenPos(out, index, cellSize, widthGrids){
    const trans = local2isoTrans(cellSize,cellSize);

    transformMat2(out, index, trans);
    const offsetX = widthGrids*cellSize*0.5;
    out[0] += offsetX;
    // debugger;
}

function $gridIndex2regularScreenPos(out, index, cellSize){
    out[0] = index[0]*cellSize;
    out[1] = index[1]*cellSize;
}


//https://www.youtube.com/watch?v=04oQ2jOUjkU&ab_channel=JordanWest
function local2isoTrans(width, height){



    const scale = fromValues$1(width/2, 0, 0,height/2);
    const trans = create$9();
    // const isoMat = mat2.fromValues(1,0.5, -1, 0.5);
    const isoMat = fromValues$1(1,0.5, -1, 0.5);
    multiply$4(trans, scale, isoMat);
    return trans;
}



function $createPattern(canvas, img = canvas,repetition = 'repeat'){
    const ctx = canvas.getContext('2d');
    return ctx.createPattern(img, repetition);

}




// async function bakeTileBrImgs(brushData, index){
//     const
//
//         cellSize = $getNumber(brushData['cellSize']),
//         padding = $getNumber(brushData['padding']),
//         offset = $getNumber(brushData['offset']),
//         imgDataSource = $getFile(brushData['source']).EntryData,
//         srcX = index[0]*cellSize + offset[0] + index[0]*padding[0],
//         srcY = index[1]*cellSize + offset[1] + index[1]*padding[1];
//
//     return await $imgCrop(imgDataSource,srcX, srcY, cellSize,cellSize);
// }


function $selection2Boundary(boundary, selection){
    $assert(Array.isArray(selection[0]));
    let minCOL = Math.maxInt, minROW = Math.maxInt, maxCOL =0, maxROW = 0;
    for (let [col,row] of selection) {
        minCOL = Math.min(minCOL, col);
        minROW = Math.min(minROW, row);
        maxCOL = Math.max(maxCOL, col);
        maxROW = Math.max(maxROW, row);
    }
    boundary[0] = minCOL,
        boundary[1] = minROW,
        boundary[2] = maxCOL-minCOL+1,
        boundary[3] = maxROW-minROW+1;

}

function wrtRuleMatrix(indice, numOfGrids){
    const isInBound = function(index){
            if(index[0]<0||index[1]<0)
                return false;
            if(index[0]>numOfGrids[0]||index[1]>numOfGrids[1])
                return false;
            return true;
        },
        isContain = (index, indice)=>indice.find(ele=>ele.index[0] == index[0] && ele.index[1] == index[1]),
        checkAndPush2Mat = (matrix, curIndex, indice)=>{

            if(isInBound(curIndex) && isContain(curIndex, indice))
                matrix.push(1);
            else
                matrix.push(-1);
        };
    for(const curIndexInfo of indice){
        const
            index = curIndexInfo.index,
            matrix = [];
        //left top ==> mid top ==> right top
        let curIndex = [index[0]-1,    index[1]-1];
        checkAndPush2Mat(matrix, curIndex, indice);
        curIndex = [index[0],         index[1]-1];
        checkAndPush2Mat(matrix, curIndex, indice);
        curIndex = [index[0]+1,        index[1]-1];
        checkAndPush2Mat(matrix, curIndex, indice);

        curIndex = [index[0]-1,           index[1]];
        checkAndPush2Mat(matrix, curIndex, indice);
        matrix.push(0);
        curIndex = [index[0]+1,           index[1]];
        checkAndPush2Mat(matrix, curIndex, indice);


        curIndex = [index[0]-1,         index[1]+1];
        checkAndPush2Mat(matrix, curIndex, indice);
        curIndex = [index[0],         index[1]+1];
        checkAndPush2Mat(matrix, curIndex, indice);
        curIndex = [index[0]+1,         index[1]+1];
        checkAndPush2Mat(matrix, curIndex, indice);

        curIndexInfo.matrix = matrix;
    }

}

function compareMatrix(autoBrMat, paletteMat){
    for(let i=0; i<autoBrMat.length; i++){
        if(autoBrMat[i] * paletteMat[i] == -1)
            return false;
    }
    return true;
}


function $genAutoBrBakingInfo( autoBrPath, palettePath){
    const   autoBrData = $getAttr$1(autoBrPath),
        ruleMatrices = autoBrData['autoTile'].map(ele=>ele.ruleMatrix),
        paletteData = $getAttr$1(palettePath),
        contents = paletteData['.contents'],
        sources = paletteData['sources'],
        numOfGrids = $getNumber(paletteData['numOfGrids']);

    const tiles4Baking = [];
    for(const indexKey in contents){
        const {srcIndex} = contents[indexKey],
            index = $getNumber([...indexKey.split(',')]);

        if(sources[srcIndex]['source'] === autoBrPath)
            tiles4Baking.push({source:autoBrData['source'],index, matrix:null,boundary:null,ruleRankIndex:null});//contentIndex:i
    }

    wrtRuleMatrix(tiles4Baking, numOfGrids);

    for(const paletteMat of tiles4Baking){
        for(const index in ruleMatrices){
            if(compareMatrix(ruleMatrices[index], paletteMat.matrix)){
                paletteMat.ruleRankIndex = index;
                paletteMat.boundary = autoBrData['autoTile'][index].boundary;
                break;
            }
        }
        if(!$isNumber$1(paletteMat.ruleRankIndex)){
            paletteMat.ruleRankIndex = 0;
            paletteMat.boundary = autoBrData['autoTile'][0].boundary;
        }
    }
    return tiles4Baking.map(({source,boundary, index,ruleRankIndex})=>{return {source,boundary, index}});


}

function $boundary2ImgPreview(boundary,cellSize,rawImg){
    boundary = $genBoundary(boundary);

    const   canvas = document.createElement('canvas'),
        ctx = canvas.getContext('2d'),
        pos = [boundary[0]*cellSize, boundary[1]*cellSize];

    canvas.width = cellSize*(boundary[2]);
    canvas.height = cellSize*(boundary[3]);
    try{
        if(rawImg){
            ctx.drawImage(rawImg, ...pos, canvas.width, canvas.height, 0,0, canvas.width,canvas.height);
        }else
            $genImgPreviewErr(canvas);}catch (e){debugger;}
    return canvas;
}
function $genImgPreviewErr(canvas){
    const   ctx = canvas.getContext('2d');
    ctx.fillStyle = 'black';
    ctx.fillRect(0,0,canvas.width,canvas.height);
}

class UIPanel extends implement(ContainerElement)  {


    get Width(){return this.canvasDiv.width;}
    get Height(){return this.canvasDiv.height;}




    canvasDiv = null;
    ctx = null;
    pattern = null;
    constructor(...args) {
        super(...args);
    }


    clear(){

        let children = this.Controller.Children;
        for (let i = children.length - 1; i >= 0; i--) {
            let child = children[i];
            this.Controller.Children.delete(child);
            child.delete();
        }

    }
    delete(){

        this.canvasDiv = null;
        this.ctx = null;

        // for(let child of this.Children.array)
        //     child.delete();
        super.delete();
    }

    async init(){
        await super.init();
        this.canvasDiv = document.createElement('canvas');
        this.canvasDiv.setAttribute('editorName', this.name);
        this.canvasDiv.setAttribute('editorType', this.constructor.name);
        this.ctx = this.canvasDiv.getContext('2d');

        await this.appendChild(this.canvasDiv);


        // this.canvasDiv.draggable ='true';
        // let camera = new Camera2d(this.name+'-camera');
        // camera.Parent = this;
        // camera.initialize();
        // this.Children.push(camera);


        let controller = new Controller('controller',{div:this.canvasDiv});
        controller.Parent = this;
        this.Children.push(controller);
        await controller.initialize();

    }
    get CanvasDiv(){return this.canvasDiv;}

    get Controller(){
        return this.Children['controller'];
    }
    // get Camera2d(){return this.Children[this.name+'-camera'];}

    resize(size){
        const [width,height] = size;
        super.resize(size);
        this.canvasDiv.width = width;
        this.canvasDiv.height = height;

        this.Controller.Width = this.canvasDiv.width;
        this.Controller.Height = this.canvasDiv.height;

    }



    onActive(fnc, isRefreshing = false){
        if(fnc) {
            const isArrowFnc = isArrowFn(fnc),
                isAsyncFnc = isAsyncFn(fnc);

            if (isArrowFnc){
                if(isAsyncFnc)
                    return async (..._) => {
                        const result= await fnc(..._);
                        this.status |= UIPanel.STATUS.rendering;
                        return result;
                    };
                else
                    return (..._) => {
                        this.status |= UIPanel.STATUS.rendering;
                        return fnc(..._);
                    };

            } else {//!isArrowFnc
                if(isAsyncFnc)
                    return async function (..._) {

                        const result= await fnc(..._);

                        const evt = _[0],
                            subscriber = evt.subscriber;
                        if(evt.type == '@onControllerAttached'){
                            if(!subscriber)
                                debugger;
                            else
                                debugger;
                        }
                        $assert(subscriber,{msg:'fnc onActive needs subscriber'});
                        subscriber.Status |= UIPanel.STATUS.rendering;
                        return result;
                    }


                else
                    return function (..._) {

                        const evt = _[0],
                            subscriber = evt.subscriber;
                        $assert(subscriber,{msg:'fnc onActive needs subscriber'});
                        subscriber.Status |= UIPanel.STATUS.rendering;
                        return fnc(..._);
                    }


            }
        }else
            this.status |= UIPanel.STATUS.rendering;


    }


    drawUI() {

        if(checkStatus$1(this.Status, UIPanel.STATUS.rendering)||
            checkStatus$1(this.Status, UIPanel.STATUS.animation)
        ) {
            this.ctx.clearRect(0, 0, this.canvasDiv.width, this.canvasDiv.height);
            this.ctx.fillStyle = editorSetting.setting.WINDOW.color;
            this.ctx.fillRect(0, 0, this.canvasDiv.width, this.canvasDiv.height);

            if(this.pattern)
                this.ctx.fillStyle = this.pattern;
            this.ctx.fillRect(0, 0, this.canvasDiv.width, this.canvasDiv.height);
            this.draw();
            if( !checkStatus$1(this.Status,UIPanel.STATUS.focus))
                this.Status &= ~UIPanel.STATUS.rendering;
        }



        if(checkStatus$1(this.Status, UIPanel.STATUS.visible))
            window.requestAnimationFrame(() => {

                if(checkStatus$1(this.Status, UIPanel.STATUS.visible)){
                    this.drawUI();
                }
            });
    }

    clear(){
        // this.onClear();
        this.Controller.clear();

    }




    static async  onLoad(){
        if(!editorSetting.setting.WINDOW.hasPattern)
            return Promise.resolve(null);

        const img = document.getElementById('keanuSrc'),
            imgBoundary = editorSetting.setting.WINDOW.patternSrcBoundary.slice(),
            patternSize = editorSetting.setting.WINDOW.patternSize.slice();
        const patternCanvas =  await $imgCrop( img,  ...imgBoundary,...patternSize);
        const pattern = $createPattern(patternCanvas, patternCanvas,'repeat');

        return Promise.resolve(pattern);
    }
    onFinishLoad(data){
        this.pattern = data;
    }



}
customElements.define('panel-element', UIPanel);

class KImage extends implement(Component, IImage){

    shinningSpeed = null;

    mode = KImage.MODE.image;
    get Mode(){return this.mode;}
    set Mode(val){
        // if(!(this.mode & KImage.MODE.colorFilterAnimation) && val &KImage.MODE.colorFilterAnimation){
        //     debugger;
        // }
        // if(this.mode & KImage.MODE.colorFilterAnimation && !(val &KImage.MODE.colorFilterAnimation)){
        //     debugger;
        // }


        this.mode = val;
    }

    img = null;
    set Image(value){
        this.img = value;
        if(value)
            this.imgSrcBoundary =  [0,0,this.img.width,this.img.height];
    }

    imgSrcBoundary = null;
    set ImgSrcBoundary(val){
        this.imgSrcBoundary = val;
    }

    constructor(name='__test',params={}){
        super(name,params);
        this.status |= common$1.setting.BASIC_STATUS.visible;
    }

    async initialize(){
        await  super.initialize();
        this.Image = this.params.img??null;
        this.Mode = this.params.mode??KImage.MODE.image;
        if(this.Image)
            this.Ratio = this.params.ratio?? this.Image.width/this.Image.height;
        this.shinningSpeed = this.params.shinningSpeed?? editorSetting.setting.COMPONENTS.image.shinningSpeed;
    }


    delete(){
        super.delete();
        this.img = null;
        this.imgSrcBoundary = null;
    }


    draw(ctx,cam){

        if(!(this.img))
            return;

        if(this.mode & KImage.MODE.background){
            ctx.fillStyle = this.color;
            ctx.fillRect(this.boundary[0],this.boundary[1],this.boundary[2],this.boundary[3]);
        }


        if(this.mode & KImage.MODE.colorFilterAnimation){
            const timeElapsed = Date.now()/1000;
            ctx.filter = `brightness(${(Math.sin(timeElapsed * this.shinningSpeed) + 2) * 0.5})`;
        }

        // ctx.fillStyle = 'yellow';
        // ctx.fillRect(this.boundary[0],this.boundary[1],this.boundary[2],this.boundary[3]);



        ctx.drawImage(this.img,
            this.imgSrcBoundary[0], this.imgSrcBoundary[1], this.imgSrcBoundary[2], this.imgSrcBoundary[3],
            this.boundary[0],this.boundary[1],this.boundary[2],this.boundary[3]);


        // if(this.drawHandler)
        //     this.drawHandler(ctx,cam);

    }
}

class UIWindow extends implement(UIPanel, IWindow,ILoad, IPanelContainer) {
    static windows = [];

    static TOOL_MODE = common$1.setting.TOOL_MODE;

    title = null;
    body  = null;
    startPos= null;
    position4Style = null;

    // rootLayout = null;
    mainLayout = null;
    touchOrigin = null;

    renderables = [];
    get Renderables(){return this.renderables;}

    bodyHighLightImgAlpha = editorSetting.setting.WINDOW_BODYLIGHTALPHA;

    get Body(){return this.body;}

    get Title(){
        return this.title;
    }
    get Content (){
        return this.mainLayout.Children[1]?this.mainLayout.Children[1]:null;
    }

    get MainLayout(){
       return this.mainLayout;
    }
    fontParams =  JSON.parse(JSON.stringify(editorSetting.setting.WINDOW.fontParams));

    get Font(){


        return (this.fontParams.bold?'bold ':'') + this.fontParams.size + "px "+ this.fontParams.font;
    }

    constructor(...args) {
        super(...args);
        this.position4Style = this.params.position ?? [0,0,0];
        this.titleHeight = this.params.titleHeight?? editorSetting.setting.WINDOW.titleHeight;

        this.titleColor = this.params.titleColor?? editorSetting.setting.WINDOW.titleColor;

        const refresh = this.refresh;
        this.refresh =async _=>{

            if(this.__DELAY_REFRESH == true)
                return;

            if(this.status & common$1.setting.BASIC_STATUS.deleting)
                return;
            if(this.status & common$1.setting.BASIC_STATUS.creating)
                return;
            if(this.status & common$1.setting.BASIC_STATUS.loading)
                return;

            this.status |= common$1.setting.BASIC_STATUS.rendering;

           return await refresh.call(this);
        };
        if(this.name != '__test')
            IWindow.Windows.push(this);
    }
    delete(){

        super.delete();

        IWindow.Windows = IWindow.Windows.filter(ele=>this.name == ele.name);

        this.title = null;
        this.startPos = null;
        this.position4Style = null;
        this.touchOrigin = null;
        // this.rootLayout = null;
        this.mainLayout = null;


        this.renderables.length = 0;
        this.highlightImg = null;
    }
    clear(){
        super.clear();
        return this.Content.clear();//async
    }

    async active(){
        const editorName = this.constructor.name,
            controller = this.Controller;

        if(!(controller.Status & common$1.setting.CTRL_STATUS.active)){
            await Event$1.Instance.emit(common$1.setting.EVT_TYPES.focus,[editorName]);
        }
    }

    async init(){
        await super.init();


        this.strokeColor = this.params.strokeColor??'rgba(0,0,0,0)';//editorSetting.setting.WINDOW.outlineStrokeColor
        this.lineWidth = this.params.lineWidth??0; //editorSetting.setting.WINDOW.outlineStrokeWidth
        this.boxShadow = this.params.boxShadow??editorSetting.setting.WINDOW.boxShadow;

        UIWindow.windows.push(this);
        let root = $findRoot(this);
        if(root&&!window.Keanu.editors.exist(root.name))
            window.Keanu.editors.push(root);


        // if( window.config['vr'])
        //     this.style["display"] = "none";

        //this.CanvasDiv.setAttribute('draggable', true);


        setPosition(this,this.position4Style);

        //https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/tabindex
        //https://stackoverflow.com/questions/12886286/addeventlistener-for-keydown-on-canvas?noredirect=1&lq=1
        //https://stackoverflow.com/questions/3656467/is-it-possible-to-focus-on-a-div-using-javascript-focus-function
        this.setAttribute('tabindex',-1);

        // //////////////
        // ///root //////
        // //////////////
        // this.rootLayout = new Layout('rootLayout',{
        //     layoutMode:Layout.LAYOUT_MODE.vertical|Layout.LAYOUT_MODE.resizeX|Layout.LAYOUT_MODE.resizeY,
        //     margin:{left:0,right:0,top:0,bottom:0}
        // });
        // this.Controller.appendChild(this.rootLayout);
        // this.rootLayout.initialize();


        //////////////
        ///main //////
        //////////////
        this.mainLayout = new Layout('mainLayout',{
            margin:editorSetting.setting.WINDOW.margin,
            marginColor:editorSetting.setting.WINDOW.marginColor,
            layoutMode:Layout.LAYOUT_MODE.vertical|Layout.LAYOUT_MODE.resizeX|Layout.LAYOUT_MODE.resizeY,
        });
        // this.rootLayout.appendChild(this.mainLayout);
        await this.Controller.appendChild(this.mainLayout);
        await this.mainLayout.initialize();
        // Layout.linkHierachy(this.rootLayout, this.mainLayout);


        //////////////
        ///title /////
        //////////////
        this.title = new TitleBar('title', {
            color:this.titleColor,
            height:this.titleHeight,
            strokeColor:editorSetting.setting.WINDOW.outlineStrokeColor,
            lineWidth:editorSetting.setting.WINDOW.outlineStrokeWidth,
            marginColor:editorSetting.setting.WINDOW.marginColor,
            margin:{left:0,right:0,top:0,bottom:editorSetting.setting.WINDOW.margin},
        });
        await this.mainLayout.appendChild(this.title);
        await this.title.initialize();
        Layout.linkHierachy(this.mainLayout, this.title);

        this.title.addEventListener("over",evt=>{
            if($isDragging(evt)) return;
            document.body.style.cursor = 'move';
        });
        this.title.addEventListener("out",evt=>{
            if($isDragging(evt)) return;
            document.body.style.cursor = 'default';
        });

        //////////////
        ///body  /////
        //////////////
        this.body = new Layout('body', {
            layoutMode:Layout.LAYOUT_MODE.vertical|Layout.LAYOUT_MODE.resizeX|Layout.LAYOUT_MODE.resizeY
        });
        await this.mainLayout.appendChild(this.body);
        await this.body.initialize();
        Layout.linkHierachy(this.mainLayout, this.body);

        const RESIZE_ZONE = [30,30],
            __isInTheZone = evt=>{
                const isInBottomRight =
                        this.body.Width - evt.localX < RESIZE_ZONE[0]&&
                        this.body.Height - evt.localY < RESIZE_ZONE[1],
                    isInBottomLeft = evt.localX<RESIZE_ZONE[0]&&
                        this.body.Height - evt.localY < RESIZE_ZONE[1];

                if(isInBottomRight) return 1;
                if(isInBottomLeft) return -1;

                return null;
            };

        //http://www.javascripter.net/faq/stylesc.htm
        this.body.addEventListener("move",evt=>{
            if($isDragging(evt)) return;


            const isZone = __isInTheZone(evt);
            if(isZone== null)
                document.body.style.cursor = 'default';
            else if(isZone === 1)
                document.body.style.cursor = 'se-resize';
            else if(isZone === -1)
                document.body.style.cursor = 'sw-resize';

        });



        this.body.addEventListener("enter",evt=>{
            if($isDragging(evt)) return;

            document.body.style.cursor = 'default';
            console.log('body enter');
        });
        this.body.addEventListener("leave",evt=>{
            if($isDragging(evt)) return;

            document.body.style.cursor = 'default';
            console.log('body leave');
        });

         this.body.addEventListener("press",evt=>{
            if(__isInTheZone(evt) == null) return;
            this.onDragResize(evt);
            evt.stopImmediatePropagation();
        });

        this.toolBoxLayout = new Layout('toolBoxLayout', {
            color:  editorSetting.setting.WINDOW.toolBoxColor,
            strokeColor:editorSetting.setting.WINDOW.outlineStrokeColor,
            lineWidth:editorSetting.setting.WINDOW.outlineStrokeWidth,
            layoutMode:Layout.LAYOUT_MODE.horizontal|Layout.LAYOUT_MODE.resizeX,
            height:editorSetting.setting.WINDOW.toolBoxHeight
        });

        await this.body.appendChild(this.toolBoxLayout);
        await this.toolBoxLayout.initialize();
        Layout.linkHierachy(this.body, this.toolBoxLayout);



    }
    onDragResize(evt){
        //calculate localSpace size change
        const
            _initPosX = Math.round(evt.localX),
            _initPosY = Math.round(evt.localY),
            _initWidth = this.Width,
            _initHeight = this.Height,
            _move = evt=>{
                $screenCoord2Local(evt, this.body);
                const   deltaX = Math.round(evt.localX) - _initPosX,
                        deltaY = Math.round(evt.localY) - _initPosY,
                        width = _initWidth + deltaX,
                        height = _initHeight + deltaY;


                this.style.width = `${width}px`;
                this.style.height = `${height}px`;

            },_stop = evt=>{
                Controller.removeEventListener('move', _move);
                Controller.removeEventListener('release', _stop);
            };

        console.log('add move');
        Controller.addEventListener("release", _stop);
        Controller.addEventListener("move", _move);
    }
    static clearOtherInput = evt=> {
        const results = $captureDeep(evt);
        if(results.length == 0) return;

        $assert(results.length == 1);

        const {fullName, offset} = results[0],
            editingFullName4exclude = fullName;

        if(KeyBoard.clearHandlers(editingFullName4exclude)){
            evt.stopImmediatePropagation();
            evt.preventDefault();
        }
    };
    static clearAllInput= evt=>{
        Controller.keyboard.clearHandler();
        // evt.stopImmediatePropagation();
        //evt.preventDefault();
    };



    initListeners(){
        super.initListeners();

        // //mousedown ==> click  ==> dblclick
        if(!Controller.checkEventListener("press", UIWindow.clearOtherInput))
            Controller.addEventListener("press",UIWindow.clearOtherInput,{capture:true});

        if(!Controller.checkEventListener("drop", UIWindow.clearOtherInput))
            Controller.addEventListener('drop',UIWindow.clearOtherInput,{capture:true});

        if(!Controller.checkEventListener("menu", UIWindow.clearAllInput))
            Controller.addEventListener("menu",UIWindow.clearAllInput,{capture:true});


        const titlePos = 32;
        this.Title.addEventListener('mouseover', evt=>{
            this.titleHighlightOffset = 0;

            this.Title.Status |= common$1.setting.BASIC_STATUS.animation;
            $animate(_=>{
                this.titleHighlightOffset += (titlePos - this.titleHighlightOffset)/20;

            },16.6,100,_=>
                this.Title.Status &= ~common$1.setting.BASIC_STATUS.animation);
        });

        this.Title.addEventListener('mouseout', evt=>{
            this.titleHighlightOffset = 0;
        });





        this.Title.addEventListener('dragstart',evt=>{

            this.startPos = this.position4Style.slice();
            this.touchOrigin = [evt.clientX,evt.clientY];

        });


        this.Title.addEventListener( 'drag',evt=>{
            this.moveWindow(evt);
        });

        this.mainLayout.addEventListener('drop',async evt=>{
            if(!evt.dataTransfer||!evt.dataTransfer.items)
                return;

            const item = evt.dataTransfer.items[0],
                file = evt.dataTransfer.files[0];

            if(!file) return;

            evt.originalEvt.preventDefault();//preventing open new tab for dropped file

            // If dropped items aren't files, reject them
            if (/\.sim/.test(file.name)){
                evt.stopPropagation();
                const str = await item.getAsFile().text(),
                    simHistory = JSON.parse(str);
                this.Controller.startEmulation(simHistory);
            }else  if (/\.keanu/.test(file.name)){
                evt.stopPropagation();


                const str = await item.getAsFile().text(),
                    snapshot =  JSON.parse(str),
                    stackHistory = snapshot.history??[];
                if(stackHistory.length)
                    $batchEmit(stackHistory);
                else {

                    await GUI$1.$clearWindows();

                    $projEnd(window.config.project);//clear opened proj
                    await $projBegin(window.config.project,snapshot.files);
                    debugger;
                    const outline =  Keanu.editors.array.find(ele=>ele.constructor.name === 'Outline'),
                            palette = Keanu.editors.array.find(ele=>ele.constructor.name === 'Palette');
                    if(outline){
                        await GUI$1.$REFRESH_LOCK_BEGIN(outline);
                        await initOutline(outline,snapshot.files);
                        await GUI$1.$REFRESH_LOCK_END(outline);
                    }else if(palette){
                        const paletteFiles = getFiles().map(ele=>ele.path).filter(ele=>/\.palette/.test(ele)),
                            file = paletteFiles.find(ele=>$readPath(ele).fileNm === window.config.palette);

                        if(file)
                            palette.open($path2ID(file));

                    }

                    $loadProcess();

                }
            }


        },{capture:false});



    }


    onErrorFixed(evt, ...params){

    }
    onError(evt, path){

    }



    registEvt(){
        super.registEvt();


        this.Event.on(common$1.setting.EVT_TYPES.onErrorFixed, (evt,...params)=>this.onErrorFixed(...params), {subscriber:this});
        this.Event.on(common$1.setting.EVT_TYPES.onError, this.onActive((evt,...params)=>this.onError(...params)),{subscriber:this});

        // this.Event.on(common.setting.EVT_TYPES.onClear, this.onActive(async function(evt){
        // }),{subscriber:this,index:-1});
        Event$1.Instance.onUnicon(common$1.setting.EVT_TYPES.onClear,async function(evt){
            const target = evt.publisher;
            //
            if(target)
                await target.clear();
            else
                await GUI$1.$clearWindows();
            // else
            //     for(const editor of window.Keanu.editors.array)
            //         await editor.clear();
        },{index:-1});


        editorSetting.setting.WINDOW_BODYLIGHTALPHA;

        // this.Content.addEventListener("over", _=>{
        //     this.bodyHighLightImgAlpha = 0;
        //     this.status |= common.setting.CTRL_STATUS.active;
        //     this.status |= common.setting.STATUS.animation;
        // });
        // this.Content.addEventListener("out", _=> {
        //     this.bodyHighLightImgAlpha = HIGHTLIGHT_ALPHA;
        //     this.Status &= ~common.setting.CTRL_STATUS.active;
        //     this.Status &= ~common.setting.STATUS.animation;
        // });



        Event$1.Instance.onUnicon(common$1.setting.EVT_TYPES.focus, function(evt, fullName){
            const isWin = !/\//.test(fullName);
            if(isWin){
                const win = Keanu.editors.objs[fullName];
                if(win)
                    $activateWindow(win);
            }
        });


        Event$1.Instance.onUnicon(common$1.setting.EVT_TYPES.onControllerDetached, function (evt, controller){
            const detachedTarget = evt.publisher;
            $assert(detachedTarget.FullName);



            //refresh ListLayout
            const finder = [],
                targetNames = detachedTarget.FullName.split('/'),
                parentNames = targetNames.slice(0,targetNames.length-1);
            const parent = $findByFullName(parentNames.join('/'));
            findParentsOf(finder, parent,
                ele => isImplement(ele, IPanelContainer),
                ele=>ele.Parent
            );
            $assert(finder.length);
            const win = finder[finder.length-1];
            if(win.__DELAY_REFRESH)
                return;
            finder[0].refresh();
        });
    }


    refreshTitle(txt){
        if(!txt)  this.Title.Text = this.constructor.name;
        else this.Title.Text = `${txt}`;

    }

    moveWindow(evt){
        const touch = [evt.clientX,evt.clientY];
        this.position4Style[0] = this.startPos[0] + touch[0]-this.touchOrigin[0];
        this.position4Style[1] = this.startPos[1] + touch[1]-this.touchOrigin[1];


        setPosition(this,this.position4Style);

    }

    resize(size){
        super.resize(size);
        this.mainLayout.resize(size);
        this.refresh();
    }
    initialized(){};

    beforeRefreshHandlers = [];
    get BeforeRefreshHandlers(){return this.beforeRefreshHandlers;}

    async beforeRefresh(){
        if(this.BeforeRefreshHandlers&&this.BeforeRefreshHandlers.length)
            for(const {caller,fnc} of this.BeforeRefreshHandlers){
                await fnc.call(caller);
            }
    }
    refresh(){

        this.Controller.refresh();
        if(this.mainLayout.Status & common$1.setting.STATUS.deleting){
            this.Renderables.length = 0;
            return;
        }
        this.mainLayout.refresh();

        const condition = child=> isImplement(child, IDrawable)&&
                checkStatus$1(child.Status,common$1.setting.STATUS.visible),
            renderable = depthFirstSearch(this.Controller,condition);


        const renderableFiltered = renderable.filter(ele=>getParentsOf(ele).findIndex(ele=>ele.Status & common$1.setting.STATUS.clippingWindow) == -1);


        this.Renderables.length = 0;
        this.Renderables.push(...renderableFiltered.sort((a,b)=>a.RenderIndex-b.RenderIndex));


    }

    draw(){
        // this.ctx.imageSmoothingQuality = "low";
        this.ctx.imageSmoothingEnabled = false;

        this.Renderables.forEach(ele=>{
            if((ele.Status & common$1.setting.STATUS.deleting) || (ele.Status & common$1.setting.STATUS.deleted))
                return;
            ele.preDraw(this.ctx);
            ele.draw(this.ctx);
            ele.postDraw(this.ctx);
        });

        if((this.Title.Status & common$1.setting.STATUS.deleted) ||  (this.Title.Status & common$1.setting.STATUS.deleting))
            return;
        const titleWidth = this.Title.Width,titleHeight = this.Title.Height;

        this.ctx.save();

        this.ctx.globalCompositeOperation = 'screen';

        this.ctx.globalAlpha = this.bodyHighLightImgAlpha;


        const offset = $isNumber$1(this.titleHighlightOffset)?this.titleHighlightOffset: 8,
            y = this.mainLayout.Margin.top;
        this.ctx.drawImage(this.highlightImg,
            offset,0,titleWidth+offset,titleHeight,
            0,y,titleWidth,titleHeight);


        this.ctx.restore();


        strokeOutline(this.ctx, this.Width,this.Height,this.strokeColor, this.lineWidth);

    }


    curToolMode = 0;
    get ToolMode(){
        return this.curToolMode;
    }

    set ToolMode(val){
        this.curToolMode = val;
    }
    toolIcons = {};

    async initToolBox(){
        const toolSize = editorSetting.setting.WINDOW.toolBoxHeight,
            color = editorSetting.setting.WINDOW.toolBoxSelectedColor;
        const TOOLS = editorSetting.setting.TOOLS_BOX[this.constructor.name]??[];
        for(const toolNm of TOOLS){
            const tool = new KImage(toolNm, {
                img:this.toolIcons[toolNm],
                mode:KImage.MODE.image,
                ratio:1,
                width:toolSize,
                color,
                layoutMode:Layout.LAYOUT_MODE.resizeY|Layout.LAYOUT_MODE.lockRatio
            });
            tool.addEventListener('click',evt=>{
                const cmd = toolNm;
                this.onUIActionStart(cmd);
                this.onUIActionEnd(cmd);
            });
            await this.toolBoxLayout.appendChild(tool);
            await  tool.initialize();
            Layout.linkHierachy(this.toolBoxLayout, tool);
        }
    }


    static async  onLoad(){
        const img = document.getElementById('keanuSrc'),
            imgBoundary = editorSetting.setting.WINDOW.highlightSrcBoundary.slice();
        let highlightImg =  await $imgCrop( img,  ...imgBoundary);//await
        highlightImg = await highlightShadow(45,highlightImg ,
            [0,0,editorSetting.setting.MAX_WIDTH,editorSetting.setting.MAX_HEIGHT]);


        return Promise.resolve({highlightImg});

    }
    onFinishLoad({highlightImg}){
        this.highlightImg = highlightImg;
    }
}
customElements.define('ui-window', UIWindow);

class UISlider extends implement(Component){

    length = null;
    sliderBlock = null;
    constructor(name='__test',params={layoutMode:common$1.setting.LAYOUT_MODE.vertical}){
        super(name,params);
    }

    get Block(){return this.sliderBlock;}
    set SliderLengthValue(val){
        this.length = this.LayoutMode & common$1.setting.LAYOUT_MODE.vertical?
            val*this.boundary[3]:val*this.boundary[2];

        this.length = Math.floor(this.length);

        if(this.LayoutMode & common$1.setting.LAYOUT_MODE.vertical)
            this.sliderBlock.Height = this.length;
        else
            this.sliderBlock.Width = this.length;
    }

    get Width(){return this.boundary[2];}
    set Width(value){
        super.Width = value;
        // if(this.sliderBlock)
        // this.sliderBlock.Width = value;
    }

    get Height(){return this.boundary[3];}
    set Height(value){
        super.Height = value;
        // if(this.sliderBlock)
        // this.sliderBlock.Height = value;
    }




    set Value (val) {
        let offset = val*(
            ( this.LayoutMode & common$1.setting.LAYOUT_MODE.vertical? this.boundary[3]:this.boundary[2])
            - this.length),
            pos = this.sliderBlock.transform.Position.slice();

        if(this.LayoutMode & common$1.setting.LAYOUT_MODE.vertical)
            pos[1] = offset;
        else
            pos[0] = offset;

        this.sliderBlock.transform.Position = pos;
    }



    async initialize(){


        await super.initialize();


        this.posX = this.params.posX;
        this.posY = this.params.posY;
        const MODE = Layout.LAYOUT_MODE,
            layoutMode = MODE.resizeX|MODE.resizeY;//(this.params.layoutMode&MODE.resizeX)?
        this.sliderBlock = new Component(this.name+'_sliderBlock', {
            layoutMode,
            margin:1,
            color:editorSetting.setting.WINDOW.slider.color,
        });
        await this.appendChild(this.sliderBlock);
        await this.sliderBlock.initialize();
        this.sliderBlock.RenderIndex = 2;

        this.sliderBlock.draw = (ctx)=>{
            const radius = editorSetting.setting.WINDOW.slider.radius;
            ctx.fillStyle = editorSetting.setting.WINDOW.slider.color;
            ctx.strokeStyle = editorSetting.setting.WINDOW.slider.strokeColor;
            ctx.lineWidth = 1;
            roundRect(ctx, 0,0,this.sliderBlock.Width, this.sliderBlock.Height, radius, true,true);
        };

        this.addEventListener("over", evt => {
            // this.status |= common.setting.BASIC_STATUS.selecting;

        });
        this.addEventListener("out", evt => {

            // this.Status &= ~common.setting.BASIC_STATUS.selecting;

        });


    }



    delete(){


        super.delete();

    }


}

class Scrollable extends implement(Component,ILayout,IDrawable){

    layoutH = null;
    verticalSlider = null;
    horizontalSlider = null;
    listLayout = null;


    #top = null;
    #bottom = null;
    #left = null;
    #right = null;
    #targetScrollValueX = null;
    #targetScrollValueY = null;

    get VerticalSlider() {
        return this.verticalSlider;
    }

    get HorizontalSlider(){
        return this.horizontalSlider;
    }

    renderables = [];
    get Renderables(){return this.renderables};

    constructor(name='unnamed', params={layoutMode:Layout.LAYOUT_MODE.vertical|Layout.LAYOUT_MODE.resizeX|Layout.LAYOUT_MODE.resizeY}) {
        super(name, params);
    }

    // get ContentLayout(){return this.listLayout;}

    async initialize() {
        await super.initialize();
        initialize(this);

        //////////////////////////////////////////////////////////////
        //------------------- ==== thisLayoutV////////////////////////
        //     bodyLayoutH                                     ///////
        // ==================                                  ///////
        // Content  |   ||                                     ///////
        //   |      |   ||                                     ///////
        //   |      |   ||                                     ///////
        //   |      | SLIDER                                   ///////
        //   |      |   ||                                     ///////
        //   |      |   ||                                     ///////
        // Content  |   ||                                     ///////
        // ==================                                  ///////
        // ==== SLIDER =======                                 ///////
        ///////////////////////==== thisLayoutV///////////////////////
        //////////////////////////////////////////////////////////////


        const name = this.name;
        this.layoutH = new Layout('bodyLayoutH', {
                layoutMode:Layout.LAYOUT_MODE.horizontal|Layout.LAYOUT_MODE.resizeX|Layout.LAYOUT_MODE.resizeY
            });
        this.verticalSlider = new UISlider('verticalSlider',{
                color:editorSetting.setting.WINDOW.slider.backgroundColor,
                layoutMode:Layout.LAYOUT_MODE.vertical|Layout.LAYOUT_MODE.resizeY,
                width:editorSetting.setting.SCROLL_BARSIZE
            });
        this.horizontalSlider = new UISlider('horizontalSlider',{
                color:editorSetting.setting.WINDOW.slider.backgroundColor,
                layoutMode:Layout.LAYOUT_MODE.horizontal|Layout.LAYOUT_MODE.resizeX,
                height:editorSetting.setting.SCROLL_BARSIZE
            });
        this.listLayout = new ListLayout(name+'-content-layout');

        this.verticalSlider.RenderIndex = 1;


        // this.appendChild(this.layoutH);
        // this.appendChild(this.horizontalSlider);

        //HARD CODE FIX////////////////////START
        uiAddChild.call(this, this.layoutH);
        uiAddChild.call(this, this.horizontalSlider);
        const controller = $findParentByType(this, Controller);
        if(controller) {
            await Event$1.Instance.emit(common$1.setting.EVT_TYPES.onControllerAttached, this.layoutH, [controller]);
            await Event$1.Instance.emit(common$1.setting.EVT_TYPES.onControllerAttached, this.horizontalSlider,[controller]);
        }
        //HARD CODE FIX////////////////////END


        await this.layoutH.appendChild(this.listLayout);
        await this.layoutH.appendChild(this.verticalSlider);

        await this.listLayout.initialize();
        await this.horizontalSlider.initialize();
        await this.verticalSlider.initialize();
        await this.layoutH.initialize();


        Layout.linkHierachy(this, this.layoutH);
        Layout.linkHierachy(this, this.horizontalSlider);
        Layout.linkHierachy(this.layoutH, this.listLayout);
        Layout.linkHierachy(this.layoutH, this.verticalSlider);






    }


    initListeners(){
        this.addEventListener('gesture', evt=>{
            this.onScrollCanvas(evt.deltaX,evt.deltaY);
        });


        let value = 0;
        this.verticalSlider.addEventListener('click',evt=>{
            const isSliderBlock = evt.target instanceof UISlider,
                blockPos = this.verticalSlider.Block.transform.position[1],
                dir = evt.localY>blockPos?1:-1;
            if(isSliderBlock)
                this.onScrollCanvas(0,100*dir,1);
        });
        this.verticalSlider.Block.addEventListener('dragstart',evt=>{
            //dont prevent, dont skip drag
            // evt.originalEvt.preventDefault();
            // evt.preventDefault();
            value = evt.localY;
        });

        this.verticalSlider.Block.addEventListener('drag', evt=>{
            const dir = evt.localY>value?1:-1;
            this.onScrollCanvas(0,dir,1);
        });
        
        this.horizontalSlider.Block.addEventListener('dragstart',evt=>{
            value = evt.localX;
        });
        this.horizontalSlider.Block.addEventListener('drag', evt=>{
            const dir = evt.localX>value?1:-1;
            this.onScrollCanvas(0,dir,1);
        });
    }

    #dragstartPos
    updateSlider(){
        const sliderSize = editorSetting.setting.SCROLL_BARSIZE;
        //SCALE SLIDER
        let xProportion = (this.listLayout.Width+sliderSize) / this.listLayout.group.Width,
            yProportion = (this.listLayout.Height+sliderSize) / this.listLayout.group.Height;

        xProportion = xProportion.clamp(0,1);
        yProportion =yProportion.clamp(0,1);

        this.HorizontalSlider.SliderLengthValue = xProportion;
        this.VerticalSlider.SliderLengthValue = yProportion;
    }
    refresh(children = this.Children){
        refresh(this,children);
        this.updateSlider();


    }
    resize(size=[this.Width,this.Height]){
        super.resize(size);
        this.updateSlider();
    }

    draw(ctx,cam){
        draw(this,ctx,cam);
    }



    // TODO: Normalizing mousewheel speed across browsers
    // https://stackoverflow.com/questions/5527601/normalizing-mousewheel-speed-across-browsers
    // http://phrogz.net/js/wheeldelta.html
    onScrollCanvas(deltaX,deltaY,SCALE = editorSetting.setting.SCROLL_ITER_STEPS,BOUNCE_SPACE = editorSetting.setting.SCROLL_BOUNCE,STEPS = editorSetting.setting.SCROLL_ITER_STEPS){
        deltaX*=SCALE;
        deltaY*=SCALE;
        const
            group = this.listLayout.group,
            groupWidth = this.listLayout.group.Width,
            groupHeight = this.listLayout.group.Height,
            _top = this.listLayout.Height - groupHeight - BOUNCE_SPACE,
            _left = this.listLayout.Width - groupWidth - BOUNCE_SPACE,
            offsetPos = group.transform.Position.slice();


        this.#top = _top<0?_top:-BOUNCE_SPACE;
        this.#bottom = BOUNCE_SPACE;
        this.#left = _left<0?_left:-BOUNCE_SPACE;
        this.#right = BOUNCE_SPACE;

        const isTopOutside = offsetPos[1]- deltaY  < this.#top,
            isBottomOutside = offsetPos[1]- deltaY > this.#bottom,
            isLeftOutside = offsetPos[0]- deltaX  < this.#left,
            isRightOutside = offsetPos[0]- deltaX > this.#right,

            isXOutside =  isLeftOutside || isRightOutside,
            isYOutside = isTopOutside || isBottomOutside,
            isOutside = isXOutside || isYOutside;

        if(isOutside)
            this.bounceBack(group,offsetPos,isXOutside,isYOutside,isLeftOutside,isTopOutside);

        //don't change scrollValue further when outside
        // if(isOutside || !isTopOutside&& deltaY<0 || !isBottomOutside&& deltaY>0)
        if(!isXOutside)
            this.#targetScrollValueX -= deltaX;
        if(!isYOutside)
            this.#targetScrollValueY -= deltaY;
        if(!(this.status&common$1.setting.BASIC_STATUS.animation))
            $throttle(_=>{
                offsetPos[0] += (this.#targetScrollValueX-offsetPos[0])/STEPS;
                offsetPos[1] += (this.#targetScrollValueY-offsetPos[1])/STEPS;
                group.transform.Position = offsetPos;
                this.HorizontalSlider.Value  = 1-(group.transform.Position[0]-this.#left)/(this.#right-this.#left);
                this.VerticalSlider.Value  = 1-(group.transform.Position[1]-this.#top)/(this.#bottom-this.#top);

            },30);
    }

    bounceBack(group,offsetPos,isXOutside,isYOutside,isLeftOutside,isTopOutside, THRESHOLD = 0,
               STEPS = editorSetting.setting.SCROLL_ITER_STEPS){

        $debounce(_=>{
            // this.status &= ~common.setting.CTRL_STATUS.wheel;

            // if(isOutside){
                [this.#targetScrollValueX, this.#targetScrollValueY] = offsetPos;
                if(isXOutside)
                    this.#targetScrollValueX = isLeftOutside?this.#left:this.#right;
                if(isYOutside)
                    this.#targetScrollValueY = isTopOutside?this.#top:this.#bottom;
                $animate(_=>{

                    this.status |= common$1.setting.BASIC_STATUS.animation;
                    offsetPos[0] += (this.#targetScrollValueX-offsetPos[0])/STEPS;
                    offsetPos[1] += (this.#targetScrollValueY-offsetPos[1])/STEPS;
                    group.transform.Position = offsetPos;

                    this.HorizontalSlider.Value  = 1-(group.transform.Position[0]-this.#left)/(this.#right-this.#left);
                    this.VerticalSlider.Value  = 1-(group.transform.Position[1]-this.#top)/(this.#bottom-this.#top);

                    const isXArrived = Math.abs((this.#targetScrollValueX??offsetPos[0]) -  offsetPos[0]) < THRESHOLD,
                        isYArrived =  Math.abs((this.#targetScrollValueY??offsetPos[1]) -  offsetPos[1]) < THRESHOLD;


                    if( isXArrived&&isYArrived){

                        offsetPos[0] = this.#targetScrollValueX;
                        offsetPos[1] = this.#targetScrollValueY;
                        group.transform.Position = offsetPos;

                        this.Status &= ~common$1.setting.BASIC_STATUS.animation;
                        return true;
                    }
                },30);
            // }

        },30);
    }





    // async appendChild(child){
    //     uiAddChild.call(this.listLayout, child);
    //
    //     const controller = $findParentByType(this, Controller);
    //     if(controller) {
    //         // const decendents = depthFirstSearch(child,
    //         //     ele=> !checkStatus(ele.Status, common.setting.STATUS.deleting));
    //         //
    //         // for(const decendent of decendents)
    //             await Event.Instance.emit(common.setting.EVT_TYPES.onControllerAttached, this.listLayout, [controller]);
    //     }
    // }
    //
    // async insertChild(index, child){
    //     uiInsertChild.call(this.listLayout, index,child);
    //     const controller = $findParentByType(this, Controller);
    //     if(controller) {
    //         // const decendents = depthFirstSearch(child,
    //         //     ele=> !checkStatus(ele.Status, common.setting.STATUS.deleting));
    //         //
    //         // for(const decendent of decendents)
    //             await Event.Instance.emit(common.setting.EVT_TYPES.onControllerAttached, this.listLayout, [controller]);
    //     }
    //
    // }
    //
    // async removeChild(child){
    //     $assert(child);
    //     uiDelChild.call(this.listLayout, child);
    //     const controller = $findParentByType(this, Controller);
    //     if(controller){
    //         // const decendents = depthFirstSearch(child);
    //         // for(const decendent of decendents)
    //         //     Event.Instance.emit(common.setting.EVT_TYPES.onControllerDetached,decendent, [controller,decendent,this,decendents]);
    //         await Event.Instance.emit(common.setting.EVT_TYPES.onControllerDetached,child, [controller]);
    //
    //     }
    // }

    //////////////////////////////////////////////////////////////////////
    //////////////////////////////////////////////////////////////////////
    //////////////////////////////////////////////////////////////////////
    //////////////////////////////////////////////////////////////////////


}

class UIScrollable extends implement(UIWindow,IUIScrollable){
    scrollable = null;

    constructor(...args) {
        super(...args);
    }

    get Width(){return this.clientWidth;}
    get Height(){return this.clientHeight;}



    get Content () {
        return this.contentLayout;
    }

    async init(){
        await super.init();



        //////////////////////////////////////////////////////////////
        //////////////////////////////BODY////////////////////////////
        //////////////////////////////////////////////////////////////
        // TOOLs                                            //////////
        //////////////////////////////////////////////////////////////
        //////////////////////////////////////////////////////////////
        //////////////////////////////////////////////////////////////
        // Scrollable       //////////////////////////////////////////
        //////////////////////////////////////////////////////////////
        //////////////////////////////////////////////////////////////

        this.scrollable = new Scrollable('scrollable');
        await this.Body.appendChild(this.scrollable);
        await this.scrollable.initialize();
        Layout.linkHierachy(this.Body, this.scrollable);


        this.contentLayout = this.scrollable.listLayout;

    }

}
customElements.define('scrollable-canvas-element', UIScrollable);

class InspectorEvent extends Event$1{

    constructor(){
        super();
    }
}

function isOpen(inspector,pathID){


    $assert(inspector.DataEntries);
    const index = inspector.DataEntries.findIndex(ele=>ele['.path'] === pathID);

    if(index === -1)
        return null;

    return true;
}


async function initAttr(inspector, fileEntries){

    inspector.clear();
    const entries = [];
    for(const entryPath of fileEntries){
        if($readPath(entryPath).fileExt){
            if( FileExt2Meta[$readPath(entryPath).fileExt] === FILE_TYPES.image){
                $getAttr$1( $getKeanuPath());

                // await inspector.createData(entryPath,[importSetting]);
            }else
                entries.push(entryPath);
        }
    }
    await inspector.createData(entries);
}
async function updateAttr(evt,path, value){
    const inspector = evt.subscriber,
        nakedPath = $readPath(path).nakedPath,
        id = $path2ID(nakedPath);

    if(!isOpen(inspector,id))
        return;
    $assert(inspector);
    await inspector.editData(id, value);
}
// export async function delAttr(evt,path,params){
//     let nakedPath = isOpen(path);
//     if(!nakedPath)
//         return;
//     const inspector = evt.subscriber;
//     $assert(inspector);
//     await inspector.editData('onDelete',path);
// };







// export function updateFilePath(path){
//     const editors = window.Keanu.editors,
//         inspector = window.Keanu.editors.objs['Inspector'];
//
//
//     let [ele] = $getFiles(path);
//     $assert(ele);
//     // open(inspector,ele);
//     // TODO:
// }


const deleteFile$1 = (evt,paths)=>{

    const inspector = evt.subscriber;
    for(const entry of inspector.DataEntries)
        $readPath(entry['.path']);


    const entries = inspector.DataEntries
        .filter(entry=>$readPath(entry['.path']) !== undefined)
        .map(ele=>ele['.path']);
    if(inspector.DataEntries.length !== entries.length)
        return initAttr(inspector,entries);
};

async function openByInspector(evt, array, mode){
    const
        inspector = evt.subscriber,
        selList = array;

    if(selList.length == 0)
        inspector.clear();
    else {

        const lastSelEntryName = selList[array.length-1];

        $assert(lastSelEntryName);
        await initAttr(inspector,array);
    }
}

window.genPalette = async function (dataEntry){
    dataEntry['.dataTypes'];
        dataEntry['.path'];
        const sources = dataEntry['sources'],
        prunedData = $pruneData(dataEntry,'sources'),
        layout = await $createDefaultGUI(prunedData);

    return Layout.create(layout,Layout.LAYOUT_MODE.create,async _=>{


        await $CREATE_ARRAY(sources, async (index, content)=>{
            const
                source = content['source'],
                path = source['.value'],
                type =  source['.dataTypes']['.'],//FileExt2Meta[$readPath(path).fileExt],
                MODE = Layout.LAYOUT_MODE;
            let img = null, icon;
            if(type & FILE_TYPES.autoBrush){
                const {source} =  $getAttr$1(path)??{source:''};
                // const imgSource = $getFileEntry(source);
                icon = Keanu.loadedItems['autoBrushIcon'];
                // if(imgSource)
                //     img = imgSource.EntryData['~rawImg'];

                img = $getAttr$1(source)['~rawImg'];

            }else if(type & FILE_TYPES.tileBrush){
                icon = Keanu.loadedItems['tileBrushIcon'];
                img = $getAttr$1(path)['~rawImg'];
            }
            await GUI$1.Image('contentRaw', {img, layoutMode:MODE.resizeY|MODE.lockRatio});
            await GUI$1.Image('icon', {img:icon, layoutMode:MODE.resizeY|MODE.lockRatio});
            await $CREATE_INPUT_BOX (source);
        });

    });
};

window.genAutoTile = async function(dataEntry){

    dataEntry['.dataTypes'];
            const path = dataEntry['.path'];

    await FoldableLayout.begin(dataEntry['.name']);

    const margin = editorSetting.setting.INSPECTOR.dataEntryMargin;

    const contents = dataEntry['autoTile'],
            sourceData = dataEntry['source'];

    await $CREATE_INPUT_BOX (sourceData);

    const autoTileLayout = await AutoTileLayout.begin('autoTiles', {margin});

    autoTileLayout.Path = `${$path2ID(path)}|autoTile`;
    // for(let ruleRankIndex in contents){
    for(const [index,content] of $mapObj(contents)){
        const ruleRankIndex = parseInt(index),
            rule = content['.value'],
            layoutMode = Layout.LAYOUT_MODE.horizontal|Layout.LAYOUT_MODE.resizeX|Layout.LAYOUT_MODE.expandY,
            margin = {left:0,right:0,top:1,bottom:1},
            indexStr = (ruleRankIndex+1).toString();
            editorSetting.setting.INSPECTOR.fontParams;
        $assert(rule);
        await Layout.begin(`rule${indexStr}`,{
            color:'gray',
            layoutMode,
            margin
        });

        //TODO: replace by drop down menu
        // await GUI.TextBox(indexStr, {
        //     fontParams,
        //     width:100,
        //     height:editorSetting.setting.INSPECTOR.autoTileLayout.ruleHeight,
        //     mode:TextBox.MODE.freeze
        // });


        const checker = GUI$1.AutoTileRule('checker',{
                ruleMatrix:rule.ruleMatrix,
                width:editorSetting.setting.INSPECTOR.autoTileLayout.checkerSize,
                height:editorSetting.setting.INSPECTOR.autoTileLayout.checkerSize,
                margin:{left:6,right:6,top:6,bottom:6}
            });

        checker.onRuleChange = (ruleMatrix)=>{
            Event$1.Instance.emit(common$1.setting.EVT_TYPES.setAttr,[
                `${path}|autoTile|${ruleRankIndex}`, {
                  ruleMatrix
                }
            ]);
        };
        let selectedRuleIndex = null;
        autoTileLayout.onSelectChange = target=>{
            const ruleArr = autoTileLayout.Children.slice(1);//get rid of title layout
            selectedRuleIndex = ruleArr.findIndex(ele=>ele===target);
            $assert(selectedRuleIndex !== -1);

        };
        autoTileLayout.onOrderChange = names=>{
            const ruleArr = autoTileLayout.Children.slice(),rules = {};
            ruleArr.shift();
            ruleArr.forEach((ele, index)=>{
                const {ruleMatrix} = ele.Children.find(ele=>ele instanceof AutoTileRule),
                    previewLayout = ele.Children.find(ele=>ele instanceof AutoTilePreview);

                rules[index] = {type:FILE_TYPES.image,
                    boundary:previewLayout.targetBoundary??null,
                    ruleMatrix:ruleMatrix.slice()
                };
            });
            Event$1.Instance.emit(common$1.setting.EVT_TYPES.setAttr,[
                `${path}|autoTile`, rules
            ]);

        };
        autoTileLayout.onAdd = dataIndex=>{
            debugger;
            Event$1.Instance.emit(common$1.setting.EVT_TYPES.setAttr, [
                `${path}|autoTile`, {
                    [dataIndex]: {
                        ruleMatrix:[
                            0,  1,  0,
                            1,  -1,  1,
                            0,  1,  0
                        ],

                        boundary:null,
                    }
                }
            ]);
        };

        autoTileLayout.onDel = _=>{
            if(!$isNumber$1(selectedRuleIndex)) return;
            Event$1.Instance.emit(common$1.setting.EVT_TYPES.delAttr, [
                `${path}|autoTile`, [selectedRuleIndex]
            ]);

            selectedRuleIndex = null;
        };


        const previewLayout = await GUI$1.AutoTilePreview('imgPreview',{
            path,
            ruleRankIndex,
            width:editorSetting.setting.INSPECTOR.autoTileLayout.checkerSize,
            height:editorSetting.setting.INSPECTOR.autoTileLayout.checkerSize,
            margin:{left:6,right:6,top:6,bottom:6},
        });
        const {boundary} = rule;
        if(boundary&&sourceData['.value']){
            const isErr = $getFileEntry(sourceData['.value']).Status & common$1.setting.BASIC_STATUS.error;
            if(!isErr){
                previewLayout.targetBoundary = boundary;
                const img = await $genAutoTileImg(sourceData['.value'], boundary);
                await previewLayout.setImg(img);
            }
        }
        Layout.end();
    }


    AutoTileLayout.end();
    return FoldableLayout.end();
};
window.genTile = async function (dataEntry){
//path,dataType
    await FoldableLayout.begin(dataEntry['.name']);
    dataEntry['.path'];
        dataEntry['.dataTypes'];
        editorSetting.setting.INSPECTOR.dataEntryMargin;
        const contents = dataEntry['slices'],
        cellSize = dataEntry['cellSize'],
        offset = dataEntry['offset'],
        padding = dataEntry['padding'],
        source = dataEntry['source'],
        fontParams = editorSetting.setting.INSPECTOR.fontParams;

    await $CREATE_INPUT_BOX (source);
    await $CREATE_INPUT_BOX (cellSize);

    await FoldableLayout.begin('offset');
    await $CREATE_INPUT_BOX (offset[0]);
    await $CREATE_INPUT_BOX (offset[1]);
    FoldableLayout.end();

    await FoldableLayout.begin('padding');
    await $CREATE_INPUT_BOX (padding[0]);
    await $CREATE_INPUT_BOX (padding[1]);
    FoldableLayout.end();

    await $CREATE_ARRAY(contents, async (index, content)=>{ //`${path}|slices`, dataType['slices'],

        const
            {name, boundary} = content,
            cellSize = dataEntry['cellSize']['.value'],
            img = $boundary2ImgPreview(boundary,cellSize,dataEntry['~rawImg']),
            MODE = Layout.LAYOUT_MODE,
            layoutMode = Layout.LAYOUT_MODE.resizeX|Layout.LAYOUT_MODE.resizeY;

        $assert(img.height);
        await GUI$1.Image('contentRaw', {img,layoutMode:MODE.resizeX|MODE.lockRatio});

        const whiteFont = JSON.parse(JSON.stringify(fontParams)),
                [posX,posY,sizeX,sizeY] = $genBoundary(boundary);
        whiteFont.color = 'black';

        await GUI$1.TextBox(`pos(${posX},${posY})  size(${sizeX},${sizeY})`, {
            fontParams:whiteFont,
            layoutMode,
            mode:TextBox.MODE.freeze
        });
    });

    return FoldableLayout.end();
};
window.$CREATE_ARRAY = async function(dataEntry, genContentFnc){
    const
        path = dataEntry['.path'], dataType = dataEntry['.dataTypes'],
            margin = editorSetting.setting.INSPECTOR.dataEntryMargin;
    const layout = await FoldableLayout.begin('array', {margin});
    $assert((dataType['.']&DATA_TYPES.array) || (dataType['.']&DATA_TYPES.object) );
    const   contents =
                $mapObj(dataEntry)
                .filter(([key,value])=>value['.value']);
    await layout.clear();
    for(const [index, content] of contents){
        const
            layoutMode = Layout.LAYOUT_MODE.horizontal|Layout.LAYOUT_MODE.resizeX|Layout.LAYOUT_MODE.expandY,
            margin = {left:0,right:0,top:1,bottom:1};

        await Layout.begin(`content${index}`,{
                            color:'white',
                            layoutMode,
                            margin
                        });
        await genContentFnc(index,content);
        Layout.end();
    }
    FoldableLayout.end();
    layout.Path = $path2ID(path);
    return layout;
};


window.$CREATE_INPUT_BOX = async function(dataEntry){
    $assert(dataEntry&&dataEntry['.dataTypes']);

    const path = dataEntry['.path'],dataType = dataEntry['.dataTypes']['.'];

    $assert(typeof dataType == 'number');
    const {nakedPath,attrKeys} = $readPath(path),
        attrName = attrKeys.pop(),
        value = dataEntry['.value'];


    const margin = editorSetting.setting.INSPECTOR.dataEntryMargin,
        isReadOnly = $isReadOnlyAttr(attrName);
    await Layout.begin(attrName+'_horizontalLayout',{
        color:editorSetting.setting.INSPECTOR.color,
        layoutMode:Layout.LAYOUT_MODE.horizontal|Layout.LAYOUT_MODE.resizeX,
        margin
    });
    const
        {specialChar,keyName} = $parseAttrValue(attrName),
        inputBoxNm = keyName,
        isPath = dataType & DATA_TYPES.path,
        fontParams = editorSetting.setting.INSPECTOR.fontParams,
        layoutMode = Layout.LAYOUT_MODE.resizeX|Layout.LAYOUT_MODE.resizeY;

    await GUI$1.TextBox(inputBoxNm+'_label', {fontParams,text:inputBoxNm,mode:TextBox.MODE.freeze, layoutMode});
    let txtBox;
    if(isReadOnly)
        txtBox = await GUI$1.TextBox(inputBoxNm,{fontParams,text:value,mode:TextBox.MODE.freeze, layoutMode});
    else if(isPath) {
        txtBox = await GUI$1.InputBox(inputBoxNm,
            {fontParams, mode: TextBox.MODE.freeze | InputBox.MODE.omit | InputBox.MODE.droppable, layoutMode});
        txtBox.bind(path, dataType);
    }else {
        txtBox = await GUI$1.InputBox(inputBoxNm, {fontParams, layoutMode});
        txtBox.bind(path, dataType);//no freeze
    }
    Layout.end();
    txtBox.Path = $path2ID(path);
    return txtBox;
};


window.updateInputBox = function (comp){
    $assert(comp.bindUpdate);
    comp.bindUpdate();
};


window.$CREATE_BUTTON = async function(dataEntry){

    const {nakedPath,attrKeys} = $readPath(dataEntry['.path']),
        attrName = attrKeys.pop();
    const {text,fnc, color = 'red'} = dataEntry['.value'];
    const btn = await GUI$1.Component(attrName,{text,color,width:200,height:30});

    if(fnc&&window[fnc])
        btn.addEventListener('click',async _=>window[fnc]());

    return btn;
};

window.genQR = async function (path,dataType){


    const   margin = editorSetting.setting.INSPECTOR.dataEntryMargin,
            name = $getAttr$1(path)['.name'],
            canvasPath = `${path}|canvas`;
    await FoldableLayout.begin(name,{
        color:editorSetting.setting.INSPECTOR.color,
        layoutMode:Layout.LAYOUT_MODE.vertical|Layout.LAYOUT_MODE.resizeX|Layout.LAYOUT_MODE.expandY,
        margin
    });

    await $CREATE_INPUT_BOX (canvasPath, DATA_TYPES.path|FILE_TYPES.palette);


    const qrLayout = Layout.begin('QRLayout',{
        color:editorSetting.setting.INSPECTOR.color,
        layoutMode:Layout.LAYOUT_MODE.vertical|Layout.LAYOUT_MODE.resizeX|Layout.LAYOUT_MODE.expandY,
        margin
    });
    Layout.end();



    const {text} = getFileData(path);
    await GUI$1.Component(text,{color:'red',width:200,height:30})
    .addEventListener('click',async _=>{
        const canvas = $getAttr$1(canvasPath);
        const img = await genQRCode(canvas);
        Layout.LAYOUT_MODE;
        const qrImage = new KImage('QR',{width:200,height:200,img});
        await  qrLayout.appendChild(qrImage);
        qrImage.initialize();

        Layout.linkHierachy(qrLayout, qrImage);
        qrLayout.refresh();
        Keanu.editors.objs.Inspector.refresh();
    });


    return FoldableLayout.end();
};









async function $createGUI(dataEntry,
                                    isDefaultGUIObject = (name,type)=>!!(type['.'] & DATA_TYPES.object)) {

    const
        dataType = dataEntry['.dataTypes'],
        path =  dataEntry['.path'],
        name = dataEntry['.name'];

    if (isDefaultGUIObject(name,dataType)){
        const   layout = await FoldableLayout.begin(name),
                arr = $mapObj(dataEntry);

        for(const [key,val] of arr){
            const entry = dataEntry[key];
            const type =  {'.':dataType[key]};
            $assert(type);
            const isObj = !!(type['.'] & DATA_TYPES.object);
            await $createGUI(isObj ? entry:val, isDefaultGUIObject);
        }
        layout.Path = $path2ID(path);
        FoldableLayout.end();
        return layout;
    }else {
        const fnc = GUI$1.$getFncByType(dataType['.'], 'onCreate');
        $assert(fnc,{path,errorType:common$1.error.ERR_TYPE.internalErr,
            msg:'unknown data entry type'});
        return await fnc(dataEntry);
    }

}

function $createDefaultGUI(dataEntry){
    dataEntry['.dataTypes']['.'] = DATA_TYPES.object;
    return $createGUI(dataEntry);
}





async function editData(inspector,path, value){
    // depthFirstSearch()
    const res = depthFirstSearch(inspector.Content,_=>true,ele=>ele.getConnection(ConnectionType.outputs,'children'));
    const finder = res.filter(ele=>ele.Path === path);
    if(finder.length === 0) return;
    const   comp = finder[0],
            type = $getFileDataType(path);


    const updateFnc = GUI$1.$getFncByType(type,'onUpdate');
    if(updateFnc){
        await updateFnc(comp, path, value);
    }else {
        const fnc = GUI$1.$getFncByType(type,'onCreate');
        if(fnc){
            const dataEntry = inspector.DataEntries.find(ele=>ele['.path']===comp.Path);
            $assert(dataEntry&&typeof fnc === 'function');
            await fnc( $initData(dataEntry['.path'], 'deepCpy'));
            return true;
        }else return false;
    }
}

class Inspector  extends implement( UIScrollable) {




    get DataEntries(){return this.data;}
    data= null;

    get Event (){return InspectorEvent.Instance;}

    constructor(name='__test', params = {
        style: {}
    }) {

        super(name, params);
        this.data = [];

    }






    async createData ( entries ){

        for(const entryPath of entries) {
            console.log(entryPath);
            const dataEntry = $initData(entryPath, 'deepCpy');
            this.data.push(dataEntry);
        }

        await GUI$1.$REFRESH_LOCK_BEGIN(this);
        Layout.beginInit(this.Content);

        for(const dataEntry of this.data){
            await $createGUI(dataEntry);
        }

        Layout.endInit();
        await GUI$1.$REFRESH_LOCK_END(this);
        $assert(this.Content instanceof Layout);

    }

    async editData(path,value){

        await GUI$1.$REFRESH_LOCK_BEGIN(this);
        Layout.beginInit(this.Content);
        if(await editData(this,path, value) === false){
            await this.clear();
            await $createGUI( $initData($readPath(path).nakedPath, 'deepCpy'));
        }
        Layout.endInit();
        await GUI$1.$REFRESH_LOCK_END(this);
    }




    initListeners() {
        super.initListeners();
        const content = this.Content;


        // content.addEventListener('dragstart', async evt => {
        //
        //     common.$clearGhostImg();
        //     common.$setGhostImg(evt,this.Canvas,0,0,0,0);//clear
        //
        //
        //     evt.preventDefault();
        // });

        // content.addEventListener("press", async evt => {
        //     console.log('mousedown');
        // });
        //
        // content.addEventListener("release", async evt => {
        //     console.log('mouseup');
        // });




        content.addEventListener('enter',evt=>{
            if(evt.target instanceof  Layout)
                return;
        });

        content.addEventListener('leave',evt=>{
            if(evt.target instanceof  Layout)
                return;
        });


        content.addEventListener('drop',evt=>{
            // if(!evt.target instanceof  TextBox)
            //     return;
            //
            //
            // $assert(evt.customDataTransfer.getData('dragInfo'));
            //
            // const info = JSON.parse(evt.customDataTransfer.getData('dragInfo'));
            //
            //
            // if(evt.target instanceof InputBox){
            //     const inputBox = evt.target;
            //     if($getFileDataType(inputBox.Path) & DATA_TYPES.path)
            //         return;
            // }else{
            //
            //     const textBox = evt.target;
            //
            // }
        });

    }



    async init(){

        await super.init();
        this.Title.Text = 'Inspector';

    }


    onError( path, stack){
        const index = this.DataEntries.findIndex(ele=>ele['.path'] === $path2ID(path));
        if(index<0) return;

        this.refresh();
        super.onError(path,stack);
    }

    registEvt() {
        super.registEvt();

        this.Event.on(common$1.setting.EVT_TYPES.select, this.onActive(openByInspector), {subscriber:this});

        this.Event.on(common$1.setting.EVT_TYPES.setAttr, this.onActive(updateAttr), {subscriber:this} );
        this.Event.on(common$1.setting.EVT_TYPES.delAttr, this.onActive(updateAttr), {subscriber:this} );
        this.Event.on(common$1.setting.EVT_TYPES.deleteFile, this.onActive(deleteFile$1),{subscriber:this});

    }


    async initGUI(){

        Layout.beginInit(this.Content);
        for(let customEditor of usrWindows){
            customEditor.onInspectGUI();
        }

        Layout.endInit();

    }




    onInspectGUI(){
        // let layout = DraggableLayout.begin('usr');
        // layout.addEventListener('mouseover',evt=>{
        //     console.log('layout mouseover',evt.target.FullName, evt.timestamp);
        // })
        // layout.addEventListener('mouseout',evt=>{
        //     console.log('layout mouseout',evt.target.FullName, evt.timestamp);
        // })
    }

    resize(size) {
        super.resize(size);
    }


    clear(){
        this.data = [];
        return super.clear();//async
    }
    delete(){

        this.data = null;

        super.delete();
    }
}

window.Inspector = Inspector;
customElements.define('inspector-element', Inspector);

class Button extends Label{
    #value =false;
    constructor(name='__test',params={}){
        // params.isRegist = false;
        super(name,params);
        this.#value = false;

    }
    get Value(){
        return this.value;
    }


    async initialize(){
        await super.initialize();
        this.status |=  Controller.STATUS.active;

        this.addEventListener("press",_=>{
            this.#value = true;

        });

        this.addEventListener("release",_=>{

            this.#value = false;
        });

    }


    delete(){
        super.delete();
    }


    draw(ctx,cam){

        super.draw(ctx,cam);
    }
}

let Proxy$1 = class Proxy{
    constructor(shape){


        this.aabb = null;
        this.proxyIndex = 0;
        this.shape = shape;
        this.nodeIndex = null;



    }




};

class Box {
    #aabb = null;
    #vertice = null;
    #boundary = null;
    #transform = null;
    constructor(){
        this.normals = [[0,0],[0,0],[0,0],[0,0]];

        this.proxies = [new Proxy$1(this)];
        this.#boundary = [0,0,0,0];
        this.#aabb = [0,0,0,0];
        this.#transform = null;
        this.parent = null;

        this.MassCenter = create$1();
        this.invMass = null;
        this.invI = null;
        this.density = 1;



    }


    updateVertice(val){
        if(val){
            this.#boundary[0] = val[0];
            this.#boundary[1] = val[1];
            this.#boundary[2] = val[2];
            this.#boundary[3] = val[3];
        }

        let vertice = [
            [this.#boundary[0],this.#boundary[1]],//top left
            [this.#boundary[0] + this.#boundary[2],this.#boundary[1]],//top right
            [this.#boundary[0]+this.#boundary[2],this.#boundary[1]+this.#boundary[3]],//bottom right
            [this.#boundary[0],this.#boundary[1]+this.#boundary[3]]//bottom left
        ];


        this.checkClockwise(vertice);

        // let vertice = [];
        // for (let vertex of val)
        //     vertice.push(vertex.slice());
        this.#vertice = vertice;

        if(this.#transform!= null){
            this.resetNormals();
            this.computeAABB();
            this.computeMass();
        }
    }
    get Boundary(){return this.#boundary;}

    get Width(){return this.#boundary[2];}
    // set Width(value){this.#boundary[2] = value;}

    get Height(){return this.#boundary[3];}
    // set Height(value){this.#boundary[3] = value;}

    get AABB(){return this.proxies[0].aabb;}

    get Registers(){
        return ['MassCenter','density'];
    }


    set Transform(val){
        this.#transform = val;
        if(this.#vertice!= null){
            this.resetNormals();
            this.computeAABB();
            this.computeMass();
        }
    }
    get Transform(){return this.#transform;}
    // set Vertice(val){
    //
    // }


    delete(){

        this.#transform = null;
        this.proxies = null;
        this.parent = null;

        this.#vertice = null;
        this.#boundary = null;

        this.MassCenter = null;
        this.invMass = null;
        this.invI = null;
        this.density = null;

    }
    get Proxies(){
        return this.proxies;
    }
    get Type(){return phyEngine.setting.SHAPE_TYPE.box;}



    get Vertice(){return this.#vertice;}

    get Normals(){return this.normals;}

    resetNormals() {
        for (let i = 0; i < this.#vertice.length; i++) {
            let next = i == this.#vertice.length - 1 ? 0 : i + 1;
            //let tmp = math.vec2.create();

            let n = this.normals[i];
            sub$1(n, this.#vertice[next], this.#vertice[i]);

            normalize$1(n,cross$1(1, n));
            //this.normals.push(tmp);
        }
    };


    checkClockwise (vertice) {
        let edge0 = create$1(),
            edge1 = create$1();

        sub$1(edge0,vertice[1], vertice[0]),
        sub$1(edge1,vertice[2], vertice[1]);

        let isClockwise = cross$1(edge0, edge1) < 0 ? true : false;

        if (!isClockwise) {
            if (vertice.length == 4) {
                let v1 = vertice[1],
                    v3 = vertice[3];
                vertice[1] = v3;
                vertice[3] = v1;
            } else
                throw new Error('lazzy pig over here');
        }
    };

    computeMass() {
        if (this.status&phyEngine.setting.SIM_STATUS.static||
            this.status&phyEngine.setting.SIM_STATUS.passive) {
            this.invMass = 0;
            this.invI = 0;
        } else {

            // Polygon mass, centroid, and inertia.
            // Let rho be the polygon density in mass per unit area.
            // Then:
            // mass = rho * int(dA)
            // centroid.x = (1/mass) * rho * int(x * dA)
            // centroid.y = (1/mass) * rho * int(y * dA)
            // I = rho * int((x*x + y*y) * dA)
            //
            // We can compute these integrals by summing all the integrals
            // for each triangle of the polygon. To evaluate the integral
            // for a single triangle, we make a change of variables to
            // the (u,v) coordinates of the triangle:
            // x = x0 + e1x * u + e2x * v
            // y = y0 + e1y * u + e2y * v
            // where 0 <= u && 0 <= v && u + v <= 1.
            //
            // We integrate u from [0,1-v] and then v from [0,1].
            // We also need to use the Jacobian of the transformation:
            // D = cross(e1, e2)
            //
            // Simplification: triangle centroid = (1/3) * (p1 + p2 + p3)
            //
            // The rest of the derivation is handled by computer algebra.


            // This code would put the reference point s inside the polygon.
            let s = create$1(), center = create$1(), area = 0, I = 0;
            for (let i = 0; i < this.#vertice.length; i++)
                add$1(s,s, this.#vertice[i]);

            //s = mul(1 / this.#vertice.length, s);
            s[0] *= 1 / this.#vertice.length, s[1] *= 1 / this.#vertice.length;


            for (let i = 0; i < this.#vertice.length; i++) {
                let e1 = create$1(),//sub(this.#vertice[i], s),
                    e2 = create$1();//i + 1 < this.#vertice.length ?
                        //sub(this.#vertice[i + 1], s) : sub(this.#vertice[0], s);

                sub$1(e1,this.#vertice[i], s);

                if(i + 1 < this.#vertice.length)
                    sub$1(e2,this.#vertice[i + 1], s);
                else
                    sub$1(e2,this.#vertice[0], s);

                let D = Math.abs(cross$1(e1, e2));
                let triangleArea = 0.5 * D;
                area += triangleArea;


                add$1(s,e1, e2);
                // math.vec2.mul(triangleArea / 3, s);
                s[0] *= triangleArea / 3, s[1] *=triangleArea / 3;
                add$1(center,center, s);

                let ex1 = e1[0], ey1 = e1[1];
                let ex2 = e2[0], ey2 = e2[1];

                let intx2 = ex1 * ex1 + ex2 * ex1 + ex2 * ex2;
                let inty2 = ey1 * ey1 + ey2 * ey1 + ey2 * ey2;

                I += (0.25 / 3 * D) * (intx2 + inty2);
            }


            let mass = this.density * area;
            //center = mul(1 / area, center);
            center[0] *= 1 / area,center[1] *= 1 / area;

            add$1(this.MassCenter,center, s);
            I = this.density * I;
            I += mass * (dot$1(this.MassCenter, this.MassCenter) - dot$1(center, center));
            this.invMass = 1 / mass;
            this.invI = 1 / I;

        }
    }
    computeAABB() {

        //TODO: missing scale in matrix

        let minx = this.#vertice[0][0], miny = this.#vertice[0][1],
            maxx = this.#vertice[0][0], maxy = this.#vertice[0][1];
        for (let i = 1; i < this.#vertice.length; i++) {
            if (minx > this.#vertice[i][0])
                minx = this.#vertice[i][0];
            if (maxx < this.#vertice[i][0])
                maxx = this.#vertice[i][0];

            if (miny > this.#vertice[i][1])
                miny = this.#vertice[i][1];
            if (maxy < this.#vertice[i][1])
                maxy = this.#vertice[i][1];
        }


        this.#aabb[0] = minx - phyEngine.setting.POLYGON_RADIUS;
        this.#aabb[1] = miny - phyEngine.setting.POLYGON_RADIUS;
        this.#aabb[2] = maxx + phyEngine.setting.POLYGON_RADIUS;
        this.#aabb[3] = maxy + phyEngine.setting.POLYGON_RADIUS;

        // this.updateAABB();

        multiply(this.#aabb,this.#transform, this.#aabb, 'aabb');

        this.proxies[0].aabb = this.#aabb;
        this.proxies[0].shape = this;


        this.width = maxx - minx;
        this.height = maxy - miny;
    };

}

const RESERVED_KEYS = ['Control','CapsLock','Escape','Backspace','Enter','Shift','Alt','Meta','ArrowLeft','ArrowRight','ArrowUp','ArrowDown'];


const __pick = function(solver, pos, radius){
    return solver.pick(pos, radius, Transform2D, phyEngine.setting.SHAPE_TYPE)
};


class TextBox extends implement(Label){

    static MODE = {
        omit:2,autoExtend:4, freeze:8, droppable:16,
        initializing:1,editing:128,selecting:256,debugging:512,omitting:1024
    };
    fontParams =  JSON.parse(JSON.stringify(editorSetting.setting.COMPONENTS.textbox.fontParams));

    selectedColor   = null;
    selectedTxtColor= null;
    cursorColor = null;

    // get Text(){
    //     if(this.mode & TextBox.MODE.omitting)
    //         return this.omitText;
    //     else
    //         return super.Text;
    // }
    // set Text(value){
    //
    //     if(this.text == value)
    //         return;
    //
    //
    //     super.Text = value;
    //
    //     // this.oldText = this.text;
    //     this.text = value.toString();
    //
    //     if(this.mode&TextBox.MODE.autoExtend) {
    //         this.Width = this.measureText(this.ctx, this.text)[2] + this.margin.right + this.margin.left;
    //     }
    //     // if(!(this.Mode &TextBox.MODE.editing))
    //
    //     if(this.Mode)
    //         this.Mode |= TextBox.MODE.initializing;
    //
    // }

    // get Width(){return super.Width;}
    // set Width(val){
    //     super.Width = val;
    //     if(this.Mode)
    //         this.Mode |= TextBox.MODE.initializing;
    // }



    get Mode(){return this.mode;}

    onNavigating(keyCode){
        //['Escape','Backspace','Enter','Shift','Alt','Meta','ArrowLeft','ArrowRight','ArrowUp','ArrowDown'];
        switch (keyCode){

            case 'Enter':
                this.Mode &=~TextBox.MODE.editing;
                // this.Mode |= TextBox.MODE.initializing;
                break;
            case 'ArrowLeft':
                this.CursorIndex--;
                if(this.mode & TextBox.MODE.selecting){
                    // const range = this.selectingRange.slice();
                    // range.sort((a,b)=>a-b);

                    const range = this.selectingRange;
                    this.CursorIndex = range[0];
                    this.mode &= ~TextBox.MODE.selecting;
                }


                break;

            case 'ArrowRight':
                this.CursorIndex++;

                if(this.mode & TextBox.MODE.selecting){

                    // const range = this.selectingRange.slice();
                    // range.sort((a,b)=>a-b);
                    const range = this.selectingRange;
                    this.CursorIndex = range[1];
                    this.mode &= ~TextBox.MODE.selecting;
                }

                break;

            default:
                console.log();
        }
    }



    onEditing(keyCode){
        //['Escape','Backspace','Enter','Shift','Alt','Meta','ArrowLeft','ArrowRight','ArrowUp','ArrowDown'];
        switch (keyCode){

            case 'Backspace':




                if(this.mode & TextBox.MODE.selecting){

                    // const range = this.selectingRange.slice();
                    // range.sort((a,b)=>a-b);
                    const range = this.selectingRange;
                    this.Text = this.text.slice(0, range[0]) + this.text.slice(range[1]);
                    this.CursorIndex = range[0]+1;
                    this.mode &= ~TextBox.MODE.selecting;

                }else if(this.cursorIndex == 0)
                    break;
                else
                    this.Text = this.text.slice(0, this.cursorIndex-1) + this.text.slice(this.cursorIndex);

                if(this.Text != ''){
                    this.CursorIndex--;

                }else {
                    const dummy = 'o';
                    // this.textOffset = this.calculateAnchor(this.measureText(this.ctx,dummy),this.layoutMode);
                    // this.textOffset[0] = this.cursorPos[0] = this.margin.left;

                    this.textOffset[0] = calculateAnchor(this.boundary,this.measureText(this.ctx,dummy), this.layoutMode & Layout.LAYOUT_MODE.ANCHOR_HORIZONTAL_MASK, this.Padding);


                    this.cursorPos[0] = this.textOffset[0];
                    this.cursorIndex = 0;
                }


                break;

            default:
                console.log();
        }
    }
    selectingEditing(keyCode){
        // const lowRange = this.selectingRange[0]<this.selectingRange[1]?this.selectingRange[0]:this.selectingRange[1],
        //     highRange = this.selectingRange[0]>this.selectingRange[1]?this.selectingRange[0]:this.selectingRange[1];
        const [lowRange, highRange] = this.selectingRange;
        this.Text =  [this.text.slice(0, lowRange), keyCode, this.text.slice(highRange)].join('');


        this.CursorIndex = lowRange+1;



        this.mode &= ~TextBox.MODE.selecting;
    }

    insertingEditing(keyCode){
        this.Text = [this.text.slice(0, this.cursorIndex), keyCode, this.text.slice(this.cursorIndex)].join('');

        this.CursorIndex++;


    }


    checkEditingEnd(value){
        return this.mode&TextBox.MODE.editing && !(value&TextBox.MODE.editing);
    }

    clearHandler(){//TODO: ??????????? could be obsoleted?

        Controller.keyboard.clearHandler();
        if(Controller.checkEventListener('move', this.moveHandler), {capture:true}){
            Controller.removeEventListener('move', this.moveHandler, {capture:true});
            Controller.removeEventListener('release', this.mouseupHandler, {capture:true});
        }
    }

    resetMode(value){
        for (let key in TextBox.MODE)
            if (/ing$/.test(key))
                value &= ~TextBox.MODE[key];

        if(value & TextBox.MODE.omit)
            if(this.setOmitText())
                value |= TextBox.MODE.omitting;

        return value;
    }



    set Mode(value){

        const isCreating = this.Status & TextBox.STATUS.creating,
            isIniting = value & TextBox.MODE.initializing,
            isEditingEnd = this.checkEditingEnd(value);
            !(this.mode&TextBox.MODE.editing) &&  value&TextBox.MODE.editing;


        // if(isEditingStart||isEditingEnd)
        //     this.clearHandler();

        if(isCreating||isIniting||isEditingEnd){
            if(typeof this.text == 'string'){
                if(isEditingEnd){
                    if(this.onValidation(this.text)){
                        this.cursorIndex = null;
                        this.endChange();
                    }
                    value = this.resetMode(value);
                }

                this.initText();
            }
        }


        if( !(this.mode&TextBox.MODE.editing)&& (value&TextBox.MODE.editing)){
            this.status |=  common$1.setting.BASIC_STATUS.animation;//flickering cursor
            this.oldText = this.text;

            if(value&TextBox.MODE.omitting){
                value &= ~TextBox.MODE.omitting;
                this.mode &= ~TextBox.MODE.omitting;
                this.initText();
            }

            if(this.CursorIndex  == null)
            this.CursorIndex = this.Text.length;

            //listening input
            // const controller = $findParentByType(this, Controller);
            Controller.keyboard.setHandler(this,keyCode=>this.keyBoardHandler(keyCode));
        }

        if(this.mode&TextBox.MODE.editing && !(value&TextBox.MODE.editing)){
            this.Status &=  ~common$1.setting.BASIC_STATUS.animation;//flickering cursor
        }

        this.mode = value;
    }

    aabbs = [];
    shapes = [];
    selectingRange = [0,0];
    textOffset = [0,0];

    cursorPos = null;
    cursorIndex = null;
    mode = null;//|MODE.debugging;
    oldText = null;


    #cursorStartTime = null;

    mouseStatus = null;
    #mouseDownX = null;
    #mouseDownY = null;

    dblclickHandler = null;
    mousedownHandler= null;
    moveHandler = null;
    mouseupHandler = null;
    dropHandler = null;

    constructor(name='__test',params={}){

        super(name,params);

        params.mode = params.mode??0;
        //
        // //mode cannot be null if mode omit is active,
        // //later init function would check if mode equals to omit
         //this.mode = this.params.mode;

        this.status |=  Controller.STATUS.active;

        this.solver = new ImpulseSolver('textBoxSolver');
    }
    initText(){

        super.initText();
        this.prepareAABBs(this.ctx, this.textOffset);
    }



    updateOffset4Boundary(cursorPos, textOffset, padding = this.Padding){
        const [left, right] = [
            Math.ceil(this.boundary[0]+padding.left),
            Math.floor(this.boundary[0]+this.boundary[2]-padding.right)
        ];

        if(this.cursorPos[0] < left){
            const diff = left - this.cursorPos[0];
            textOffset[0] += diff;
            cursorPos[0] += diff;
        }else if(this.cursorPos[0] > right){
            const diff = this.cursorPos[0] - right;
            textOffset[0] -= diff;
            cursorPos[0] -= diff;
        }else {

            console.log();
        }

    }



    onValidation(newText){

        if(this.text == this.oldText)
            return false;

        if(!newText)
            this.Text = 'unnamed';
        else
            this.Text = newText;



        return true;
    }
    keyBoardHandler(keyCode){
        if(RESERVED_KEYS.includes(keyCode)){
            this.onNavigating(keyCode);
            if(!(this.mode&TextBox.MODE.freeze))
                this.onEditing(keyCode);

        }else {
            this.onChange(keyCode);
            if (!(this.mode & TextBox.MODE.freeze) &&
                this.Text.length < editorSetting.setting.COMPONENTS.textbox.maxTextLength) {

                if (this.mode & TextBox.MODE.selecting)
                    this.selectingEditing(keyCode);
                else
                    this.insertingEditing(keyCode);

            }
        }

    }
    onChange(text){
        console.log('onChange:',text);
    }

    endChange(){
    }
    onActive(fnc){

        return  evt => {

            // if( this.status & commonSetting.setting.BASIC_STATUS.deleted){
            //     debugger;
            // }else
            //     fnc(evt);

            fnc(evt);
        };
    }

    drop = (evt, element = null)=>{

        this.Mode |= TextBox.MODE.editing;
        if(element)
            this.Text = element;
        this.initText();

        this.Mode |= TextBox.MODE.selecting;
        $assert(this.Text.length == this.aabbs.length);
        this.selectingRange = [0,this.aabbs.length];
    };
    dblclick = evt => {
        this.selectingRange = [0,this.aabbs.length];
        this.Mode |= TextBox.MODE.editing|TextBox.MODE.selecting;
    };
    static MOUSE_STATUS = {init:1,move:2,left:4,right:8,mouseup:16,mousedown:32}
    mousedown = evt => {
        //TODO: test code
        $assert(this && !( this.status & common$1.setting.BASIC_STATUS.deleted));

        if(this.Text.length == 0)
            return;



        this.mouseStatus = TextBox.MOUSE_STATUS.mousedown;

        this.#mouseDownX = evt.offsetX;
        this.#mouseDownY = evt.offsetY;

        this.Mode |= TextBox.MODE.editing;
        const resultList = __pick(this.solver,[this.#mouseDownX,this.#mouseDownY]);
        resultList.sort((a,b)=>a.target.index-b.target.index);

        console.log('mousedown text', evt.eventPhase);
        $assert(!Controller.checkEventListener('move', this.moveHandler));

        Controller.addEventListener("move",this.moveHandler, {capture:true});//
        Controller.addEventListener("release",this.mouseupHandler, {capture:true});//,{capture:true}


        const [,minY,,maxY] = this.aabbs[0].aabb;
        if(resultList.length){
            this.selectingRange[0]=this.selectingRange[1]  = this.prepareCursor(resultList);
        }else if(evt.localY>minY&&evt.localY<maxY){//inside Y range
            if(this.outOfXBound(evt.localX) == 'leftBoundary')
                this.selectingRange[0] =this.selectingRange[1] = 0;
            else  if(this.outOfXBound(evt.localX) == 'rightBoundary')
                this.selectingRange[0] =this.selectingRange[1] = this.Text.length;
        }


        this.CursorIndex = this.selectingRange[0];
    }
    mousemove = evt => {

        $assert(this && !( this.status & common$1.setting.BASIC_STATUS.deleted));

        this.mouseStatus |= TextBox.MOUSE_STATUS.move;
        this.mouseStatus &= ~TextBox.MOUSE_STATUS.right;
        this.mouseStatus &= ~TextBox.MOUSE_STATUS.left;


        $assert(this instanceof TextBox);


        $screenCoord2Local(evt,this);
        const   local = [evt.localX,this.#mouseDownY];

        this.mouseStatus |= local[0]>this.#mouseDownX?TextBox.MOUSE_STATUS.right:TextBox.MOUSE_STATUS.left;

        const resultList =  __pick(this.solver,local);

        resultList.sort((a,b)=>a.target.index-b.target.index);
        if(resultList.length){

            this.selectingRange[1] = this.prepareSelectingCursor(resultList,this.mouseStatus);
            this.CursorIndex = this.selectingRange[1];
            if(this.selectingRange[0]!=this.selectingRange[1])
                this.Mode |= TextBox.MODE.selecting;
        }

    };
    mouseup = evt => {
        $assert(this && !( this.status & common$1.setting.BASIC_STATUS.deleted));

        console.log('mouseup text', evt.eventPhase);
        $screenCoord2Local(evt,this);
        this.#cursorStartTime = Date.now();
        const resultList =  __pick(this.solver,[evt.localX, evt.localY]);

        resultList.sort((a,b)=>a.target.index-b.target.index);

        if(resultList.length){
            let index;
            if(this.mouseStatus&TextBox.MOUSE_STATUS.move){
                index = this.prepareSelectingCursor(resultList,this.mouseStatus);
                this.selectingRange[1] = index;
            }else
                index = this.prepareCursor(resultList);


            this.CursorIndex =  index;
            if(this.selectingRange[0]==this.selectingRange[1])
                this.Mode &= ~TextBox.MODE.selecting;

        }else {

            //if((this.Mode&TextBox.MODE.selecting) && !this.mouseStatus){
            if(!(this.mouseStatus & TextBox.MOUSE_STATUS.move)){
                this.Mode &= ~TextBox.MODE.selecting;
                this.CursorIndex = //this.outOfXBound(local[0])=='rightBoundary'?this.Text.length:0;
                    this.Text.length;
            }
        }

        if(this.mouseStatus & TextBox.MOUSE_STATUS.mousedown) {
            console.log('clear mouseup text', evt.eventPhase);
            Controller.removeEventListener('move', this.moveHandler, {capture:true});
            Controller.removeEventListener('release', this.mouseupHandler, {capture:true});

            $assert(!Controller.checkEventListener('move', this.moveHandler, {capture:true}));
            this.mouseStatus = TextBox.MOUSE_STATUS.init;
        }
    }

    async initialize(){
        await super.initialize();
        this.Mode = this.params.mode ?? 0;
        this.Margin = this.params.margin ?? editorSetting.setting.COMPONENTS.textbox.margin;

        this.fontParams = this.params.fontParams??this.fontParams;
        this.color = this.params.color?? editorSetting.setting.COMPONENTS.textbox.color;
        this.selectedColor   = this.params.selectedColor  ?? editorSetting.setting.COMPONENTS.textbox.selectedColor  ;
        this.selectedTxtColor   = this.params.selectedTxtColor  ?? editorSetting.setting.COMPONENTS.textbox.selectedTxtColor;

        this.cursorColor = this.params.cursorColor??editorSetting.setting.COMPONENTS.textbox.fontParams.color;
        this.oldText = this.Text;

        this.dblclickHandler =  this.onActive(this.dblclick);
        this.mousedownHandler= this.onActive(this.mousedown);
        this.moveHandler = this.onActive(this.mousemove);
        this.mouseupHandler = this.onActive(this.mouseup);
        if(this.Mode & TextBox.MODE.droppable)
            this.dropHandler =  this.onActive(this.drop);

        this.addEventListener('dblclick',   this.dblclickHandler, false);

        if(this.Mode & TextBox.MODE.droppable)
            this.addEventListener('drop',       this.dropHandler, false);
        this.addEventListener("press",  this.mousedownHandler, {capture:true});

        this.addEventListener("release",_=>{
            this.mouseStatus |= TextBox.MOUSE_STATUS.mouseup;
            this.mouseStatus &= ~TextBox.MOUSE_STATUS.mousedown;
        }, false);



        //guarantee controller is cleanned, as textbox is deleted when inspector is refreshed
       Event$1.Instance.on(common$1.setting.EVT_TYPES.onControllerDetached, function(evt, controller){
            const target = evt.publisher;

            // const controllerName = target.FullName.split('/').slice(0,2).join('/'),
            //     controller = $findByFullName(controllerName);
            // $assert(controller);

            if(Controller.checkEventListener('move', target.moveHandler, {capture:true})){
                Controller.removeEventListener('move', target.moveHandler, {capture:true});
                Controller.removeEventListener('release', target.mouseupHandler, {capture:true});
            }

        },{subscriber:this});

    }
    outOfXBound(x){
        const leftAABB = this.aabbs[0].aabb, rightAABB = this.aabbs[this.aabbs.length-1].aabb;

        if(x<leftAABB[0])
            return 'leftBoundary';
        else if(x>rightAABB[2])
            return 'rightBoundary';

        $assert(false, 'internal err');
        return null;

    }
    prepareSelectingCursor(contactList, mouseStatus){

        $assert((mouseStatus&TextBox.MOUSE_STATUS.right)||(mouseStatus&TextBox.MOUSE_STATUS.left));

        $assert(contactList.length == 1 ||contactList.length == 2);
        let resultIndex;
        if(contactList.length == 1){

            const intersection = contactList[0].manifold.points[0].worldPoint.slice(),
                aabb = this.aabbs[contactList[0].target.index].aabb,
                index = this.aabbs[contactList[0].target.index].index;

            $assert(intersection[0]>aabb[0]);
            $assert(intersection[0]<aabb[2]);

            if(mouseStatus&TextBox.MOUSE_STATUS.left)
                resultIndex = parseInt(index);
            else
                resultIndex = parseInt(index)+1;




        }else {
            const rightIndex = contactList[0].target.index<contactList[1].target.index?contactList[1].target.index:contactList[0].target.index,
                leftIndex = contactList[0].target.index>contactList[1].target.index?contactList[1].target.index:contactList[0].target.index;

            if(mouseStatus&TextBox.MOUSE_STATUS.left)
                resultIndex = parseInt(leftIndex);
            else
                resultIndex = parseInt(rightIndex);
            // const leftTarget = this.aabbs[leftIndex], rightTarget = this.aabbs[rightIndex];
        }
        return resultIndex;
    }

    prepareCursor(contactList){

        $assert(contactList.length == 1 ||contactList.length == 2);
        let resultIndex;
        if(contactList.length == 1){

            const intersection = contactList[0].manifold.points[0].worldPoint.slice(),
                    aabb = this.aabbs[contactList[0].target.index].aabb,
                    index = this.aabbs[contactList[0].target.index].index;

            $assert(intersection[0]>aabb[0]);
            $assert(intersection[0]<aabb[2]);

            if(intersection[0]-aabb[0]<aabb[2]-intersection[0]){//leftSpace<rightSpace

                //left
                resultIndex = parseInt(index);
            }else {
                //right
                resultIndex = parseInt(index)+1;
            }



        }else {
            const rightIndex = contactList[0].target.index<contactList[1].target.index?contactList[1].target.index:contactList[0].target.index;


            resultIndex = parseInt(rightIndex);
            // const leftTarget = this.aabbs[leftIndex], rightTarget = this.aabbs[rightIndex];
        }
        return resultIndex;
    }

    set CursorIndex (value){
        if(value <0 || value>this.aabbs.length) return;

        $assert(value>=0&&value<=this.aabbs.length);


        const aabb = value==0?this.aabbs[0].aabb:this.aabbs[value-1].aabb;
        this.cursorPos = value==0?[aabb[0], aabb[3]]:[aabb[2], aabb[3]];
        this.cursorIndex = value;

        this.updateOffset4Boundary(this.cursorPos,this.textOffset);
        this.prepareAABBs(this.ctx, this.textOffset);

    }

    get CursorIndex(){return this.cursorIndex;}


    delete(){




        this.aabbs = null;
        this.shapes = null;

        this.selectingRange = null;
        this.textOffset = null;
        this.cursorPos = null;
        this.cursorIndex = null;
        this.mode = null;//|MODE.debugging;
        this.oldText = null;

        super.delete();
    }



    clearShapes(){

        const dynamicTree = this.solver.dynamicTree;

        for(const {proxies} of this.shapes)
            dynamicTree.delNode(proxies[0].nodeIndex);
        this.shapes.length=0;
    }

    addTextShape(info){
        info.char;
            const x = info.aabb[0],
            y=info.aabb[1],
            w=info.aabb[2]-info.aabb[0],
            h=info.aabb[3]-info.aabb[1];


        let box = new Box();
        box.Parent = info;
        box.Transform = new Transform2D(name+'-textTransform');
        box.updateVertice([x,y,w,h]);

        const proxy = box.proxies[0];

        proxy.nodeIndex = this.solver.dynamicTree.addProxy(proxy);



        this.shapes.push(box);

    }

    drawCursor(ctx,pos,height = this.fontParams.size*1.2,width= this.fontParams.size/10,fontParams = this.fontParams){

        $assert(pos);
        const elapsedTime = parseInt((Date.now()-this.#cursorStartTime)/400);
        if(elapsedTime%2==0) return;
        ctx.fillStyle = fontParams.color;
        ctx.fillRect(pos[0]-width/3,pos[1],width,-height);
    }

    drawingSelectingBG(ctx,offset){
        ctx.fillStyle = this.selectedColor;

        const range = this.selectingRange.slice();
        range.sort((a,b)=>a-b);
        let boundary = this.measureText(this.ctx, this.Text, range);
        ctx.fillRect(offset[0]+boundary[0],
            offset[1]+boundary[1],
            boundary[2],boundary[3]);

        ctx.fillStyle = this.color;
    }
    drawingSelectingTxt(ctx,fontParams,offset){

        const range = this.selectingRange.slice();
        range.sort((a,b)=>a-b);
        const    selectedTxt =  this.Text.slice(...range);
        let boundary = this.measureText(this.ctx, this.Text, range);

        boundary[0] += offset[0];
        boundary[1] += offset[1];

        fontParams = {...fontParams};
        fontParams.color = this.selectedTxtColor;

        super.drawText(ctx,selectedTxt,boundary,fontParams);
    }

    drawText(ctx, txt = 'test',
             offset = this.textOffset,
             fontParams= this.fontParams,isDrawingTxtLine=false){


        if(this.mode&TextBox.MODE.selecting)
            this.drawingSelectingBG(ctx, offset);



        super.drawText(ctx,txt,offset,fontParams);


        if(this.mode&TextBox.MODE.selecting)
            this.drawingSelectingTxt(ctx, fontParams,offset);




       if(isDrawingTxtLine){
           let boundary = this.measureText(this.ctx, this.Text);
           ctx.moveTo(offset[0], offset[1]+1);
           ctx.lineTo(offset[0]+boundary[2], offset[1]+1);
           ctx.lineWidth = '2px';
           ctx.stroke();
       }

    }

    prepareAABBs(ctx,textOffset){
        $assert(ctx);
        let posX = textOffset[0];
        this.aabbs.length=0;

        ctx.font = this.Font;


        const [,top,,height] = this.measureText(this.ctx, this.Text);

        for(let i=0;i< this.Text.length;i++){

            const [,,width] = this.measureText(this.ctx, this.Text[i]);

            const pos = [posX,textOffset[1]+top];
            if(i==0)
                this.aabbs.push({
                    aabb:[pos[0], pos[1],
                        pos[0]+width, pos[1]+height],
                    char:this.Text[i]
                });
            else {

                const [,,lastWidth] = this.measureText(this.ctx, this.Text.slice(0,i));

                this.aabbs.push({
                    aabb:[pos[0]+lastWidth, pos[1], pos[0]+lastWidth+width,pos[1]+height],
                    char:this.Text[i]
                });


            }
        }

        for(let i in this.aabbs)
            this.aabbs[i].index = i;
        if(this.aabbs.length>1){
            this.aabbs[this.aabbs.length-1].left = this.aabbs[this.aabbs.length-2];
            this.aabbs[0].right = this.aabbs[1];
        }
        for(let i=1;i<this.aabbs.length-1;i++){
            this.aabbs[i].left = this.aabbs[i-1];
            this.aabbs[i].right = this.aabbs[i+1];
        }



        this.clearShapes();
        for(const info of this.aabbs)
            this.addTextShape(info);


    }

    clipTextBoxBegin(ctx){

        ctx.save();
        ctx.beginPath();
        const boundary = this.boundary.slice();
        boundary[0] += this.Padding.left;
        boundary[1] += this.Padding.top;
        boundary[2] -= this.Padding.left + this.Padding.right;
        boundary[3] -= this.Padding.top + this.Padding.bottom;

        const region = new Path2D();
        region.rect(boundary[0], boundary[1], boundary[2], boundary[3]);

        ctx.clip(region);

    }

    clipTextBoxEnd(ctx){

        ctx.restore();//beginPath
    }
    draw(ctx,cam){

        if(this.name == '_entry0-textBox'){
            ctx.fillStyle = 'white';
            ctx.fillRect(0,0,127,2);
            ctx.fillRect(0,28,127,2);
        }

        ctx.save();


        ctx.fillStyle = this.color;
            //editorSetting.default.OUTLINE_BACKGROUND_COLOR;
        ctx.fillRect(this.boundary[0],this.boundary[1],this.boundary[2],this.boundary[3]);



        // const offset = [this.textOffset[0]+this.#offsetX, this.textOffset[1]]

        const MODE = TextBox.MODE;
        const txt = checkStatus$1(this.Mode, MODE.omitting) &&
                    !checkStatus$1(this.Mode,MODE.editing) &&
                    !checkStatus$1(this.Mode,MODE.selecting) ?
                            this.omitText:this.Text;


        this.clipTextBoxBegin(ctx);
        this.drawText(ctx,txt, this.textOffset);
        this.clipTextBoxEnd(ctx);


        if((this.mode & TextBox.MODE.editing)&&!(this.mode & TextBox.MODE.selecting)){
            this.drawCursor(ctx,this.cursorPos,  );
        }


        if(window.debug){//this.mode & TextBox.MODE.debugging
            const boundary = this.boundary.slice(),
                margin=[this.margin.left,this.margin.top,this.margin.right,this.margin.bottom];

            boundary[0] += margin[0];
            boundary[1] += margin[1];
            boundary[2] -= margin[0]+margin[2];
            boundary[3] -= margin[1]+margin[3];

            ctx.strokeStyle = 'white';
            ctx.strokeRect(boundary[0], boundary[1],boundary[2],boundary[3]);
            for(let {aabb} of this.aabbs)
                ctx.strokeRect(aabb[0], aabb[1],aabb[2]-aabb[0],aabb[3]-aabb[1]);

        }


        ctx.restore();

    }


}
window.debug = false;

class Texture extends implement(Base,ITexture) {
    image = null;
    path = null;
    type = null;
    status = null;
    aniList = null;

    boundary = null;

    constructor(image={},parmas={}) {
        super();
        this.image = image;
        this.type = parmas.type?parmas.type:common$1.setting.TYPE.graphic;
        this.status = common$1.setting.BASIC_STATUS.creating;
        this.boundary = parmas.boundary?parmas.boundary:[0,0,image.width,image.height];
        this.size = parmas.size?parmas.size:[this.boundary[2],this.boundary[3]];

    }
    async initialize(){

        document.createElement('canvas');

        if(this.type & common$1.setting.TYPE.animation){
            this.aniList = [];
            $assert( this.boundary[2]>=this.size[0]);
            $assert( this.boundary[3]>=this.size[1]);
            const diffIndex = this.boundary[2] - this.size[0]>this.boundary[3] - this.size[1]?0:1;

            const startPos = [this.boundary[0],this.boundary[1]],
                deltaSize = this.size[diffIndex];
            for(let i = startPos[diffIndex]; i<this.boundary[2+diffIndex]; i += deltaSize){
                this.aniList.push(await $imgCrop( this.image, ...startPos, ...this.size));
                startPos[diffIndex] = deltaSize;
            }
        }else
            this.image = await $imgCrop( this.image,  this.boundary[0],this.boundary[1], this.size[0],this.size[1]);


        this.status &= ~common$1.setting.BASIC_STATUS.creating;


        this.onload();
    }

    onload(){

    }
    get Image(){
        $assert(this.image instanceof Image);
        if(this.type & common$1.setting.TYPE.animation)
            return this.aniList;
        return this.image;
    }
}

const COMPONENTS =  editorSetting.setting.COMPONENTS;
let lastReadyingInputBox;


const isTesting = true;
class InputBox  extends implement(TextBox,ILoad){

    #evtSource = null;
    #dataType = null;

    lockerTexture = null;
    #lockerWaitingMsg = COMPONENTS.inputbox.waitingMsg;
    #lockerWaitingStartTime = Date.now();


    lockerTextureIndex = 0;


    #lockerSize = null;

    // static lastReadyingInputBox = null;
    static MODE = {
        omit:2,autoExtend:4, freeze:8,droppable:16,
        initializing:1,editing:128,selecting:256,debugging:512,omitting:1024,


        wait:1024*2,lock:1024*4,ready:1024*8,
    };


    #dataPath = null;
    get Path(){
        return this.#dataPath;
    }
    set Path(value){
        this.#dataPath = value;
    }


    get Mode(){return this.mode;}



    #isLockingToggled = false;
    checkEditingEnd(value){
        const result = super.checkEditingEnd(value) || this.#isLockingToggled;
        this.#isLockingToggled = false;
        return result;
    }
    set Mode(value){



        if(!(this.Mode&InputBox.MODE.lock) && value&InputBox.MODE.lock){
            value |= InputBox.MODE.wait;
            this.lockerTextureIndex = 1;

        }else if((this.Mode&InputBox.MODE.lock) && !(value&InputBox.MODE.lock)){
            value |= InputBox.MODE.wait;
            this.lockerTextureIndex = 0;

        }


        //TODO: wait ==> ready
        if(!(this.Mode&InputBox.MODE.wait)&&(value&InputBox.MODE.wait)){
            // //clean
            // for (let key in TextBox.MODE)
            //     if (/ing$/.test(key))
            //         value &= ~TextBox.MODE[key];
            // value |= InputBox.MODE.wait;

            this.#lockerWaitingStartTime = Date.now();
            //TEST
            if(isTesting)
                setTimeout(_=>this.Mode &= ~InputBox.MODE.wait,2000);
        }
        if((this.Mode&InputBox.MODE.wait)&&!(value&InputBox.MODE.wait)){
            this.#lockerWaitingStartTime = null;

        }


        //TODO: wait ==> ready
        if(!(this.Mode&InputBox.MODE.ready)&&(value&InputBox.MODE.ready));
        if((this.Mode&InputBox.MODE.ready)&&!(value&InputBox.MODE.ready)){
            if(this.#evtSource)
                this.#evtSource.close();
        }



        if((super.Mode&InputBox.MODE.editing)&&!(value&InputBox.MODE.editing)){

            value &= ~InputBox.MODE.ready;

        }



        super.Mode = value;
    }


    constructor(name='__test',params={}){
        super(name,params);
    }

    mousedown(evt){

        // if(this.Mode & InputBox.MODE.wait){
        //     this.Mode |= TextBox.MODE.editing;
        //     this.mouseup(evt);
        // }else

        //TODO: check GC
        if(this.StatusOfMasked &InputBox.STATUS.deleting)
            debugger;

        super.mousedown(evt);
    }

    dblclick(evt){
        //TODO: check GC
        if(this.Status &InputBox.STATUS.deleting)
            debugger;
        super.dblclick(evt);
    }
    get Height(){return super.Height;}
    set Height(val){
        super.Height = val;
        this.Padding.right = this.#lockerSize = val;

        this.Padding.right += this.Padding.left;
        this.#lockerSize -= this.Padding.top + this.Padding.bottom;
    }
    get Width(){return super.Width;}
    set Width(val){
        super.Width = val - this.#lockerSize;
    }

    async initialize() {
        await super.initialize();

        this.fontParams = this.params.fontParams??
            editorSetting.setting.COMPONENTS.inputbox.fontParams;

        const    iconSize = COMPONENTS.locker.size,
            radius = iconSize[0]*0.5;

        this.lockerBG = document.createElement('canvas');
        const ctx = this.lockerBG.getContext("2d");


        this.lockerBG.width = iconSize[0];
        this.lockerBG.height = iconSize[1];
        ctx.beginPath();
        ctx.arc(radius, radius, radius, 0, 2 * Math.PI);
        ctx.fillStyle = 'black';
        ctx.fill();


        this.Padding = this.params.padding??
            editorSetting.setting.COMPONENTS.inputbox.padding;

        this.Padding.right = this.#lockerSize = this.Height;



    }
    static async onLoad(){
        const img = document.getElementById('keanuSrc');
        const lockerTexture = new Texture(img,{
            type:common$1.setting.TYPE.graphic|common$1.setting.TYPE.animation,
            boundary:COMPONENTS.locker.iconSrcBoundary,
            size:COMPONENTS.locker.size});

        await lockerTexture.initialize();

        return Promise.resolve({lockerTexture});
    }

    onFinishLoad({lockerTexture}){
        this.lockerTexture = lockerTexture;
    }

    onEditReady = (evt, element = null)=>{

        const fontParamsStr = JSON.stringify(this.fontParams);
        this.fontParams = JSON.parse(fontParamsStr);
        this.Text = this.getTextWithLocker(this.Value).text;
        this.Mode &= ~InputBox.MODE.wait;
        this.Mode |= InputBox.MODE.ready;


        this.Mode |= TextBox.MODE.editing;
        this.CursorIndex = this.Text.length;

        if(evt.type === 'drop')
            this.drop(evt,element);


        // fnc.call(this,evt);
    }

    onWaitingList = lockerNm=>{
        this.Text = lockerNm;
    }

    onWaitFinish = _=>{

        const fontParamsStr = JSON.stringify(this.fontParams);
        this.fontParams = JSON.parse(fontParamsStr);
        this.Text = this.getTextWithLocker(this.Value).text;
        this.Mode &= ~InputBox.MODE.wait;
    }


    //TODO: catcher middleware function
    onActive(fnc){//wait ===> ready ===> editing
        return evt=>{
            if(this.Mode & InputBox.MODE.wait)
                return;

            if(evt.type == 'mouseup' || evt.type == 'mousemove')
                return fnc.call(this,evt);

            const local = [evt.localX, evt.localY];
            if(evt.target != evt.currentTarget){
                const invMat = create$8();
                invert$2(invMat, this.transform.globalMatrix);
                Transform2D.multiply(local, invMat, [evt.offsetX, evt.offsetY]);
            }

            const [localX,] = local;
            if(localX<this.Width- this.#lockerSize){

                if(this.Mode & InputBox.MODE.lock){ //visual feedback when locked
                    this.Mode |= InputBox.MODE.wait;
                    return;
                }

                if(this.Mode & InputBox.MODE.editing){
                    fnc.call(this,evt);
                    return;
                }

                const startTime = Date.now();


                if(this.Mode & InputBox.MODE.ready)
                    fnc.call(this,evt);
                else {//NOT editing NEITHER ready, DO wait

                    this.Mode |= InputBox.MODE.wait;


                    this.fontParams = editorSetting.setting.COMPONENTS.inputbox.fontParams;
                    this.Text = this.#lockerWaitingMsg;

                    if(lastReadyingInputBox && lastReadyingInputBox!=this){//make sure ONLY one SSE
                        lastReadyingInputBox.Mode &= ~InputBox.MODE.ready;
                        if(lastReadyingInputBox.Mode & InputBox.MODE.wait){
                            if(isTesting){
                                clearTimeout(lastReadyingInputBox.timeoutTest);
                                lastReadyingInputBox.onWaitFinish();
                            }else
                                debugger;
                        }

                    }
                    lastReadyingInputBox = this;
                    if(isTesting){
                        this.onWaitingList('tester');
                        const {element} = JSON.parse(evt.customDataTransfer.getData('dragInfo')??'{}');
                        this.timeoutTest = setTimeout(_=>{
                            if(this.StatusOfMasked & InputBox.STATUS.deleted) return;
                            this.onEditReady(evt, evt.type === 'drop'?element:null);
                        },2000);

                    }else
                        this.#evtSource = setFocusCheckerSSE(this.Path, _=>this.onEditReady(evt), this.onWaitingList, _=>this.onWaitFinish());
                    console.log('focusChecker:', Date.now()-startTime);
                }
            } else if(evt.type == 'mousedown'){
                this.#isLockingToggled = true;
                this.Mode ^= InputBox.MODE.lock;
            }
        };
    }




    initLocker(locker){
        if(locker)
            this.Mode |= InputBox.MODE.lock;
        else
            this.Mode &= ~InputBox.MODE.lock;
    }
    getTextWithLocker(value){
        if(typeof value != 'string')
            value = JSON.stringify(value);
        $assert(value && typeof value == 'string');


        return $readLockerValue(value);
    }



    bind(path,
         dataType = null
    ){

        $assert(path&&dataType);
        this.#dataPath = $path2ID(path);
        $assert(this.#dataPath);
        this.#dataType = dataType;

        return this.bindUpdate();
    }
    bindUpdate(){
        const data = $getAttr$1(this.#dataPath);
        let {text, locker} = this.getTextWithLocker(data);

        this.Text = text;
        this.initLocker(locker);
        return this;
    }


    get Text(){return super.Text;}
    set Text(value){
        if(this.#dataType & DATA_TYPES.path)
            value = $readPath(value).nakedPath;
        super.Text = value;
    }

    get Value(){

        return $getAttr$1(this.#dataPath);
    }

    set Value(value){

        $setAttr(this.#dataPath, value);

    }

    onValidation(newText, isLocking = this.Mode & InputBox.MODE.lock ? true:false) {


        const readOnlyPrefix = isLocking ? LOCKER_CHAR : '',
            fullPath = this.#dataPath;
        let isValid = null;

        if (this.#dataType == null || (this.#dataType & DATA_TYPES.string)){
            isValid = true;
        } else if (this.#dataType & DATA_TYPES.number) {
            if(newText == '') newText = 0;
            isValid = $isNumber$1(newText);
            $assert(isValid, {path: fullPath, msg: `${newText} is not number`});
        } else if (this.#dataType & DATA_TYPES.path) {
            const isExist = $checkFiles(newText),
                    // $getFiles(newText).length ? true : false,
                    fileType = this.#dataType & ~DATA_TYPES.path;
            let isFileTypeValid = true;
            if(fileType)
                isFileTypeValid = FileExt2Meta[$readPath(newText).fileExt] == fileType;

            isValid = isExist && isFileTypeValid;
            $assert(isValid, {path: fullPath, msg: `${fullPath} is not image path`});
        }

        typeof this.Value == 'string' ? this.Value : JSON.stringify(this.Value);

        if(!isValid) return false;

        // if(isSame)
        //     return false;



        this.Text = newText;
        this.Value = readOnlyPrefix + newText;
        return true;
    }





    onChange(text ){
        console.log('onChange:', text);
    }

    async endChange(){
        if(!this.#dataPath)//testing data
            return;
        //setAttr path [attr]:[+10]

        this.Mode |= InputBox.MODE.wait;


        let value = this.Value;
        if (this.#dataType & DATA_TYPES.path){
            value = $path2ID(this.Value);
        }
        await Event$1.Instance.emit(common$1.setting.EVT_TYPES.setAttr, [
            `${this.#dataPath}`, value
        ]);


        if(!isTesting)
            this.Mode &= ~InputBox.MODE.wait;
    }
    getClipPath(boundary){
        return this.clipCapsule(boundary,false);
    }
    clipCapsule(boundary, counterwise){
        const region = new Path2D(),
            rad =  this.Height/2,
            startX = rad,
            startY = rad,
            endX = Math.ceil( this.Width - rad),
            endY = startY;
        region.arc(startX, startY, rad, Math.PI/2, Math.PI*3/2);
        region.lineTo(endX,0);
        region.arc(endX, endY, rad, Math.PI*3/2,Math.PI/2, counterwise?true:false);
        region.lineTo(startX,this.Height);
        return region;
    }
    delete(){
        if(this.#evtSource)
            this.#evtSource.close();
        super.delete();
        this.lockerTexture = null;
        this.#dataPath = null;
        this.#dataType = null;
    }


    draw(ctx,cam){
        ctx.fillStyle = 'gray';
        ctx.fillRect(0,0,this.Width, this.Height);
        this.ctx = ctx;
        const
                MARGIN = 4,
                RENDER_SIZE = this.Height-MARGIN,
                xOffset = this.Width - RENDER_SIZE-MARGIN,
                yOffset = MARGIN/2,
                timeElapsed = (Date.now() - this.#lockerWaitingStartTime)/1000,
                speed = 4, offset = 0.5*Math.PI;




        if(this.Mode & InputBox.MODE.wait){
            this.ctx.save();
            this.ctx.filter = `brightness(${(Math.sin(timeElapsed*speed)+1)*0.5})`;
        }





        if(this.Mode & InputBox.MODE.wait)
            this.ctx.filter = `brightness(${(Math.sin(offset + timeElapsed * speed) + 1) * 0.5})`;


        // if(this.Mode & InputBox.MODE.ready)
        //     this.color = editorSetting.setting.COMPONENTS.textbox.color;
        // else
        //     this.color = 'red';


        // ctx.save();
        // ctx.beginPath();
        //
        // const boundary = this.boundary.slice();
        // boundary[0] += this.Padding.left;
        // boundary[1] += this.Padding.top;
        // boundary[2] -= this.Padding.left + this.Padding.right;
        // boundary[3] -= this.Padding.top + this.Padding.bottom;
        // const region = new Path2D();
        // region.rect(boundary[0], boundary[1], boundary[2], boundary[3]);
        // ctx.clip(region);


        super.draw(ctx,cam);
        // ctx.restore();//beginPath



        if(this.Mode & InputBox.MODE.wait)
            this.ctx.restore();


        this.ctx.drawImage(this.lockerBG,  xOffset,yOffset, RENDER_SIZE, RENDER_SIZE);
        this.ctx.drawImage(this.lockerTexture.Image[this.lockerTextureIndex],  xOffset,yOffset,RENDER_SIZE,RENDER_SIZE);


    }

}

const checkName$1 = (parent,curNode) =>{

    const   children = parent.getConnection(ConnectionType.outputs,'children');
    $assert(!children.find(ele=>ele.name == curNode.name));
};
async function create(name,callback){
    if(Layout.CurLayout.LayoutMode & Layout.LAYOUT_MODE.create&&
        !Layout.CurLayout.Children.toObject()[name]){
        const comp = callback();
        await Layout.CurLayout.appendChild(comp);
        Layout.linkHierachy(Layout.CurLayout, comp, checkName$1);

        await comp.initialize();
        return comp;
    }else if(Layout.CurLayout.Children.toObject()[name]){
        return Layout.CurLayout.Children.toObject()[name];
    }else {
        console.error('name clash', name, 'type:', typeof Layout.CurLayout.Children[name]);
        $assert(false);
    }
}

const __REFRESH_LOCK = {};
let GUI$1 = class GUI{

    static  $clearWindows(){
        const clearJobs = Keanu.editors.array.slice(1)
            .map(win=>new Promise(res=>win.clear()
                .then(_=>win.refresh().then(res()))
            ));

        return Promise.all(clearJobs);
    }

     static async $REFRESH_LOCK_BEGIN(win){
        $assert(win&&win.refresh);
        const release = await lock$1(`${win.name}-delay-refresh.lock`);
        __REFRESH_LOCK[win.FullName] = {target:win,lock:{release}};

         win.__DELAY_REFRESH = true;
    }
     static async $REFRESH_LOCK_END(win){
        const    {target,lock} = __REFRESH_LOCK[win.FullName];

        $assert(target&&target === win&&lock,{msg:'missing DELAY_REFRESH_BEGIN/DELAY_REFRESH_END',path:win.FullName});
        await target.beforeRefresh();

        target.__DELAY_REFRESH = false;
        target.refresh();
        lock.release();
        delete __REFRESH_LOCK[win.FullName];
    }

    static $WINDOW_COMPONENTS_REGISTER = {
        Button:{
            type: DATA_TYPES.button,
            'onCreate':$guiCatcher($CREATE_BUTTON),
            'onUpdate':null,
            'onDelete':null,
        },
        QR:{
            type: DATA_TYPES.QR,
            'onCreate':$guiCatcher(genQR),
            'onUpdate':null,
            'onDelete':null,
        },
        InputBox:{
            type: DATA_TYPES.string|DATA_TYPES.number|DATA_TYPES.path,
            'onCreate':$guiCatcher($CREATE_INPUT_BOX),//$guiCatcher(createInputBox),
            'onUpdate':updateInputBox,
            'onDelete':null,
        },
        AutoTile:{
            type:DATA_TYPES.autoTile,
            'onCreate':$guiCatcher(genAutoTile),
            'onUpdate':null,
            'onDelete':null,
        },
        Tile:{
            type: DATA_TYPES.tile,
            'onCreate':$guiCatcher(genTile),
            'onUpdate':null,
            'onDelete':null,
        },
        Palette:{
            type: DATA_TYPES.palette,
            'onCreate':$guiCatcher(genPalette),
            'onUpdate':null,
            'onDelete':null,

        }
    };


    static  $getFncByType(type, state){
        $assert(type&&state);
        for(const key in GUI.$WINDOW_COMPONENTS_REGISTER){
            const comp = GUI.$WINDOW_COMPONENTS_REGISTER[key];
            if( comp.type & type)
                return comp[state];
        }
        return null;
    }


    static Button = (name = 'unnamed',params = {width: 100, height: 30}) =>create(name,_=> new Button(name, params));

    static TextBox = (name = 'unnamed', params={width:100, height:30, mode :TextBox.MODE.omit}) =>create (name,_=>new TextBox(name, params));

    static InputBox = (name = 'unnamed', params={width:100, height:30, mode :InputBox.MODE.omit|InputBox.MODE.droppable}) => create (name,_=>new InputBox(name, params));

    static Component = (name = 'unnamed', params = {width: 100, height: 30}) => create (name,_=>new Component(name, params));

    static Image = (name = 'unnamed',params = {width: 30, height: 30, img:'null'}) => create (name,_=>new KImage(name, params));

    static Label = (name = 'unnamed',params = {width: 100, height: 30, text:'null'})=> create (name,_=>new Label(name, params));



};



GUI$1.$register = function(cls,name = 'unnamed',params={}){
    $assert(isImplement(cls, Component));
    GUI$1[cls.name] = (name,params)=> create(name,_=>new cls(name,params) );
};

window.GUI = GUI$1;

class AutoTilePreview extends implement(Component){

    alpha = 1;
    targetBoundary = null;
    path = null;

    constructor(name='__test',params={}){
        super(name,params);
        this.path = params.path;
        this.status |= common$1.setting.BASIC_STATUS.visible;
    }

    async setImg(img){
        await this.#delLabel();
        const contentRaw = new KImage('contentRaw', {img, ratio:1, layoutMode:Layout.LAYOUT_MODE.resizeX|Layout.LAYOUT_MODE.resizeY|Layout.LAYOUT_MODE.lockRatio});
        await this.appendChild(contentRaw);
        await contentRaw.initialize();
        Layout.linkHierachy(this, contentRaw);
    }
    #addLabel(){
        const previewLabel = new Label('dropLabel', {
            text: 'drop',
            color: 'rgba(0,0,0,0)',
            fontParams: editorSetting.setting.INSPECTOR.autoTileLayout.fontParams,
            layoutMode: Layout.LAYOUT_MODE.resizeX,
            height: editorSetting.setting.INSPECTOR.autoTileLayout.ruleHeight
        });
        this.appendChild(previewLabel);
        previewLabel.initialize();
        Layout.linkHierachy(this, previewLabel);
    }
    async #delLabel(){
        const previewLabel = this.Children.find(ele=>ele instanceof Label);
        if(previewLabel){
            Layout.clearHierachy(previewLabel);
            await this.removeChild(previewLabel);
        }
    }
    async initialize(){

        await super.initialize();
        this.LayoutMode = this.params.layoutMode ?? Layout.LAYOUT_MODE.vertical;
        this.color = this.params.color?? editorSetting.setting.INSPECTOR.autoTileLayout.previewColor;

        this.#addLabel();


        let interval = null;
        const clear = interval=>{
            if(interval){
                clearInterval(interval);
                this.color = 'black';
                this.alpha = 1;
                interval = null;
            }
        };
        this.addEventListener("over", evt=>{
            const time = Date.now();
            this.color = 'grey';
            interval = $animate(_=> this.alpha = ((Math.sin(8*(Date.now()-time)/1000)+1)*0.5).clamp(0.4,1));
            setTimeout(_=> clear(interval),1000);
        });
        this.addEventListener("out", evt=>clear(interval));


        this.addEventListener('drop', evt=>{

            const aBrPath = this.params['path'],
                tBrSource = $getAttr(aBrPath)['source'],
                dragInfo = evt.customDataTransfer.getData('brushDrag');
            if(!dragInfo)
                return;



            $findParentByType(this, Inspector);

            $assert(this.path);
            const {source, boundary} = JSON.parse(dragInfo),
                ruleRankIndex = this.params.ruleRankIndex;


            if(tBrSource != source)
                return;



            // this.clear();
            // inspector.refresh();
            this.#delLabel();
            evt.stopImmediatePropagation();

            //TODO: validate source
            Event$1.Instance.emit(common$1.setting.EVT_TYPES.setAttr,[
                `${this.path}|autoTile|${ruleRankIndex}`, {
                    boundary
                }
            ]);
        });

    }

    delete(){

        this.color = null;
        super.delete();
    }


    // draw(ctx,cam){
    //     this.ctx = ctx;
    //     this.fillStyle  = this.color;
    //     this.ctx.globalAlpha = this.alpha;
    //     this.ctx.fillRect(this.boundary[0],this.boundary[1],this.boundary[2],this.boundary[3]);
    // }
}
GUI$1.$register(AutoTilePreview);

class AutoTileRule extends implement(Component,ILoad){

    ruleMatrix = [0,1,0,   1,-1,1,    0,1,0]; //topRow midRow bottomRow
    checkerImg = null;
    color = null;


    onRuleChange =_=>{

    }

    constructor(name='__test',params={}){
        super(name,params);
        this.status |= common$1.setting.BASIC_STATUS.visible;
    }
    static async  onLoad(){
        const img = document.getElementById('keanuSrc'),
            crossCheckerBoundary = editorSetting.setting.INSPECTOR.autoTileRule.crossCheckerBoundary.slice(),
            leftCheckerBoundary = editorSetting.setting.INSPECTOR.autoTileRule.leftCheckerBoundary.slice(),
            leftBottomCheckerBoundary = editorSetting.setting.INSPECTOR.autoTileRule.leftBottomCheckerBoundary.slice(),
            size = editorSetting.setting.INSPECTOR.autoTileRule.checkerSize;
        const   backupCanvas = document.createElement('canvas');
                backupCanvas.width = backupCanvas.height = editorSetting.setting.INSPECTOR.autoTileRule.checkerSize*3;
        const   ctx = backupCanvas.getContext('2d');
        ctx.imageSmoothingEnabled = false;


        //upperLeft
        ctx.save();
        ctx.scale(1, -1);
        ctx.drawImage(img,...leftBottomCheckerBoundary, 0, -size, size,size);
        ctx.restore();



        //upperMid
        ctx.save();
        ctx.translate(size,0);
        ctx.rotate(degree2Rad(90));
        ctx.drawImage(img,...leftCheckerBoundary, 0, -size, size,size);
        ctx.restore();


        //upperRight
        ctx.save();
        ctx.translate(size*2,0);
        ctx.scale(-1, -1);
        ctx.drawImage(img,...leftBottomCheckerBoundary, -size, -size, size,size);
        ctx.restore();


        //midLeft
        ctx.drawImage(img,...leftCheckerBoundary, 0, size, size,size);

        //mid
        ctx.drawImage(img,...crossCheckerBoundary, size, size, size,size);

        //midRight
        ctx.save();
        ctx.translate(size*2,size);
        ctx.scale(-1, 1);
        ctx.drawImage(img,...leftCheckerBoundary, -size, 0, size,size);
        ctx.restore();



        //bottomLeft
        ctx.drawImage(img,...leftBottomCheckerBoundary, 0, size*2, size,size);

        //bottomMid
        ctx.save();
        ctx.translate(0,size*3);
        ctx.rotate(degree2Rad(-90));
        ctx.drawImage(img,...leftCheckerBoundary, 0, size, size,size);
        ctx.restore();


        //bottomRight
        ctx.save();
        ctx.translate(size*2,size*2);
        ctx.scale(-1, 1);
        ctx.drawImage(img,...leftBottomCheckerBoundary, -size, 0, size,size);
        ctx.restore();


        return Promise.resolve(backupCanvas);
    }
    onFinishLoad(data){
        this.checkerImg = data;
    }


    async initialize(){

        await  super.initialize();

        this.Color = this.params.color?? editorSetting.setting.COMPONENTS.color;

        this.ruleMatrix = this.params.ruleMatrix??[0,1,0,   1,-1,1,    0,1,0];

        this.addEventListener('click',evt=>{
            const size = editorSetting.setting.INSPECTOR.autoTileRule.checkerSize,
                    row = Math.floor(evt.localY/size),
                    col = Math.floor(evt.localX/size);

            if(row == 1 && col == 1)
                return;

            const loop = [-1,0,1],
                loopIndex = loop.findIndex(ele=>ele==this.ruleMatrix[row*3+col]);
            this.ruleMatrix[row*3+col] = loop[(loopIndex+1)%3];

            this.onRuleChange(this.ruleMatrix);

        });
    }

    delete(){

        super.delete();
        this.color = null;
        this.textOffset = null;
        this.checkerImg = null;
    }


    draw(ctx,cam){
        this.ctx = ctx;


        //batch draw horizontal line
        const size = editorSetting.setting.INSPECTOR.autoTileRule.checkerSize, lineWidth = 1;

        ctx.save();

        for(let row = 0 ; row < 3; row++){
            for(let col = 0 ; col < 3; col++) {

                if(this.ruleMatrix[row*3+col] == 1) //paint green arrow
                    this.ctx.drawImage(this.checkerImg, col*size, row*size, size, size, col*size, row*size, size, size);

                if(this.ruleMatrix[row*3+col] == -1) //paint cross
                    this.ctx.drawImage(this.checkerImg, size, size, size, size, col*size, row*size, size, size);
            }
        }



        ctx.strokeStyle = 'black';
        ctx.lineWidth = lineWidth;

        ctx.translate(-0.5,-0.5);
        for(let row = 0; row<= 3;row++){
            ctx.beginPath();
            const width = 3*size,
                    y = row*size;
            ctx.moveTo(0,y);
            ctx.lineTo(width,y);
            ctx.stroke();
        }


        for(let col = 0; col<= 3;col++){
            ctx.beginPath();
            const height = 3*size,
                x = col*size;
            ctx.moveTo(x, 0);
            ctx.lineTo(x,height);
            ctx.stroke();
        }


        ctx.restore();


    }
}
GUI$1.$register(AutoTileRule);

const   mul = mul$2,invert = invert$2;
class Camera2d extends implement(Element2d,ICamera, IConnection){
    matrix = null;
    projectionMat = null;
    viewMatrix = null;

    width = null;
    height = null;

    originWidth = null;
    originHeight = null;

    scale = [1,1];
    get Matrix(){return this.matrix;};
    get ViewMatrix(){return this.viewMatrix;};
    get ProjectionMatrix(){return this.projectionMat;};


    constructor(name='__test',params) {
        super(name,params);

        this.initConnection(cameraConnection);
    };
    delete(){

        this.matrix = null;
        this.projectionMat = null;
        this.viewMatrix = null;
    }

    set Width(val){//reset
        this.width = this.originWidth = val;
    }

    set Height(val){//reset
        this.height = this.originHeight = val;
    }

    set TargetWidth(val){
        this.width = val;
        this.update();
    }
    set TargetHeight(val){
        this.height = val;
        this.update();
    }

    get Width(){
        return this.width;
    }
    get Height(){
        return this.height;
    }


    update(){

        //sx,   0,      sx*tx
        //0,    sy,     sy*ty
        //0,    0,      1
        // math.mat2d.multiply(this.projectionMat,
        //     [this.scale[0], 0, 0, this.scale[1], 0, 0],
        //     [1, 0, 0, 1, 0.5*this.targetWidth, -0.5*this.targetHeight]);

        this.scale = [this.width/this.originWidth, this.height/this.originHeight];


        multiply$3(this.projectionMat,
            [this.scale[0], 0, 0, this.scale[1], 0, 0],
            [1, 0, 0, 1, 0,0]);
    }

    async initialize(){
        await super.initialize();
        this.matrix = create$8();
        this.projectionMat = create$8();
        this.viewMatrix = create$8();
        this.scale = [1,-1];

        this.Width = this.params.width??editorSetting.setting.MIN_WIDTH;
        this.Height = this.params.height??editorSetting.setting.MIN_HEIGHT;
        this.update();

        // // this.setConnection(ConnectionType.outputs,'localMatrix',this.Matrix);
        // //inv scale
        // this.transform = new Transform2D(this.name+'-transform',{updateCallback:()=>{
        //
        //     //wrt to camera.Matrix
        //     Transform2D.inverse(this.viewMatrix, this.transform);
        //     mul(this.matrix,this.projectionMat, this.viewMatrix);
        //
        //
        //
        //     //kCanvas.js line 64&line 65
        //     const transform = this.getConnection(ConnectionType.inputs,'transform');
        //     $assert(transform);
        //     transform.update(false);//update children
        // }});
        // this.transform.setConnection(ConnectionType.inputs,'object',this);


        this.transform.UpdateCallback = ()=>{

            //wrt to camera.Matrix
            // Transform2D.inverse(this.viewMatrix, this.transform);
            invert$2(this.viewMatrix, this.transform.globalMatrix);

            mul(this.matrix,this.projectionMat, this.viewMatrix);



            //kCanvas.js line 64&line 65
            const transform = this.getConnection(ConnectionType.inputs,'transform');
            $assert(transform);
            transform.update(false);//update children
        };

    }



    // V        = [t] [p]       [RS]            [-p]
    // V^-1     = [p]           [RS]^-1         [-p-t]
    //          = [T`] [P`]   [RS]^-1         [-P`]

    setPivot(pivot){
        const invMat= this.viewMatrix.slice(),
            invTransform = new Transform2D();
        Transform2D.set(invTransform, invMat);
        invTransform.insertPivot(pivot);


        const Tinv = invTransform.position;

        invert(invMat, invMat);


        const   RS00 = invMat[0], RS10 = invMat[2],
                RS01 = invMat[1], RS11 = invMat[3],

                px = pivot[0]+Tinv[0],//[P`x]
                py = pivot[1]+Tinv[1],//[P`y]

                tx = invMat[4] - (RS00*-px + RS01*-py  + px),
                ty = invMat[5] - (RS10*-px + RS11*-py  + py);

        this.transform.position[0] = tx,
        this.transform.position[1] = ty;
        this.transform.Pivot = [px,py];//already call update() inside the Pivot setter

        //TODO: these should be equal
        // invert(this.viewMatrix, this.transform.Matrix);
        // $assert(math.mat2d.equals(this.viewMatrix, invTransform.localMatrix));
    }


    set Scale(value) {


    };

    get Scale() {
        return this.scale;
    }

    unproject(out,pos) {
        let invM = [1,0,0,1,0,0];
        invert$2(invM, this.matrix);
        transformMat2d(out, pos, invM);

        return out;

    };


    pick(point,dynamicTree,radius=2){
        $assert($isNumber$1(point[0]) && $isNumber$1(point[1]));

        let pos = point.slice();

        this.unproject(pos,pos);




        let aabb = [pos[0]-radius,pos[1]-radius, pos[0]+radius,pos[1]+radius],
            dummy = {Transform:new Transform2D(),MassCenter:pos, Type:common$1.setting.SHAPE_TYPE.sphere,Radius:radius},
            proxy = {aabb:aabb,shape:dummy};
        let sphereId = dynamicTree.addProxy(proxy)
            , pickList = [];


        dynamicTree.query(sphereId,function(nodeId,sphereId){


            let proxyA = dynamicTree.nodes[nodeId].proxy,
                proxyB = dynamicTree.nodes[sphereId].proxy;



            let pair = {nodeIndexA:nodeId,nodeIndexB:sphereId, contactStatus:0};
            let type = proxyA.shape.Type+proxyB.shape.Type;
            let solveFnc;
            switch (type){
                case common$1.setting.SHAPE_TYPE.edge+common$1.setting.SHAPE_TYPE.sphere:
                    solveFnc = helper$1.collideEdgeAndCircle;
                    break;
                case common$1.setting.SHAPE_TYPE.sphere+common$1.setting.SHAPE_TYPE.sphere:
                    solveFnc = helper$1.collideCircles;
                    break;
                case common$1.setting.SHAPE_TYPE.sphere+common$1.setting.SHAPE_TYPE.poly:
                    solveFnc = helper$1.collideCircleAndPolygon;
                    break;
                default:
                    throw new Error('unknown pair types');
            }

            if(solveFnc(dynamicTree,{},pair))
                pickList.push(dynamicTree.nodes[nodeId].proxy.shape.Parent);




        });
        dynamicTree.delNode(sphereId);

        return pickList;
    }

    // zoom(value) {
    //     this.scale[0] *= value;
    //     this.scale[1] *= value;
    //     // this.offset[0] *= value; this.offset[1] *= value;
    //     this.halfWidth *= 1 / value;
    //     this.halfHeight *= 1 / value;
    //     mul(this.projectionMat,[this.scale[0], 0, 0, this.scale[1], 0, 0], [1, 0, 0, 1, this.halfWidth, -this.halfHeight]);
    // };

    // move(input) {
    //     if (input) {
    //         let target = [input[0], input[1]];
    //         this.position[0] = target[0];
    //         this.position[1] = target[1];
    //         // target[0] += this.offset[0];
    //         // target[1] += this.offset[1];
    //
    //         this.transform.set(target);
    //     }
    //     let invMat = this.transform.toInvMat();
    //     mul(this.projectionMat, invMat, this.matrix);
    // };
}

class KCanvas extends implement(Component, IUICanvas, IPanelContainer){
    camera = null;
    drawHandler = null;

    renderables = [];
    get Renderables(){return this.renderables;}

    get Camera(){return this.camera;}
    set Width(val){
        super.Width = val;
        if(this.camera){
            // this.camera.Width = this.camera.TargetWidth = val;
            this.camera.Width =  val;
            this.camera.update();
        }
    }

    set Height(val){
        super.Height = val;
        if(this.camera){
            // this.camera.Height = this.camera.TargetHeight = val;
            this.camera.Height =  val;
            this.camera.update();
        }
    }

    get Width(){return super.Width;}
    get Height(){return super.Height;}

    get ContentLayout(){return this.group;}
    constructor(name='__test',params={}){
        // params.isRegist = false;
        super(name,params);

    }
    async  initialize() {
        await super.initialize();

        this.status |= common$1.setting.STATUS.clippingWindow;

        this.camera = new Camera2d(this.name + '-camera',
            {width:this.Width,height:this.Height});
        this.camera.initialize();


        this.group = new Controllable$1('group');
        uiAddChild.call(this, this.group); //equals to: super.appendChild(this.group);

        const controller = $findParentByType(this.group, Controller);
        if(controller)
            await Event$1.Instance.emit(common$1.setting.EVT_TYPES.onControllerAttached, this.group, [controller]);
        this.group.initialize();


        this.camera.setConnection(ConnectionType.inputs,'transform',this.group.transform);
        this.group.transform.setConnection(ConnectionType.inputs, 'localMatrix', this.camera.Matrix);



    }



    setConnection(...params){
        this.group.setConnection(...params);
    }
    getConnection(...params){
        this.group.getConnection(...params);
    }

    async appendChild(child){
        uiAddChild.call(this.group, child);
        const controller = $findParentByType(this, Controller);
        if(controller) {
            // const decendents = depthFirstSearch(child,
            //     ele=> !checkStatus(ele.Status, common.setting.STATUS.deleting));
            await Event$1.Instance.emit(common$1.setting.EVT_TYPES.onControllerAttached, child, [controller]);
        }
    }

    async insertChild(index, child){
        uiInsertChild.call(this.group, index,child);
        const controller = $findParentByType(this, Controller);
        if(controller) {
            // const decendents = depthFirstSearch(child,
            //     ele=> !checkStatus(ele.Status, common.setting.STATUS.deleting));

            await Event$1.Instance.emit(common$1.setting.EVT_TYPES.onControllerAttached, child, [controller]);
        }

    }

    async removeChild(child){
        $assert(child);
        if(this.group === child)
            uiDelChild.call(this,child);
        else
            uiDelChild.call(this.group, child);
        const controller = $findParentByType(this, Controller);
        if(controller){
                await Event$1.Instance.emit(common$1.setting.EVT_TYPES.onControllerDetached,child, [controller, child]);
        }
    }



    refresh(){
        this.group.boundary = [0,0,0,0];
        refreshBoundary(this.group,
                target=>checkStatus$1(target.Status, common$1.setting.UI_STATUS.layoutable),['x','y']);

        const renderable = depthFirstSearch(this.group,
            ele=>isImplement(ele, IDrawable)&&
                checkStatus$1(ele.Status, common$1.setting.STATUS.visible));


        this.Renderables.length = 0;
        this.Renderables.push(...renderable.sort((a,b)=>a.RenderIndex-b.RenderIndex));
    }



    delete(){
        this.renderables.length = 0;
        super.delete();
        this.camera = null;
    }
    async clear(){

        let children = this.group.Children.slice();
        for (let i = children.length - 1; i >= 0; i--)
            await children[i].delete();

    }



    draw(ctx,cam){
        // super.draw(ctx,cam);


        ctx.save();
         this.Renderables.forEach(child => {

            child.preDraw(ctx, cam);
            child.draw(ctx, cam);
            child.postDraw(ctx, cam);

        });
        ctx.restore();


    }
}

const DEFAULT$2 = Layout.LAYOUT_MODE.vertical|Layout.LAYOUT_MODE.resizeX|Layout.LAYOUT_MODE.expandY;

class AutoTileLayout extends implement(DraggableLayout){

    static  begin = function(name = 'layout', params={
            color:editorSetting.setting.COMPONENTS.layout.color,
            layoutMode:DEFAULT$2}) {
        return Layout.begin.call(AutoTileLayout,name, params);
    }


    constructor(name='unnamed', params = {}){
        super(name, params);
    }

    onAdd =_=>{};
    onDel =_=>{};

    async test(){
        debugger;
        const layoutMode = Layout.LAYOUT_MODE.horizontal|Layout.LAYOUT_MODE.resizeX|Layout.LAYOUT_MODE.expandY,
            layout = new Layout('rule1', {
                layoutMode,
                color:'white',
                margin:{left:0,right:0,top:1,bottom:1}
            });
        await this.appendChild(layout);
        await layout.initialize();
        Layout.linkHierachy(this, layout);

        const label = new TextBox(getPaddingNum(layout.name).toString(),{
            width:100,
            height:editorSetting.setting.INSPECTOR.autoTileLayout.ruleHeight,
            mode :TextBox.MODE.freeze,
        });
        await layout.appendChild(label);
        await label.initialize();
        Layout.linkHierachy(layout, label);


        const checker = new AutoTileRule('checker',{
            width:editorSetting.setting.INSPECTOR.autoTileLayout.checkerSize,
            height:editorSetting.setting.INSPECTOR.autoTileLayout.checkerSize,
            margin:{left:6,right:6,top:6,bottom:6}
        });
        await layout.appendChild(checker);
        await checker.initialize();
        Layout.linkHierachy(layout, checker);



        const preview = new AutoTilePreview('previewLayout',{
            width:editorSetting.setting.INSPECTOR.autoTileLayout.checkerSize,
            height:editorSetting.setting.INSPECTOR.autoTileLayout.checkerSize,
            margin:{left:6,right:6,top:6,bottom:6},
        });
        await layout.appendChild(preview);
        await preview.initialize();
        Layout.linkHierachy(layout, preview);

        const previewLabel =  new Label('dropLabel', {
            text:'drop',
            color:'rgba(0,0,0,0)',
            fontParams:editorSetting.setting.INSPECTOR.autoTileLayout.fontParams,
            layoutMode:Layout.LAYOUT_MODE.resizeX,
            height:editorSetting.setting.INSPECTOR.autoTileLayout.ruleHeight
        });
        await preview.appendChild(previewLabel);
        await previewLabel.initialize();
        Layout.linkHierachy(preview, previewLabel);


        refreshWindow(this);
    }
    async initialize() {
        await super.initialize();


        this.addBtn = new Label(this.name + '_title', {
            text:'+',
            height:editorSetting.setting.COMPONENTS.foldableLayout.titleHeight,
            layoutMode:Layout.LAYOUT_MODE.lockRatio
        });

        await this.titleLayout.appendChild(this.addBtn);
        this.addBtn.initialize();
        Layout.linkHierachy(this.titleLayout, this.addBtn);

        this.addBtn.addEventListener('click',_=>{

            $assert(this.Path);
            const   autoTileData =$getAttr(this.Path),
                    dataIndex = autoTileData.length;

            this.onAdd(dataIndex);


            // if(this.path) {
            //
            //     const autoTileData =$getAttr(this.path),
            //         dataIndex = autoTileData['autoTile'].length;
            //
            //
            //
            //     this.onAdd(dataIndex);
            // }else
            //     this.test();


        });






        this.delBtn = new Label(this.name + '_title', {
            text:'-',
            height:editorSetting.setting.COMPONENTS.foldableLayout.titleHeight,
            layoutMode:Layout.LAYOUT_MODE.lockRatio
        });

        await this.titleLayout.appendChild(this.delBtn);
        this.delBtn.initialize();
        Layout.linkHierachy(this.titleLayout, this.delBtn);

        this.delBtn.addEventListener('click',_=>{
            if(!this.path)
                return;

            this.onDel();
        });



    }

}

const MAXSCROLL = editorSetting.setting.CANVAS_SCALE_MAXSCROLL,
    SCALE = editorSetting.setting.CANVAS_MAXSCALE;
class Canvas2DLayout extends implement(Layout){//interfaces.IDrawable

    contentLayout = null;

    scrollY = 0;


    get ContentLayout(){return this.contentLayout;}

    constructor(name='unnamed', params={layoutMode:Layout.LAYOUT_MODE.vertical|Layout.LAYOUT_MODE.resizeX|Layout.LAYOUT_MODE.resizeY}) {
        super(name, params);
    }

    async initialize() {
        await super.initialize();


        //////////////////////////////////////////////////////////////
        //------------------- ==== bodyLayoutV      //////////////////
        // ==================           |
        //                              |
        //                              |
        // KCanvas                      |
        //                              |
        //                              |
        // ==================           |
        //-------------------- ==== bodyLayoutV     //////////////////
        //////////////////////////////////////////////////////////////
        //////////////////////////////////////////////////////////////

        this.name;
        this.contentLayout = new KCanvas('kCanvas', {layoutMode:Layout.LAYOUT_MODE.resizeY|Layout.LAYOUT_MODE.resizeX});
        await this.appendChild(this.contentLayout);
        await this.contentLayout.initialize();

        //TEST
        // this.contentLayout.Camera.transform.position[1] =  -50;
        // this.contentLayout.Camera.transform.update();


    }
    onDrag(evt, press=_=>{}, move=_=>{}, stop=_=>{}){
        // const controller = $findRoot(this).Controller;
        // $assert(controller);

        press(evt.localX,evt.localY);
        const


            _move = evt=>{
                $screenCoord2Local(evt, this);
                move(evt.localX, evt.localY);
            },_stop = evt=>{
                Controller.removeEventListener('move', _move);
                Controller.removeEventListener('release', _stop);

                $screenCoord2Local(evt, this);
                stop(evt.localX, evt.localY);
            };


        Controller.addEventListener("release", _stop);
        Controller.addEventListener("move", _move);
    }


    async clear(){
        this.scrollY = 0;

        const transform =  this.contentLayout.Camera.transform;
        transform.clear();


        let children = this.contentLayout.group.Children.slice();
        for (let i = children.length - 1; i >= 0; i--)
            await children[i].delete();



        const connType = ConnectionType;
        this.contentLayout.group.deleteConnection(connType.inputs, 'children');


    }

    updateScrollY(deltaY){
        this.scrollY += deltaY;
        this.scrollY = this.scrollY.clamp(-MAXSCROLL,MAXSCROLL);

    }
    setScale(scale){
        let scrollRatio = 0;
        if(scale>1)
            scrollRatio = (scale-1)/(SCALE-1);
        else
            scrollRatio = (scale-1)/(1/SCALE-1);

        this.oldY = this.scrollY;

        this.scrollY = scale>1? scrollRatio*MAXSCROLL: -scrollRatio*MAXSCROLL;

        // if(Math.abs(this.scrollY-this.oldY)>50) debugger;
        console.log(`==== ==== ==== ==== ==== ==== ==== scale ${scale.toFixed(2)}, scrollY ${this.scrollY.toFixed(2)} `);
    }

    getScale(scrollY = this.scrollY){
        let scale, scrollRatio = Math.abs(scrollY).clamp(0,MAXSCROLL) / MAXSCROLL;
        if(scrollY>= 0)
            scale = scrollY.lerp(scrollRatio, 1, SCALE);
        else
            scale =  scrollY.lerp(scrollRatio,1,1/SCALE);
        return scale;
    }

    scaleUpdateCanvas(evt = {}, targetPivot = [0,0]){
        const transform =  this.contentLayout.Camera.transform;

        Transform2D.multiply(targetPivot, transform, targetPivot);
        this.contentLayout.Camera.setPivot(targetPivot);
        const TOUCH_STATE = Controller.TOUCH_STATE;

        const IS_TRACK_PAD = window.Menu.btns['menu/inputStatus/trackpad'].Status;

        if(evt.controller && (evt.controller.touchState & TOUCH_STATE.gesture) && evt.gesture && IS_TRACK_PAD){
            $assert($isNumber$1(evt.gesture.scale));
            // console.log('evt.gesture.scale',evt.gesture.scale);
            transform.scale[0] = transform.scale[1] = evt.gesture.scale;
        }else
            transform.scale[0] = transform.scale[1] = this.getScale();
        transform.update();
    }

    moveCanvas(x,y){

        const transform = this.contentLayout.Camera.transform,
            scale = transform.scale[0];

        transform.position[0] += scale*x;
        transform.position[1] += scale*y;
        transform.update();
    }

    refresh(){
        super.refresh();
        this.contentLayout.refresh();
    }



}

class ListLayout extends implement(Layout,IDrawable, IPanelContainer){//


    // renderIndex = 0;
    //
    // renderables = [];
    // get Renderables(){return this.renderables};



    // get Spacing(){return 0;}


    get ContentLayout(){return this.group;}


    constructor(name='unnamed', params={
        isIndent:false,
        layoutMode:Layout.LAYOUT_MODE.vertical|Layout.LAYOUT_MODE.resizeX|Layout.LAYOUT_MODE.resizeY ,
        margin:{left:0,right:0,top:0,bottom:0},
    }){
        super(name,params);



    }

    async initialize(){
        await super.initialize();

        // this.status |= common.setting.STATUS.clippingWindow;
        const LAYOUT_MODE = Layout.LAYOUT_MODE;
        this.LayoutMode =
            LAYOUT_MODE.vertical|LAYOUT_MODE.resizeX|LAYOUT_MODE.resizeY;


        this.group = new Layout('group', {layoutMode:LAYOUT_MODE.vertical|LAYOUT_MODE.resizeX|LAYOUT_MODE.resizeY});
        uiAddChild.call(this, this.group);// equals to: super.appendChild(this.group);
        await this.group.initialize();
        const controller = $findParentByType(this.group, Controller);
        if(controller)
            await Event$1.Instance.emit(common$1.setting.EVT_TYPES.onControllerAttached, this.group,[controller]);

    }




    sort(sorter){
        this.group.Children.length = 0;


        const children = depthFirstSearch(this,
                ele =>ele instanceof EntryLayout,
                ele=>{
                    const children = ele.getConnection(ConnectionType.outputs,'children');
                    children.sort(sorter);
                    return children;
                });

        this.group.Children.values = children;
    }


    refresh(){
        super.refresh(this.group.Children);//
        this.group.boundary = [0,0,0,0];
        refreshBoundary(this.group, target=>checkStatus$1(target.Status, common$1.setting.UI_STATUS.layoutable),['x','y'], {depth:1});

        let children =  this.group.Children.filter(ele=>
            !getParentsOf(ele, _=>true, el=>el.getConnection(ConnectionType.inputs,'parent'))
            .find(ele=>!(ele.StatusOfMasked & common$1.setting.STATUS.visible)));

        children = children.filter(ele=>!(ele.StatusOfMasked & common$1.setting.STATUS.deleting));

        if(children.length){
            const arr = children.sort((a,b)=>b.Boundary[2] - a.Boundary[2]),
                MAXLENGTH = arr[0].Boundary[2]<this.Width?this.Width:arr[0].Boundary[2];
            for(const entry of children)
                if(entry.LayoutMode & Layout.LAYOUT_MODE.resizeX)
                    entry.Boundary[2] =  MAXLENGTH;
        }


        const renderable =
                depthFirstSearch(this.group,
                ele=> checkStatus$1(ele.Status, common$1.setting.STATUS.visible)&&
                    !checkStatus$1(ele.Status, common$1.setting.STATUS.clippingWindow));
        // renderable.shift();
        renderable.push(... children.filter(ele=>checkStatus$1(ele.Status, common$1.setting.STATUS.clippingWindow)&&
                                                checkStatus$1(ele.Status, common$1.setting.STATUS.visible)));

        this.Renderables.length = 0;
        this.Renderables.push(... renderable.filter(ele=>isImplement(ele, IDrawable)).sort((a,b)=>a.RenderIndex-b.RenderIndex));



    }


    delete(){
        this.renderables.length = 0;
        super.delete();
    }


    async clear(){

        this.renderables.length = 0;
        let children = this.group.Children.slice();
        for (let i = children.length - 1; i >= 0; i--)
            await children[i].delete();
    }


    draw(ctx,cam){
        ctx.save();
        const boundary = [0,0,0,0];

        Transform2D.multiply(boundary, this.transform.globalMatrix, this.boundary);
         this.Renderables.forEach(child => {
             const childBoundary = [0,0,0,0];
             //const child = this.Renderables.find(ele=>ele.text == 'jimmy');
             Transform2D.multiply(childBoundary, child.transform.globalMatrix, child.boundary);


             if(!$isBoundaryOverlap(boundary, childBoundary))
                 return true; //continue
            child.preDraw(ctx, cam);
            child.draw(ctx, cam);
            child.postDraw(ctx, cam);

        });
        ctx.restore();
    }






    //////////////////////////////////////////////////////////////////////
    //////////////////////////////////////////////////////////////////////
    //////////////////////////////////////////////////////////////////////
    //////////////////////////////////////////////////////////////////////
    //////////////////////////////////////////////////////////////////////
    // setConnection(...params){
    //     return this.group.setConnection(...params);
    // }
    // getConnection(...params){
    //     return this.group.getConnection(...params);
    // }
    async appendChild(child){
        uiAddChild.call(this.group, child);

        const controller = $findParentByType(this, Controller);
        if(controller) {
            // const decendents = depthFirstSearch(child,
            //     ele=> !checkStatus(ele.Status, common.setting.STATUS.deleting));
            //
            // for(const decendent of decendents)
                await Event$1.Instance.emit(common$1.setting.EVT_TYPES.onControllerAttached, child, [controller]);
        }
    }

    async insertChild(index, child){
        uiInsertChild.call(this.group, index,child);
        const controller = $findParentByType(this, Controller);
        if(controller) {
            // const decendents = depthFirstSearch(child,
            //     ele=> !checkStatus(ele.Status, common.setting.STATUS.deleting));
            //
            // for(const decendent of decendents)
                await Event$1.Instance.emit(common$1.setting.EVT_TYPES.onControllerAttached, child, [controller]);
        }

    }

    async removeChild(child){
        $assert(child);

        if(this.group === child)
            uiDelChild.call(this,child);
        else
            uiDelChild.call(this.group, child);
        const controller = $findParentByType(this, Controller);
        if(controller){
            // const decendents = depthFirstSearch(child);
            // for(const decendent of decendents)
            //     Event.Instance.emit(common.setting.EVT_TYPES.onControllerDetached,decendent, [controller]);//[controller,decendent,this,decendents]

            await Event$1.Instance.emit(common$1.setting.EVT_TYPES.onControllerDetached,child, [controller]);

        }
    }

    //////////////////////////////////////////////////////////////////////
    //////////////////////////////////////////////////////////////////////
    //////////////////////////////////////////////////////////////////////
    //////////////////////////////////////////////////////////////////////
}

const OUTLINE$2 = editorSetting.setting.OUTLINE;
const DEFAULT$1 = Layout.LAYOUT_MODE.horizontal|Layout.LAYOUT_MODE.resizeX;
const MODE = {
    error:1,folder:2,layer:4, file:8, folding:16,cmd:32,selecting:64
};


class SelectableLayout extends implement(Layout){

    static MODE = MODE;


    static  begin(name = 'selectableLayout', params={layoutMode:DEFAULT$1}) {
        return Layout.begin.call(SelectableLayout,name,params);
    }


    get EntryFileName(){return this.file;}
    set EntryFileName(value){this.file = value;}


    constructor(name,params={layoutMode:SelectableLayout.LAYOUT_MODE.horizontal|SelectableLayout.LAYOUT_MODE.resizeX}){
        super(name,params);

        this.status |= Controller.STATUS.active;
    }







    get Name(){return this.name;}
    set Name(val){
        this.name = val;
    }
    onSelect(){

    }

    onDeselect(){
    }


    set Mode(val){
        if(val& MODE.selecting && !(this.mode & MODE.selecting))
            this.onSelect();

        if(this.mode & MODE.selecting && !( val & MODE.selecting))
            this.onDeselect();

        this.mode = val;
    }
    get Mode (){return this.mode;}
    async initialize(){
        await super.initialize();

        this.Height = this.params.height??editorSetting.setting.OUTLINE.entryHeight;
        this.Margin = this.params.margin??editorSetting.setting.OUTLINE.margin;

        this.RenderIndex = -1;

        this.LayoutMode = Layout.LAYOUT_MODE.horizontal| Layout.LAYOUT_MODE.resizeX;
    }





    delete(){

        super.delete();

        this.inputs = null;
        this.outputs = null;
    }



    set Percentage(value){
        this.percentage = value;
    }


    draw(ctx,cam){

        if(this.Mode& MODE.selecting){
            ctx.save();
            ctx.fillStyle = OUTLINE$2.selectColor;
            ctx.fillRect(...this.boundary, this.boundary[2],this.boundary[3]);
            ctx.restore();
        }else {
            ctx.fillStyle = this.color;
        }
        super.draw(ctx,cam);
    }

}

const OUTLINE$1 = editorSetting.setting.OUTLINE;
const DEFAULT = SelectableLayout.LAYOUT_MODE.horizontal|SelectableLayout.LAYOUT_MODE.resizeX;


function __getParent(out,item){
    const parent = item.getConnection(ConnectionType.inputs, 'parent');
    out.push(item.file);

    if(parent && !(parent instanceof ListLayout))
        __getParent(out,parent);

}


class EntryLayout extends implement(SelectableLayout){

    static MODE = {
        folder:2,layer:4, file:8, folding:16,cmd:32,selecting:64
    };


    static  begin(name = 'entryLayout', params={layoutMode:DEFAULT}) {
        return Layout.begin.call(EntryLayout,name,params);
    }

    file = null;

    // get EntryData(){
    //     debugger;
    //     return null;
    // }


    get EntryFileName(){return this.file;}
    set EntryFileName(value){this.file = value;}


    constructor(params={layoutMode:EntryLayout.LAYOUT_MODE.horizontal|EntryLayout.LAYOUT_MODE.resizeX}){

        super('_entry0',params);
        this.file = params.file;
        this.status |= Controller.STATUS.active;
    }

    id = null;
    set ID(val){
        $assert(this.id ===null);
        this.id = val;
    }

    get ID(){return this.id};




    get Path(){
        let result = [];
        __getParent(result, this);
        return result.reverse().join('/');
    }

    get Name(){return this.name;}
    set Name(val){
        this.name = val;
    }
    // initialize(){
    //     super.initialize();
    // }

    delete(){

        super.delete();

        this.inputs = null;
        this.outputs = null;
    }



    set Percentage(value){
        this.percentage = value;
    }


    draw(ctx,cam){



        const width = this.boundary[2]+this.boundary[0];


        if(this.Mode& EntryLayout.MODE.selecting){
            ctx.save();
            ctx.fillStyle = OUTLINE$1.selectColor;
            ctx.fillRect(...this.boundary, this.boundary[2],this.boundary[3]);
            ctx.restore();
        }else {
            ctx.fillStyle = this.color;
            ctx.fillRect(...this.boundary, width*($isNumber$1(this.percentage)?this.percentage:1),this.boundary[3]);

        }

        draw(this,ctx,cam);
    }

}

class OutlineEvent extends Event$1{

    constructor(){
        super();
    }
}

class OutlineText extends implement(TextBox) {


    constructor(name='__test',params={}){
        super(name,params);
    }

    async initialize() {

        const superMousedown = this.mousedown;
        this.mousedown = evt => {
            const entry = this.Parent;

            if(entry.Mode & OutlineEntry.MODE.selecting)
                superMousedown(evt);
        };

        await super.initialize();




        this.endChange =  async _=>{

            const
                entry = this.Parent,
                parent = entry.getConnection(ConnectionType.inputs,'parent');
            const originFile = entry.EntryFileName;
            let file = this.text || 'empty';
            if(file === $readPath(originFile).fileNm)
                return;


            if(entry.Mode & OutlineEntry.MODE.file){
                if(!$readPath(file).fileExt)
                    file += '.'+$readPath(originFile).fileExt;
            }




            const newName = $getValidName(parent, file, $OUTLINE_RENAME_CHECKER);

            if(entry.text !== this.text)
                await Event$1.Instance.emit(common$1.setting.EVT_TYPES.renameFile, [entry.Path, `${$readPath(entry.Path).folder}/${newName}`]);

        };
    }

    onValidation(newText){
        const isInvalid = !super.onValidation(newText),
            //Non-word & Non-digits, and contains !@#$%^&*()
            isContainSymbol = /\W/.test(newText);
        if(isInvalid || isContainSymbol){
            this.Text = this.oldText;
            return false;
        }

        return true;

    }


}

const OUTLINE = editorSetting.setting.OUTLINE;
class OutlineEntry extends implement(EntryLayout,ILoad,IDraggable){




    get EntryFileName(){return this.file;}
    set EntryFileName(value){
        this.file = value;
        this.textBox.Text = $readPath(this.file).fileNm;
    }


    get Mode(){return this.mode;}

    #errorDraw =(ctx)=>{
        if(this.Status & common$1.setting.BASIC_STATUS.error){
            ctx.fillStyle = 'red';
            const [x,y] = this.iconItem.transform.position;
            ctx.beginPath();
            ctx.arc(x-4,16,4,0,2*Math.PI);
            ctx.closePath();
            ctx.fill();
        }
    }

    async setErrorMode(val){
        if(val === true && !(this.status&common$1.setting.BASIC_STATUS.error)){
            const   error = new Component(this.name+'-'+'error',
                    {layoutMode:Layout.LAYOUT_MODE.ignoreTranslate});
            //error is not being layoutRefresh
            //don't clip error.draw
            error.Status &= ~common$1.setting.BASIC_STATUS.clippingBoundary;
            await this.appendChild(error);
            await error.initialize();
            error.draw = this.#errorDraw;//error has customized draw
            error.RenderIndex = 1;
            this.error = error;
        }else if(val === false&&(this.status&common$1.setting.BASIC_STATUS.error)) {
            $assert$1(this.error);
            this.error.Status |= common$1.setting.BASIC_STATUS.clippingBoundary;
            await this.removeChild(this.error);
        }
        this.refresh();
    }
    set Mode(val){
        // if(!(this.mode&EntryLayout.MODE.error) && (val&EntryLayout.MODE.error)){
        //     this.setErrorMode();
        // }else if((this.mode&EntryLayout.MODE.error) && !(val&EntryLayout.MODE.error)){
        //
        //     this.removeChild(this.error);
        // }


        super.Mode = val;
        if(val & EntryLayout.MODE.folder){
            let isFold = checkStatus$1(val, EntryLayout.MODE.folding);
            if(isFold){
                this.folderItem.Image = Keanu.loadedItems['srcFoldIcon'];
            }else {
                this.folderItem.Image = Keanu.loadedItems['srcUnfoldIcon'];
            }
        }

        if(val & EntryLayout.MODE.folder)
            this.iconItem.Image = Keanu.loadedItems['folderIcon'];

        else if(val & EntryLayout.MODE.file){
            const ext = $readPath(this.Path).fileExt;
            switch (FileExt2Meta[ext]) {
                case FILE_TYPES.js:
                    this.iconItem.Image = Keanu.loadedItems['jsIcon'];
                    break;
                case FILE_TYPES.image:
                    this.iconItem.Image = Keanu.loadedItems['imgIcon'];
                    break;
                case FILE_TYPES.tileBrush:
                    this.iconItem.Image = Keanu.loadedItems['tileBrushIcon'];
                    break;
                case FILE_TYPES.autoBrush:
                    this.iconItem.Image = Keanu.loadedItems['autoBrushIcon'];
                    break;
                case FILE_TYPES.autoBrush:
                    this.iconItem.Image = Keanu.loadedItems['autoBrushIcon'];
                    break;
                case FILE_TYPES.palette:
                    this.iconItem.Image = Keanu.loadedItems['paletteIcon'];
                    break;
                case FILE_TYPES.projSetting:
                    this.iconItem.Image = Keanu.loadedItems['jsIcon'];
                    break;
                default:
                    this.iconItem.Image = Keanu.loadedItems['jsIcon'];
                    break;
            }
        }


    }

    static async  onLoad(){
        const srcImg = document.getElementById('keanuSrc');
        Keanu.loadedItems['srcFoldIcon'] =   await $imgCrop( srcImg,  ...OUTLINE.srcFoldIcon);
        Keanu.loadedItems['srcUnfoldIcon'] = await $imgCrop( srcImg,  ...OUTLINE.srcUnfoldIcon);
        Keanu.loadedItems['folderIcon'] =    await $imgCrop( srcImg,  ...OUTLINE.folderIcon);
        Keanu.loadedItems['jsIcon'] =        await $imgCrop( srcImg,  ...OUTLINE.jsIcon);
        Keanu.loadedItems['imgIcon'] =       await $imgCrop( srcImg,  ...OUTLINE.imgIcon);
        Keanu.loadedItems['paletteIcon'] =     await $imgCrop( srcImg,  ...OUTLINE.paletteIcon);
        Keanu.loadedItems['tileBrushIcon'] =     await $imgCrop( srcImg,  ...OUTLINE.tileBrushIcon);
        Keanu.loadedItems['autoBrushIcon'] =     await $imgCrop( srcImg,  ...OUTLINE.autoBrushIcon);
        Keanu.loadedItems['layerIcon'] =     await $imgCrop( srcImg,  ...OUTLINE.layerIcon);
    }


    async initialize(){
        await super.initialize();


        if(this.params.mode & OutlineEntry.MODE.folder){
            const folderItem = new KImage(this.name+'-'+'folder',{
                layoutMode:OutlineEntry.LAYOUT_MODE.resizeY|OutlineEntry.LAYOUT_MODE.lockRatio
            });
            folderItem.Image = document.getElementById('keanuSrc');
            await this.appendChild(folderItem);
            await folderItem.initialize();
            this.folderItem = folderItem;
        }




        const iconItem = new KImage(this.name+'-'+'icon',{
            layoutMode:OutlineEntry.LAYOUT_MODE.resizeY|OutlineEntry.LAYOUT_MODE.lockRatio
        });

        iconItem.Image = document.getElementById('keanuSrc');
        await this.appendChild(iconItem);
        await  iconItem.initialize();
        // OutlineEntry.linkHierachy(this,iconItem);
        this.iconItem = iconItem;

        //TextBox.TYPE.fix|TextBox.TYPE.omit
        const textBox = new OutlineText(this.name + '-textBox', {
            fontParams:OUTLINE.fontParams,
            layoutMode:OutlineEntry.LAYOUT_MODE.resizeY|Layout.LAYOUT_MODE.left|Layout.LAYOUT_MODE.middle,
            mode:OutlineText.MODE.omit,
            text:$readPath(this.file).fileNm,
            width: OUTLINE.textBoxWidth,
        });
        await this.appendChild(textBox);
        await textBox.initialize();
        // OutlineEntry.linkHierachy(this,textBox);
        this.textBox = textBox;

        if(this.params.mode) this.Mode = this.params.mode;

    }

    onSelect(){
        super.onSelect();
    }

    onDeselect(){
        super.onDeselect();
    }

    // removeChild(item,layout){
    //     const connType = interfaces.ConnectionType;
    //     if(item instanceof OutlineEntry) {//interfaces.isImplement(item,interfaces.IConnection)
    //         debugger;
    //         layout.removeChild(item);
    //         let children = this.getConnection(connType.inputs,'children');
    //         let delIndex = children.findIndex(ele=>ele.FullName == item.FullName);
    //         children.splice(delIndex,1);
    //
    //
    //         this.deleteConnection(connType.inputs, 'children',item);
    //         item.deleteConnection(connType.inputs,'parent');
    //     }else
    //         super.removeChild(item);
    // }


}

const _errorList = [];

queueMicrotask(_=> Event$1.Instance.onUnicon(common$1.setting.EVT_TYPES.onClear,_=>_errorList.length = 0));
let KError$1 = class KError {

    static get ErrorList(){return _errorList;}
    static findErrIndex =  pathID=>{
        pathID = $isPathID(pathID)?pathID:$path2ID(pathID);
        try{
            const index =  KError.ErrorList.findIndex(ele=>$readPath(ele.pathID).nakedPath === $readPath(pathID).nakedPath);
            return index;
        }catch (err){
            debugger;
        }
    }
    static isRelated = pathID=>  KError.findErrIndex(pathID)>=0;
    static resolve =pathID=>{
        pathID = $isPathID(pathID)?pathID:$path2ID(pathID);
        const lastErrIndex = KError.findErrIndex(pathID);
        if(lastErrIndex<0) return undefined;
        KError.ErrorList.splice(lastErrIndex,1);
        return pathID;
    }
    static async generate (type, {msg,pathID,data}) {
        if(pathID)
            pathID = $isPathID(pathID)?pathID:$path2ID(pathID);
        const stack = $getStackLocationByIndex(-2);
        if(!_errorList.find(ele=>ele.pathID === pathID))
            _errorList.push({pathID:pathID, type});


        if(pathID){
            await Event$1.Instance.emit(common$1.setting.EVT_TYPES.onError,[//
                pathID,stack
            ]);
        }else {

            console.error(stack);
            console.error(data);
            const debugDiv = document.getElementById('debug');
            if(debugDiv){
                debugger;
                if(msg){
                    debugDiv.appendChild(document.createTextNode(msg));
                    debugDiv.appendChild(document.createElement('br'));
                }
                const {url,lineNum,colNum} = stack;
                debugDiv.appendChild(document.createTextNode(`${url} row:${lineNum}, col:${colNum}`));
                debugDiv.appendChild(document.createElement('br'));
            }
            throw this;
        }
    }
};
if(typeof window !== 'undefined')
window.KError = KError$1;

async function createLocalFile( path, data) {
    data = data instanceof Blob? data:await $base64ToFileBlob(data);
    let entryData;
    const type = FileExt2Meta[$readPath(path).fileExt];//.toLowerCase()


    switch (type){
        case FILE_TYPES.image:
            $assert(data instanceof Blob);
            let binaryData = await file2Img(data);
            getDataTemplate(FILE_TYPES.image);
            // jsonData['+width'] = binaryData.width;
            // jsonData['+height'] = binaryData.height;
            entryData = binaryData;
            break;
        default: //if JSON type
            $assert(type,{msg:'unsupported file type'});
            entryData = data instanceof Blob?
                JSON.parse(await readAsText(data)):
                data;
            break;
    }

    return entryData;

}
async function createRemoteFile(path, versionId) {
    const fileBlob = await window.setting.Store.download(
        path,
        versionId,
        //(url, percentage)=>$getFile(path).Percentage = percentage
    );
    const result = await createLocalFile(path,fileBlob);
    return Promise.resolve(result);
}
function $rename(oldPath, newPath) {
    const isFile  =  !!$readPath(oldPath).fileExt;
    if(isFile)
        $projRenameFile($path2ID(oldPath), newPath);
    else {
        const files = $getFiles$1(oldPath);
        for(const file of files){
            $projRenameFile(file.id, file.path.replace(oldPath,newPath));
        }
    }
    // debugger;
    // _updateProjAssets(oldPath, newPath);
    return newPath;
}

class Headless extends implement(IEvtHandler){
    constructor() {
        super();
    }
    setAttr(evt,path,params){return $setAttr(path,params)};
    delAttr(evt,path,params){return $delAttr(path,params);}

    async createFile(evt, id, path, data){
        const isFolder = $readPath(path).fileExt?false:true;
        if(isFolder)
            return null;

        let entryData, version;
        if(window.config.stack){
            version = data;
            entryData = await createRemoteFile(path,version);
        }else
            entryData = await createLocalFile( path,data);
        $projAddFile(id, path,  entryData, version??'local');
        return entryData;

    }
    deleteFiles(evt, sel){return $deleteFile(sel);}
    process(evt,nakedPath){//async
        return $processFiles(nakedPath);
    }
    async import (evt, srcPath, targetPath, dstIndex){

        await $paint2(srcPath, targetPath, null, [dstIndex]);

        Event$1.Instance.emit(common$1.setting.EVT_TYPES.onPaletteRenderChange,[$path2ID(targetPath)]);
    };

    async paint (evt,sourcePath, targetPath,srcIndice,dstIndice){
        await $paint2(sourcePath, targetPath,srcIndice,dstIndice);
        Event$1.Instance.emit(common$1.setting.EVT_TYPES.onPaletteRenderChange,[$path2ID(targetPath)]);
    }

    rename  (evt, oldPath, newPath){return $rename( oldPath, newPath)};

}



function registEvt$1(handler = new Headless()){



    const Evt = Event$1.Instance;
    Evt.onUnicon(common$1.setting.EVT_TYPES.setAttr, handler.setAttr,0);
    Evt.onUnicon(common$1.setting.EVT_TYPES.delAttr, handler.delAttr,0);

    Evt.onUnicon(common$1.setting.EVT_TYPES.import, handler.import,0);
    Evt.onUnicon(common$1.setting.EVT_TYPES.paint,handler.paint,0);



    // Evt.onUnicon(common.setting.EVT_TYPES.undo,undoRedo,0);
    // Evt.onUnicon(common.setting.EVT_TYPES.redo, undoRedo,0);



    Evt.onUnicon(common$1.setting.EVT_TYPES.renameFile, handler.rename,0);


    Evt.onUnicon(common$1.setting.EVT_TYPES.createFile, handler.createFile,0);

    Evt.onUnicon(common$1.setting.EVT_TYPES.deleteFile,  handler.deleteFiles,0);

    Evt.onUnicon(common$1.setting.EVT_TYPES.onProcess, handler.process,0);

    Evt.onUnicon(common$1.setting.EVT_TYPES.onControllerAttached, function (evt,controller){
        const leafs = depthFirstSearch(evt.publisher);
        for(const leaf of leafs){
            $assert(!(leaf.StatusOfMasked & common$1.setting.BASIC_STATUS.deleting));
            const result = getParentsOf(leaf);
            result.unshift(leaf);
            leaf.fullName = result.map(ele=>ele.Name).reverse().join('/');
        }
    },{index:0});

}

let recallableIndice,historyIndex;
const publishers= EventDispatcher$1.Publishers;
async function undoRedo$1(evt){

    if(!(Event$1.Instance.Mode & Event$1.MODE.recalling))
        return;

    $assert($isNumber$1(historyIndex));


    const minIndex = Event$1.Instance.InitIndex, maxIndex = Event$1.Instance.HistoryIndex,
        lastIndex = publishers.length-1;

    if(publishers[lastIndex].type == common$1.setting.EVT_TYPES.undo ||
        publishers[lastIndex].type == '@'+common$1.setting.EVT_TYPES.undo ){
        if(historyIndex == minIndex)
            return historyIndex;
        return await undo(evt);
    }else {//common.setting.EVT_TYPES.redo

        if(historyIndex == maxIndex)
            return historyIndex;
        return await redo(evt);
    }
}


async function undo(evt){

    const minIndex = evt.InitIndex;

    for(--historyIndex;historyIndex>minIndex;--historyIndex)
        if(recallableIndice.includes(historyIndex))
            break;
    debugger;
    await undo2BeforeIndex(evt,historyIndex);
    return historyIndex;
}

async function redo(evt){
    const  maxIndex = evt.HistoryIndex;

    for(++historyIndex;historyIndex<maxIndex;++historyIndex)
        if(recallableIndice.includes(historyIndex))
            break;
    await redo2Index(evt,historyIndex,historyIndex-1);
    return historyIndex;
}

async function undo2BeforeIndex(evt,index){
    const Evt = Event$1.Instance,history = Evt.History;

    $assert(Evt.Mode & Event$1.MODE.recalling);
    // $assert(!(Evt.Mode & Event.MODE.batchEmitting));
    // debugger;//(Evt.Mode& Event.MODE.emitting) ||

    console.log(`undo2BeforeIndex: ${index}`);

    await Evt.emit(common$1.setting.EVT_TYPES.onClear,{timestamp:evt.options.timestamp});


    await $batchEmit(history.slice(Evt.InitIndex, index), {writeHistory:false, internal:true});

    // for(let i = Evt.InitIndex; i < index;i++)
    //     await Evt.emit('@'+history[i].type, history[i].params,{timestamp:history[i].timestamp});

}


async function redo2Index(evt,index, curIndex){
    const Evt = Event$1.Instance,history = Evt.History;

    for(let i = curIndex; i < index;i++){
        $assert(history[i]);
        await Evt.emit('@'+history[i].type, history[i].params,{timestamp:history[i].timestamp});
    }
}


async function onCheckGUI(evt, path){
    if(path === undefined)
        path = evt, evt = null;

    const   {nakedPath,fileExt} = $readPath(path),
        type = FileExt2Meta[fileExt];

    if(FILE_TYPES.binary&type) //escape when JPG/PNG
        return true;
    return await $checkSource4EntryData(nakedPath);
}




async function _checkBrush (path){

    let isAllCorrect = true;

    for(const fullPathID of $searchData(path, DATA_TYPES.path)){
        const target = $getAttr$1(fullPathID);
        let isCorrect = !!target && !!$getFiles$1(target).length;
        if(isCorrect){
            const targetData =  $getAttr$1(target);
            const {fileExt} = $readPath(target),
                value = $getFileDataType(fullPathID);
            if(value & FILE_TYPES.image)
                isCorrect = isCorrect && FileExt2Meta[fileExt] === FILE_TYPES.image;

            if(value & FILE_TYPES.brush) {
                const isTile = isCorrect && FileExt2Meta[fileExt] === FILE_TYPES.tileBrush && targetData['~rawImg'] && targetData['source'],
                    isAuto = isCorrect && FileExt2Meta[fileExt] === FILE_TYPES.autoBrush;
                isCorrect = isTile || isAuto;
            }

        }

        isAllCorrect = isAllCorrect && isCorrect;
        const {nakedPath} =  $readPath(fullPathID);
        await $assert(isCorrect, {pathID:fullPathID, msg:`${nakedPath} is not valid source`});

    }
    return isAllCorrect;
}




async function    $checkSource4EntryData(path){
    const {nakedPath,fileExt} = $readPath(path);
    const data =  $getAttr$1(path);
    $assert(data&&data['.dataTypes']);

    const type = FileExt2Meta[fileExt];
    let isCorrent = true;
    if(type & FILE_TYPES.brush)
        isCorrent &&= await _checkBrush(path);
    if(isCorrent){
        await Event$1.Instance.emit(common$1.setting.EVT_TYPES.onProcess,[path]);
        if(KError$1.isRelated(path)){
            const
                pathID = $path2ID(path),
                refers = [pathID];
            $findRefers(refers,pathID);
            for(const referPathID of refers){
                const pathID = KError$1.resolve(referPathID);
                $assert(pathID);
                await Event$1.Instance.emit(common$1.setting.EVT_TYPES.onErrorFixed,[referPathID]);
            }
        }
    }


    return isCorrent;
}

class  OutlineHeadless extends implement(Headless){
    constructor() {
        super();
    }
    async setAttr  (evt,path,params){
        const   isSuccess = super.setAttr(evt, path,params),
            {nakedPath} = $readPath(path);
        if(isSuccess)
            // for(const fullPathID of $searchData(path, DATA_TYPES.path)){
            //     if(fullPathID === path)
            //         await Event.Instance.emit(common.setting.EVT_TYPES.onCheckGUI, [nakedPath]);
            // }
            await Event$1.Instance.emit(common$1.setting.EVT_TYPES.onCheckGUI, [nakedPath]);
    };

    async deleteFiles  (evt, sel){

        if($canDel(sel))
            return;

        for(const path of sel){
            for(const file of $getFiles$1(path)){
                const pathID = KError$1.resolve(file.id);
                if(pathID)//when deleting error state Files
                    await Event$1.Instance.emit(common$1.setting.EVT_TYPES.onErrorFixed,[pathID]);
            }
        }

        await $deleteFile(sel,async fullPath=>await onCheckGUI(fullPath));
    }
    async import  (evt, srcPath, targetPath, dstIndex){


        // await $importAll(srcPath, targetPath, dstIndex,
        //     async (fullPath, srcPathValue)=>{ // await setAttr(fullPath, {source:srcPathUUID, '.dataTypes':{'.':DATA_TYPES.object,source:type}});
        //         await Event.Instance.emit('@'+common.setting.EVT_TYPES.setAttr,[fullPath, srcPathValue]);
        //     });

        await $paint2(srcPath, targetPath, null, [dstIndex],
            async (fullPath, srcPathValue)=>{ // await setAttr(fullPath, {source:srcPathUUID, '.dataTypes':{'.':DATA_TYPES.object,source:type}});
                await Event$1.Instance.emit('@'+common$1.setting.EVT_TYPES.setAttr,[fullPath, srcPathValue]);
            });

        Event$1.Instance.emit(common$1.setting.EVT_TYPES.onPaletteRenderChange,[$path2ID(targetPath)]);
    };

    async paint (evt,sourcePath, targetPath,srcIndice,dstIndice){
        await $paint2(sourcePath, targetPath,srcIndice,dstIndice,async (fullPath, srcPathValue)=>{
            await Event$1.Instance.emit('@'+common$1.setting.EVT_TYPES.setAttr,[fullPath, srcPathValue]);
            await onCheckGUI(targetPath);
        });
        Event$1.Instance.emit(common$1.setting.EVT_TYPES.onPaletteRenderChange,[$path2ID(targetPath)]);
    }

    rename(evt, oldPath, newPath){
        super.rename(evt,oldPath, newPath);

        const errInfo = KError$1.ErrorList.find(ele=>new RegExp(oldPath).test(ele.path));
        if(errInfo)
            errInfo.path = errInfo.path.replace(oldPath, newPath);
    }

}



function registEvt(handler = new OutlineHeadless()){
    const Evt = Event$1.Instance;
    Evt.onUnicon(common$1.setting.EVT_TYPES.setAttr, handler.setAttr,0);
    Evt.onUnicon(common$1.setting.EVT_TYPES.delAttr, handler.delAttr,0);

    Evt.onUnicon(common$1.setting.EVT_TYPES.import, handler.import,0);
    Evt.onUnicon(common$1.setting.EVT_TYPES.paint,handler.paint,0);



    // Evt.onUnicon(common.setting.EVT_TYPES.undo,undoRedo,0);
    // Evt.onUnicon(common.setting.EVT_TYPES.redo, undoRedo,0);



    Evt.onUnicon(common$1.setting.EVT_TYPES.renameFile, handler.rename,0);


    Evt.onUnicon(common$1.setting.EVT_TYPES.createFile, handler.createFile,0);

    Evt.onUnicon(common$1.setting.EVT_TYPES.deleteFile,  handler.deleteFiles,0);

    Evt.onUnicon(common$1.setting.EVT_TYPES.onProcess, handler.process,0);
    Evt.onUnicon(common$1.setting.EVT_TYPES.onCheckGUI, onCheckGUI,0);



    // Evt.onUnicon(common.setting.EVT_TYPES.onRecallingStart, checkPrivilege,0);
    // Evt.onUnicon(common.setting.EVT_TYPES.onRecallingStart, onRecallingStart,1);
    // Evt.onUnicon(common.setting.EVT_TYPES.onRecallingEnd, onRecallingEnd,0);

    Evt.onUnicon(common$1.setting.EVT_TYPES.onControllerAttached, function (evt,controller){
        const leafs = depthFirstSearch(evt.publisher);
        for(const leaf of leafs){
            $assert(!(leaf.StatusOfMasked & common$1.setting.BASIC_STATUS.deleting));
            const result = getParentsOf(leaf);
            result.unshift(leaf);
            leaf.fullName = result.map(ele=>ele.Name).reverse().join('/');
        }
    },{index:0});


}

async function  createFile(evt, id, path) {//, uint8
    const reader = $readPath(path);
    const entryName=reader.file, parentPath=reader.folder;
    // const entryData = EventDispatcher.getSubscriberResult(evt, {index:0});
    const newEntry = await __createEntry(entryName,parentPath),
        isFolder = $readPath(entryName).fileExt?false:true;

    if(!isFolder) {
        // newEntry.EntryData = entryData;
        newEntry.ID = id;
        await Event$1.Instance.emit(common$1.setting.EVT_TYPES.onCheckGUI, [path]);
    }

    const win = evt.subscriber;
    await win.indentEntry();
    win.Content.refresh();
    //Event.Instance.emit('@'+common.setting.EVT_TYPES.select, [[path],'reselect']);
    return newEntry;
}

async function __createEntry(entryName = 'unnamed', parentPath = '/'){
    const regRes = entryName.match(/\.(.+)/);
    let extName = regRes?regRes[1]:null;

    let editors = window.Keanu.editors,
        editor = editors.objs['Resource']?editors.objs['Resource']:editors.objs['Outline'],
        fileMode =extName?OutlineEntry.MODE.file:OutlineEntry.MODE.folder,
        parent = null;

    const array = editor.Content.group.Children;
        array.length+1;
        const hasParent = parentPath == '/'?false:true;

    let insertIndex = array.length;

    if(hasParent) {
        const projPath = $PROJ_PATH(window.config.project);
        if(!$getFileEntry(parentPath)) { //create parents folders

            debugger;
            const folders = parentPath.substring(
                        projPath.length+1,parentPath.length)
                        .split('/');

            let parentFolder = projPath;
            for(const folderNm of folders){
                __createEntry(folderNm, parentFolder);
                parentFolder += `/${folderNm}`;
            }
        }

        parent = $getFileEntry(parentPath);
        $assert(parent);
        if(parent.Mode & OutlineEntry.MODE.folding)
            await Event$1.Instance.emit('@'+common$1.setting.EVT_TYPES.toggleFolder,this,[parent.Path]);
        insertIndex = array.findIndex(ele=>ele.Name == parent.Name)+1;
    }else
        parent = editor.Content;


    const newObj = new OutlineEntry({
        color:editorSetting.setting.OUTLINE.entryColor,
        file:entryName,
        mode: fileMode,
        height: editorSetting.setting.OUTLINE.entryHeight,
        width: editor.clientWidth
    });
    editor.Content.insertChild(insertIndex,newObj);
    await newObj.initialize();
    OutlineEntry.linkHierachy(parent, newObj);


    // for(let i= 0;i<totalCount;i++)
    //     editor.Content.group.Children.rename(array[i],'_tmp'+i);
    // for(let i= 0;i<totalCount;i++)
    //     editor.Content.group.Children.rename(array[i],'_entry'+i);





    editor.contentLayout.sort(editor.sortRule);
    return newObj;

}


async function deleteFile(evt, sel) {
    if($canDel(sel)) return;

    await deleteEntry(evt, sel);

    const win = evt.subscriber;
    await win.indentEntry();
    win.Content.refresh();
}

async function deleteEntry(evt, sel) {



    const editors = window.Keanu.editors,
        editor = editors.objs['Resource']?editors.objs['Resource']:editors.objs['Outline'];





    for(const entryPath of sel){
        if(editor.Selection.includes(entryPath)){
            const index = sel.findIndex(path=>path == entryPath);
            editor.Selection.splice(index,1);
        }

        const entry = $getFileEntry(entryPath),

            leafs = depthFirstSearch(entry, _=>true,
            ele=>ele.getConnection(ConnectionType.outputs,'children'));

        $assert(entry);
        $assert(entry.Parent.Children.exist(entry.name));



        const  parent = entry.getConnection(ConnectionType.inputs,'parent'),
            children = parent.getConnection(ConnectionType.outputs,'children'),
            delIndex = children.findIndex(ele=>ele.Path == entry.Path);
        children.splice(delIndex,1);

        for(const child of leafs)
            child.delete();

    }

    editor.contentLayout.sort(editor.sortRule);
}




function select(evt, selGrp, mode){//out is selection selGrp
    const editors = window.Keanu.editors,
        editor = editors.objs['Resource']?editors.objs['Resource']:editors.objs['Outline'];
        editor.name;
        const selList = editor.Selection;
    $assert(editor);
    $assert(selList);
    $assert(selGrp);
    if(mode == 'deselect'){
        for(let path of selGrp) {

            let finder =  $getFileEntry(path);

            if(!finder) return;
            finder.Mode &= ~OutlineEntry.MODE.selecting;


            let delIndex = selList.findIndex(ele=>ele==path);
            if(delIndex>-1)
            selList.splice(delIndex,1);
        }

    }else if(mode== 'add'){

        const newSelGrp = [...new Set(selList.concat(selGrp))];

        selList.length = 0;
        for(let path of newSelGrp)
            selList.push(path);


        for(let path of newSelGrp) {
            const ele =  $getFileEntry(path);
            ele.Mode |= OutlineEntry.MODE.selecting;
            selList.push(path);
        }
    }else {//reselect


        for(let path of selList.slice()){
            if(selGrp.includes(path))
                continue;
            const ele =  $getFileEntry(path);
            if(ele)
                ele.Mode &= ~OutlineEntry.MODE.selecting;

            let delIndex = selList.findIndex(ele=>ele==path);
            $assert(delIndex>-1);
            selList.splice(delIndex,1);
        }




        for(let path of selGrp) {
            if(selList.includes(path))
                continue;

            let ele =  $getFileEntry(path);
            $assert(ele,{msg:`${JSON.stringify(getFiles())} err`});



            $assert(ele,{msg:`${JSON.stringify(Array.from(Event$1.Instance.History.values()))} err`});
            ele.Mode |= OutlineEntry.MODE.selecting;

            selList.push(path);
        }

    }

}



async function rename(evt, oldPath, newPath){
    if($readPath(oldPath).folder  == $readPath(newPath).folder)
        _rename(oldPath,newPath);
    else {
        _move(oldPath,newPath);
        const win = evt.subscriber;
        await win.indentEntry();
        win.Content.refresh();
    }

    const usrName = window.config['usrName'],
        deviceID = window.config['deviceID'];

    if(evt.options.device === `${usrName}:${deviceID}`)
        await Event$1.Instance.emit('@'+common$1.setting.EVT_TYPES.select,[[newPath],'reselect']);
}

function _rename(oldPath, newPath){
    const
        newValidFile = $readPath(newPath).file,
        editors = window.Keanu.editors,
        editor = editors.objs['Resource']?editors.objs['Resource']:editors.objs['Outline'],
        // ele = $getFileEntry(oldPath),
        ele = $getFileEntry(oldPath),
        regex = new RegExp(oldPath);
    $assert(ele);
    const sel = editor.Selection;
    for(const i in sel)
        if(regex.test(sel[i]))
            sel[i] = sel[i].replace(oldPath,newPath);


    ele.EntryFileName = newValidFile;

    editor.contentLayout.sort(editor.sortRule);
}

function _move(srcPath, dstPath){
    const
        editors = window.Keanu.editors,
        editor = editors.objs['Resource']?editors.objs['Resource']:editors.objs['Outline'],
        dragEntry = $getFileEntry(srcPath),
        dropEntry =  $getFileEntry($readPath(dstPath).folder),
        validName = `${$readPath(dstPath).file}`;


    $assert(dragEntry&&dropEntry);

    const sel = editor.Selection;

    const filteredSel = sel.filter(ele=> !(ele === srcPath || new RegExp(srcPath+'/').test(ele)));
    sel.length = 0;
    for(const ele of filteredSel)
        sel.push(ele);

    if(dragEntry.EntryFileName !== validName)
        _rename(dragEntry.Path, dstPath);

    OutlineEntry.clearHierachy(dragEntry);
    OutlineEntry.linkHierachy(dropEntry, dragEntry);

    // const leafs = depthFirstSearch(dragEntry, _=>true, ele=>ele.getConnection(ConnectionType.outputs,'children'));
    if(dropEntry.Mode & OutlineEntry.MODE.folding){
        dragEntry.Status &= ~common$1.setting.BASIC_STATUS.visible;
        dragEntry.Status &= ~common$1.setting.CTRL_STATUS.active;
        dragEntry.Status &= ~common$1.setting.UI_STATUS.layoutable;
    }


    editor.contentLayout.sort(editor.sortRule);

}


async function onError(evt,fullPath){
    const {nakedPath,fileExt} = $readPath(fullPath),
        entry = $getFileEntry(nakedPath),
        entryData = $updateAttr(nakedPath),
        type = FileExt2Meta[fileExt];

    if(entry) {
        await entry.setErrorMode(true);
        entry.Status |= common$1.setting.BASIC_STATUS.error;
    }
    const asset = $assetsFind(fullPath);
    $assert(asset);
    const
        refers = asset['.refers'];
    for(const refer of refers){
        const {nakedPath,attrKeys} = $readPath(refer);
        await $assert(false, {pathID:refer, msg:`the file referenced in ${nakedPath}|${attrKeys.join('|')} is corrupted`});
    }
    if(FILE_TYPES.tileBrush&type){
        entryData['~rawImg'] = null;
    }

}
async function onErrorFixed(evt,pathID){
    const   entry = $getFileEntry(pathID);
    await entry.setErrorMode(false);

    // if Controller is inactive
    // entry.Status |= common.setting.STATUS.active; //or use status NOT Status
    // entry.Status &= ~common.setting.BASIC_STATUS.error;
    entry.Status -= common$1.setting.BASIC_STATUS.error;

}



async function toggleFolder(evt, path){
    evt.subscriber;
            const entry = $getFileEntry(path);

    const
            otherStates = entry.Mode & ~OutlineEntry.MODE.folding, // 0
            foldState = entry.Mode & OutlineEntry.MODE.folding;    // 1
    entry.Mode = foldState ?
        otherStates :
        entry.Mode | OutlineEntry.MODE.folding;


    const children = depthFirstSearch(entry,_=>true,ele=>ele.getConnection(ConnectionType.outputs,'children'));
    children.shift();
    for (const child of children) {
        if(entry.Mode & OutlineEntry.MODE.folding){
            child.Status &= ~common$1.setting.BASIC_STATUS.visible;
            child.Status &= ~common$1.setting.CTRL_STATUS.active;
            child.Status &= ~common$1.setting.UI_STATUS.layoutable;
        }else {
            child.Status |= common$1.setting.BASIC_STATUS.visible;
            child.Status |= common$1.setting.CTRL_STATUS.active;
            child.Status |= common$1.setting.UI_STATUS.layoutable;
        }
    }
    const win = evt.subscriber;
    await win.indentEntry();
    win.Content.refresh();

}


async function open(evt,path){
    const editors = window.Keanu.editors;
        editors.objs['Resource']?editors.objs['Resource']:editors.objs['Outline'];
        const data = $getAttr$1(path);

    $assert(data);

    FileExt2Meta[$readPath(path).fileExt] == FILE_TYPES.palette;
        FileExt2Meta[$readPath(path).fileExt] == FILE_TYPES.brush;

    const type = FileExt2Meta[$readPath(path).fileExt];

    if(FILE_TYPES.palette&type && editors.objs['Palette']){
        const palette = editors.objs['Palette'];
        palette.onActive();
        await palette.open($path2ID(path));
    }else  if(FILE_TYPES.tileBrush&type &&editors.objs['Brush']){
        const brush = editors.objs['Brush'];
        brush.onActive();
        await brush.open($path2ID(path));
    }
}

class Outline extends implement(UIScrollable) {



    #selection = null;
    #dragstartElement = null;
    sortRule = (a,b)=>{


        //same type
        if((a.Mode & OutlineEntry.MODE.folder && b.Mode & OutlineEntry.MODE.folder)||
            (a.Mode & OutlineEntry.MODE.file && b.Mode & OutlineEntry.MODE.file)){

            const reg = /(\D+)(\d+)$/gm, //is same baseName
                rA = $match(reg, a.EntryFileName),
                rB = $match(reg,b.EntryFileName);
            if(rA&&rB&& rA[1]&& rB[1]&& rA[1] == rB[1])
                return parseInt(rA[2]) - parseInt(rB[2]);
            else {

                if(a.EntryFileName>b.EntryFileName)
                    return 1;
                else
                    return -1;
            }

        }else {
            if(a.Mode&OutlineEntry.MODE.folder)
                return -1;
            else if(b.Mode&OutlineEntry.MODE.folder)
                return 1;
        }

    };
    constructor(name='__test', params = {
        style: {}
    }) {

        super(name, params);

        // init selection

    }

    get Event (){return OutlineEvent.Instance;}



    get Selection() {
        return this.#selection;
    }





    clearSelection() {
        this.#selection.length=0;
    }



    registEvt() {//OutlineEvent.Instance
        super.registEvt();
        $assert(!this.Event.exist(common$1.setting.EVT_TYPES.select));//don't double registing

        const __clean = fnc =>{
            return async (...params)=>{
                await fnc(...params);
                this.#dragstartElement=null;
            }
        };

        this.Event.on(common$1.setting.EVT_TYPES.onClear, this.onActive(__clean(async function(){
            console.log('before onInitialized =========');
            await Event$1.Instance.emit(INTERNAL(common$1.setting.EVT_TYPES.onInitialized), ['Outline']);
            console.log('after onInitialized =========');
        })),{subscriber:this});

        this.Event.on(common$1.setting.EVT_TYPES.onError, this.onActive(onError),{subscriber:this,index:0});
        this.Event.on(common$1.setting.EVT_TYPES.onErrorFixed, this.onActive(onErrorFixed),{subscriber:this,index:0});
        this.Event.on(common$1.setting.EVT_TYPES.openFile, this.onActive(open),{subscriber:this});


        //Files Evts
        this.Event.on(common$1.setting.EVT_TYPES.renameFile, this.onActive(__clean(rename)),{subscriber:this,index:0});


        this.Event.on(common$1.setting.EVT_TYPES.createFile, this.onActive(__clean(createFile)),{subscriber:this});

        this.Event.on(common$1.setting.EVT_TYPES.deleteFile, this.onActive(__clean(deleteFile)),{subscriber:this});
        //GUI Evts
        this.Event.on(common$1.setting.EVT_TYPES.toggleFolder, this.onActive(__clean(toggleFolder)),{subscriber:this});
        this.Event.on(common$1.setting.EVT_TYPES.select, this.onActive(__clean(select)),{subscriber:this,index:0});


        this.Event.on('#create/#folder', this.onActive(_=>{

            const parentPath = this.getSelParentFolder();
            const validName = this.getValidName();
            $assert(validName);

            Event$1.Instance.emit(common$1.setting.EVT_TYPES.createFile,[null, parentPath +'/'+validName]);
        }), {subscriber:this});
        this.Event.on('#create/#palette',(evt)=>{
            this.createDataEntry('unnamed.palette');
        }, {subscriber:this});

        this.Event.on('#create/#brush/#autoBrush',(evt)=>{
            this.createDataEntry('unnamed.autoBrush');
        }, {subscriber:this});
        this.Event.on('#create/#brush/#tileBrush',(evt)=>{
            this.createDataEntry('unnamed.tileBrush');
        }, {subscriber:this});
        this.Event.on('#create/#scene',(evt)=>{
            this.createDataEntry('unnamed.scene');
        }, {subscriber:this});

        this.Event.on('#delete', (evt, fullName )=>{

            const
                curTarget =  $findByFullName(fullName),
                targets = curTarget instanceof OutlineEntry?
                    [curTarget]:
                    getParentsOf(curTarget, ele=> ele instanceof OutlineEntry);

            if(targets.length &&
                this.Selection.length &&
                this.Selection.includes(targets[0].Path))
                Event$1.Instance.emit(common$1.setting.EVT_TYPES.deleteFile,[this.Selection.slice()]);
            // if(this.Selection.length)
            //     Event.Instance.emit(common.setting.EVT_TYPES.deleteFile,[this.Selection.slice()]);
        }, {subscriber:this});
    }

    onErrorFixed(evt, ...params){
        if(KError.ErrorList.length) return;

        const status = common$1.setting.BASIC_STATUS;
        this.Status &= ~status.error;
        this.Title.Status &= ~status.error;
    }
    onError(evt, path){

        const status = common$1.setting.BASIC_STATUS;
        this.Status |= status.error;
        this.Title.Status |= status.error;
    }


    getValidName(name = 'unnamed'){
        const hasParent =  this.Selection.length !=0;

        let curEntry = hasParent?$getFileEntry(this.Selection[0]):null,
            parent = hasParent?curEntry:this.Content;
        if(curEntry&&!(curEntry.Mode & OutlineEntry.MODE.folder))
            parent = $getFileEntry($readPath(curEntry.Path).folder);

        return $getValidName(parent, name,$OUTLINE_RENAME_CHECKER);
    }



    initListeners() {
        super.initListeners();
        this.Content.addEventListener('release',async evt => {
            if(!(evt.buttons & 1))
                return;
            const entry = evt.target instanceof OutlineEntry ? evt.path[0] : evt.path[1];

            if (!entry.Path) {
                //this.constructor.name,
                if(this.Selection.length)
                    await Event$1.Instance.emit(common$1.setting.EVT_TYPES.select, [this.Selection.slice(), 'deselect']);
                return evt.stopImmediatePropagation();
            }

            // if(evt.target instanceof UISlider)
            //     return evt.stopImmediatePropagation();


            const isClickingFolder = evt.target instanceof KImage && // when clicking icon folder
                        entry.Mode & OutlineEntry.MODE.folder;

            if (isClickingFolder)
                return evt.stopPropagation();

            if(!this.Selection.includes(entry.Path)) {
                await Event$1.Instance.emit(common$1.setting.EVT_TYPES.select, [[ entry.Path],'reselect']);
            }
        });
        this.Content.addEventListener('release',async evt => {//isClickFolder
            if(!(evt.buttons & 1))
                return;

            const entry = evt.target instanceof OutlineEntry ?
                evt.target : evt.target.Parent,
                isClickingFolder = evt.target instanceof KImage && // when clicking icon folder
                    entry.Mode & OutlineEntry.MODE.folder;
            if (!isClickingFolder)
                return;


            Event$1.Instance.emit(common$1.setting.EVT_TYPES.toggleFolder,this,[entry.Path]);

        });


        this.Content.addEventListener('dblclick', async evt => {

            const entry = evt.target instanceof OutlineEntry ? evt.path[0] : evt.path[1];

            if(evt.target instanceof OutlineText)
                return evt.stopPropagation();

            if( entry.Mode && !(entry.Mode & OutlineEntry.MODE.folder)){
                $assert(entry.Path);
                const pathID = $path2ID(entry.Path);
                if(!pathID) return;
                await Event$1.Instance.emit(common$1.setting.EVT_TYPES.openFile, this, [pathID]);
            }

            evt.stopPropagation();
        });



        // this.Content.addEventListener('mouseover', evt=>{
        //     if(evt.target.Path)
        //         console.log(evt.target.Path);
        // });
        this.Content.addEventListener('dragstart', async evt => {
            //if target is ListLayout.group
            if (!(evt.target instanceof OutlineEntry) && !(evt.target instanceof KImage) ) {
                evt.preventDefault();
                return evt.stopPropagation();
            }

            const entry = evt.target instanceof KImage?evt.path[1]:evt.target;
            $assert(entry instanceof OutlineEntry);
            const data = {
                source: this.name,
                element: entry.Path, //$assetsFind(entry.Path).id
            };
            evt.customDataTransfer.setData('dragInfo', JSON.stringify(data));
            console.log(data);

            $assert(entry.Path && entry.iconItem.img);
            const canvas = entry.iconItem.img;
            $setGhostImg(canvas, this.Controller);
            this.#dragstartElement = entry;
            return evt.stopPropagation();
        });
        this.Content.addEventListener('dragend', async evt => {
            $clearGhostImg( this.Controller);
            const isInside = $isInsideBoundary([evt.offsetX, evt.offsetY], [0,0,this.Width, this.Height]);
            if(!isInside && this.#dragstartElement)
                select(null, [this.#dragstartElement.Path],'reselect');

        });


        // this.Content.addEventListener("out", async evt => {
        //     if(evt.target.FullName != this.Content.FullName)
        //         return;
        //     console.log('out target',evt.target.FullName, 'related:', evt.relatedTarget.FullName);
        // });

        this.Content.addEventListener("leave", async evt => {

            if(!$isDragging(evt)) return;

            if(this.#dragstartElement)//external drag this.#dragstartElement = null
                select(null, [this.#dragstartElement.Path],'reselect');
            $assert(evt.relatedTarget);
            //console.log('leave target',evt.target.FullName, 'related:', evt.relatedTarget.FullName);
        });

        this.Content.addEventListener("over", evt=>{
            if(!$isDragging(evt)) return;

            if(evt.target instanceof ListLayout){
                select(null, [],'reselect');
                return evt.stopPropagation();
            }

            const enterElement = evt.target instanceof OutlineEntry ?evt.path[0] : evt.path[1],
                    dragInfo = JSON.parse(evt.customDataTransfer.getData('dragInfo')??'{}');


            if(dragInfo.element) {
                const draggedElement = $getFileEntry(dragInfo.element);
                $assert(draggedElement);
                if(draggedElement.FullName === evt.target.FullName){
                    select(null, [],'reselect');
                    // return evt.stopPropagation();
                }
                if(new RegExp(draggedElement.Path+'/').test(enterElement.Path))//cannot drop its own child
                    select(null, [],'reselect');

            }



            if(enterElement.Mode & OutlineEntry.MODE.folder)
                select(null, [enterElement.Path],'reselect');
            else
                select(null, [],'reselect');

            return evt.stopPropagation();
        });





        //drop cleans everything already
        //this.Content.addEventListener('dragend', async evt => draggedElement = null);

        this.Content.addEventListener('drop', evt => {

            evt.preventDefault();
            let dropEntry = evt.target;


            if (evt.target instanceof  KImage || evt.target instanceof  TextBox) //outlineImage
                dropEntry = evt.path[1]; //assign outlineImage parent, which is outlineEntry

            if(dropEntry instanceof  ListLayout ||
                dropEntry.parent instanceof  ListLayout)
                return evt.stopPropagation();

            if (dropEntry instanceof OutlineEntry && !(dropEntry.Mode & OutlineEntry.MODE.folder)) //escape none folder case
                return evt.stopPropagation();

            const dragStr = evt.customDataTransfer.getData('dragInfo'),
                dragInfo = JSON.parse(dragStr??'null'),
                isExternalDrop = !dragInfo;

            if (isExternalDrop) { //no dragInfo
                $assert(evt.dataTransfer);
                // Use DataTransferItemList interface to access the file(s)
                for (let i = 0; i < evt.dataTransfer.items.length; i++) {

                    let item = evt.dataTransfer.items[i],
                        file = evt.dataTransfer.files[i];

                    // If dropped items aren't files, reject them
                    if (item.kind === 'file' && this.isTypeReadable(item))
                        this.readItem(item,file, dropEntry);
                }
            } else {//has dragInfo

                if(dragInfo.element == dropEntry.Path)//cannot drop its own
                    return evt.stopPropagation();

                if(new RegExp(dragInfo.element+'/').test(dropEntry.Path))//cannot drop its own child //+'/'
                    return evt.stopPropagation();


                this.dragDrop(dropEntry, dragInfo);
            }

            // return evt.stopPropagation();
        });
    }


    async init() {
        await super.init();

        this.Title.Text = 'outline';


        this.#selection = [];
        this.beforeRefreshHandlers.push({caller:this,fnc:this.indentEntry});

        this.beforeRefreshHandlers.push({caller:this,fnc:_=> this.Content.sort(this.sortRule)});

    }

    async indentEntry() {
        const children = depthFirstSearch(this.contentLayout.group, ele =>
            ele instanceof OutlineEntry).filter(ele=>!(ele.Status & common$1.setting.STATUS.deleting));

        if(children.length == 0)
            return;

        for (let entry of children) {
            const connType = ConnectionType.inputs;
                entry.transform.Position.slice();
            //indentEntry x position, in relative coord
            const parent = entry.getConnection(connType, 'parent');
            if(!parent)
                continue;


            const paths = $match(/\/([^\/]+)/gm,entry.Path);

            const dummyWidth = paths.length*editorSetting.parseSetting(editorSetting.setting.OUTLINE.entryImageLeftMargin);
            // entry.Offset = offset;

            if(entry.Children[0].name != 'dummy'){
                const dummy = new Component('dummy',{status: common$1.setting.STATUS.layoutable,layoutMode:Component.LAYOUT_MODE.resizeY,width:dummyWidth});
                await entry.insertChild(0,dummy);
                await  dummy.initialize();
            }else {
                const dummy =entry.Children[0];
                dummy.Width = dummyWidth;
            }
            entry.refresh();
            entry.expand(['x']);
        }

        const arr = children.sort((a,b)=>b.Boundary[2] - a.Boundary[2]),
            MAXLENGTH = arr[0].Boundary[2]<this.Width?this.Width:arr[0].Boundary[2];
        for(const entry of children)
            entry.Width =  MAXLENGTH;
    }


    resize(size) {
        super.resize(size);
    }

    set Style(value) {
        super.Style = value;
    }

    dragDrop(dropEntry, dragInfo) {
        let dragEntry = $getFileEntry(dragInfo.element);
        $assert(dragEntry);

        let children = depthFirstSearch(dragEntry,target=>{
            if(!checkStatus$1(target.Status, common$1.setting.BASIC_STATUS.visible))
                return false;
            if(!checkStatus$1(target.Status, common$1.setting.CTRL_STATUS.active))
                return false;
            return true;
        }, ele=>ele.getConnection(ConnectionType.outputs,'children'));
        children.shift();
        if (children.includes(dropEntry.FullName)) return; //cannot drop to its own child


        if(dragEntry.getConnection(ConnectionType.inputs,'parent').Path == dropEntry.Path)
            return;//already same child


        const parent = dropEntry;
        $assert(dragEntry.EntryFileName);
        const newName = $getValidName(parent, dragEntry.EntryFileName, $OUTLINE_RENAME_CHECKER);
        $assert(!/\//.test(newName));
        $assert( dropEntry.Path);
        Event$1.Instance.emit(common$1.setting.EVT_TYPES.renameFile,[dragEntry.Path, `${dropEntry.Path}/${newName}`]);
        //a/b/c==>a/         a/b/c    a/

    }
    async readItem(item,file, entry) {
        let blob = item.getAsFile();
        // let buf = await blob.arrayBuffer(),
        //     uint8 = new Uint8Array(buf);
        // const fileBlob = await new Blob([uint8]);

        const hasParent =  this.Selection.length !=0,
            parentPath = hasParent?this.Selection[0]:'/',
            parent = hasParent?$getFileEntry(this.Selection[0]):this.Content;
        $assert(parent);
        const validName = $getValidName(parent, file.name, $OUTLINE_RENAME_CHECKER),
            base64 = await $fileBlob2Base64(blob);
        Event$1.Instance.emit(common$1.setting.EVT_TYPES.createFile, [$createFileID(),parentPath+'/'+validName,base64]);
    }
    getSelParentFolder(){
        let parentPath = this.Selection.length?this.Selection[0]:$PROJ_PATH(window.config.project);
        if($getFileEntry(parentPath).Mode & OutlineEntry.MODE.file)
            parentPath = $readPath(parentPath).folder;
        return parentPath;
    }
    async createDataEntry( validName){
        const parentPath = this.getSelParentFolder();

        validName = this.getValidName(validName);

        $assert(validName);
        const json = genData(parentPath +'/'+validName),
            base64 = await $fileBlob2Base64(JSON.stringify(json));


        await Event$1.Instance.emit(common$1.setting.EVT_TYPES.createFile,[$createFileID(), parentPath +'/'+validName,base64]);
    }

    isTypeReadable(item){
        if(/image/.test(item.type))
            return true;

        else if(/json/.test(item.type))
            return true;
        else if(/text/.test(item.type))
            return true;

        return false;
    }



    clear() {

        this.clearSelection();
        return super.clear();//async
    }



    delete() {
        this.#selection = null;
        super.delete();
    }

    async initByData(parent,stack){
        const entryList = [];
        for(let path of stack){
            const isFile = /\./.test(path);
            entryList.push({name:path, mode:isFile?OutlineEntry.MODE.file: OutlineEntry.MODE.folder});
        }

        let entry,info;
        while(info = entryList.shift()){
            const {name, mode} = info;
            $assert(name&&mode);
            const children = parent.getConnection(ConnectionType.outputs,'children');
            entry = children.find(ele=>ele.EntryFileName == name);

            if(!entry){
                entry = new OutlineEntry( {
                    color:editorSetting.setting.OUTLINE.entryColor,
                    file:name,
                    mode,
                    height: editorSetting.setting.OUTLINE.entryHeight,
                    width: this.clientWidth
                });

                await this.Content.appendChild(entry);
                OutlineEntry.linkHierachy(parent, entry);
                await entry.initialize();
            }
            parent = entry;
        }
    }

}
customElements.define('outline-editor', Outline);

class ResourceEvent extends OutlineEvent {

    constructor(){
        super();
    }



}

let keanuStack;

// export async function create(evt, entryName, parentPath, version = null){
//     const
//         path = parentPath +'/'+entryName;
//
//
//     const entryData = EventDispatcher.getSubscriberResult(evt, evtHandler.createFile);
//
//     if(evt && evt.options.upload == true){
//         const projData = getProjFileData( window.config['projPath']);
//         $assert(!(projData['.assets'].find(source=>source['.path'] == path)));
//         const   dataIndex = projData['.assets'].length,
//             fullPath = window.config['projPath'] + '|.assets';
//         Event.Instance.emit('@'+common.setting.EVT_TYPES.setAttr,[
//             fullPath, {
//                 [dataIndex]:jsonData
//             }
//         ],{timestamp:evt.options.timestamp});
//     }
//
// };

window.bot=bot;
function bot(id = 0,slice = 5, parallel = 1, interval = 5000){

    const file = $getFiles(new RegExp(`${window.config['palette']}.palette$`));
    if(file.length == 0) return null;

    const path = file[0].path;
    let gridNum = $readFileDataValue(`${path}|numOfGrids|0`),
        dstIndex = parseInt(id*gridNum*gridNum/5);

    const job =async _=>{
        const   row = Math.floor(dstIndex/gridNum),
                col = dstIndex%gridNum,
                time = Date.now();
        Event$1.Instance.emit(common$1.setting.EVT_TYPES.paint,[
            path,
            path,
            [[0,Math.floor(Math.random()*gridNum)]],
            [[col,row]]
        ],{usrName:`bot`});
        dstIndex++;
        console.log(`paint================${Date.now()-time}`);
    };

    setInterval(_=>{
        for(let i=0;i<parallel;i++)
            job();
    },interval);
}
async function connect(evt,projName,cloudSettings){
    $assert(projName && cloudSettings);
    const editor = window.Keanu.editors.objs['Resource'];


    $assert(editor);


    window.setting = new UploadSetting(cloudSettings,{usr: ''});

    window.setting.Store;
    keanuStack = window.setting.Stack;

    const   history =  await initProject(editor);
    await Event$1.Instance.initialize(history, evt.InitIndex);//


    if (window.config['vr'])
       testVR();
    // if (window.config['bot'])
    //     // for(let i=0;i<parseInt(window.config['bot']);i++)
    //         bot();
}

async  function initProject(editor){

    const {history} = await downloadProject(editor);
    debugger;
    Event$1.Instance.subscribeSSE();
    return history;
}



function downloadProject(editor){
    let curIndex = null;
    return   keanuStack.getSerializedInfo()
         .then(response=>{
             const {files,index,tag} = response;
             $assert(files&&index&&tag, 'proj data lost');

             curIndex = parseInt(index)+1;
             editor.Event.InitIndex = curIndex;

             return $download(files)
                 .then(_=> $projBegin(window.config.project,files))
                 .then(_=>GUI$1.$REFRESH_LOCK_BEGIN(editor))
                 .then(_=>initOutline(editor,files))
                 .then(_=>GUI$1.$REFRESH_LOCK_END(editor))
                 .then(_=>$loadProcess());

         })
        // .then(entries=>{
        //     const  jobProcessBr = [],
        //         brFiles = entries.map(ele=>ele.Path).filter(path=>{
        //             const srcType = FileExt2Meta[$readPath(path).fileExt];
        //             return srcType === FILE_TYPES.tileBrush;
        //         });
        //     //brFiles.forEach(path=>jobProcessBr.push(Event.Instance.emit(common.setting.EVT_TYPES.onProcess, [path])));//
        //     brFiles.forEach(path=>jobProcessBr.push($checkSource4EntryData(path)));//
        //
        //     return Promise.all(jobProcessBr)
        //
        // })
        .then(_=>keanuStack.getCurrentStack(curIndex))

}

const UPLOAD_LOCKER = 'RESOURCE_UPLOADER';
class Resource extends implement(Outline){
    constructor(name='__test',params){
        super(name,params);
    }

    get Event (){return ResourceEvent.Instance;}

    async readItem(item,file, entry){//overwrite outline readItem

        if(entry instanceof Controller) return;
        const blob = item.getAsFile();

        lock$1(UPLOAD_LOCKER)
            .then(release=>{

                const parent = entry,
                    validName = $getValidName(parent, file.name, $OUTLINE_RENAME_CHECKER),
                    path = `${entry.Path}/${validName}`;

                if($assetsFind(path))
                    $assert(false, {errorType:common$1.error.ERR_TYPE.illegalPath, path});

                console.log(path, '======================================================================');
                return  window.setting.Store.upload(path, blob)
                    .then(({VersionId})=>Event$1.Instance.emit(common$1.setting.EVT_TYPES.createFile, [$createFileID(),path,VersionId]))
                    .then(_=>release());
            });
    }
    async createDataEntry( validName){
        const parentPath = this.getSelParentFolder();
        validName = this.getValidName(validName);

        const
            path = parentPath +'/'+validName,
            json = genData(path);

        const {VersionId} = await window.setting.Store.upload(path, JSON.stringify(json));//blob
        Event$1.Instance.emit(common$1.setting.EVT_TYPES.createFile,[$createFileID(),parentPath +'/'+validName,VersionId]);
    }


    registEvt(){


        super.registEvt();

        // this.Event.on(common.setting.EVT_TYPES.renameFile, evtHandler.rename);
        // this.Event.on(common.setting.EVT_TYPES.createFile,evtHandler.create);
        // this.Event.on(common.setting.EVT_TYPES.deleteFile, evtHandler.del);
        this.Event.on(common$1.setting.EVT_TYPES.onConnect, connect);
        // this.Event.on('download', evtHandler.download);
    }

    initListeners(){
        super.initListeners();
    }


    // init(){
    //     super.init();
    // }

    clear(){
        return super.clear().then(_=>initProject(this));
    }




}
customElements.define('resource-editor', Resource);

const IMG_SIZE = 32, PRESS_COL = "grey", RELEASE_COL = "white";


let Menu$1 = class Menu extends HTMLElement{
    static btns = {};
    static onChange= element =>{

        // for(const [key,value] of Object.entries(Menu.btns))
        console.log(element.id, element.Status);

    };
};
customElements.define('menu-root', Menu$1);

class MenuBtnBase extends HTMLElement{
    constructor(name,params) {
        super();
        this.className = 'menu-element';
        this.style['background-color'] = RELEASE_COL;
        this.id = name;

        this.appendChild(getImg(name,IMG_SIZE));
    }
}
customElements.define('menu-btn-base', MenuBtnBase);

class MenuStatusBtn extends MenuBtnBase{
    get Status(){
        return this.style['background-color'] === PRESS_COL;
    }
    set Status(value){
        if(value !== (this.style['background-color'] === PRESS_COL))
            Menu$1.onChange(this);
        this.style['background-color'] =value?PRESS_COL:RELEASE_COL;
    }

    constructor(...params) {
        super(...params);
        this.addEventListener('click',evt=>{

            const parentGrp = this.parentElement;
            const otherBtns = [...parentGrp.children].filter(ele=>ele!==this);
            for(const other of otherBtns)
                other.Status = false;

            this.Status = !this.Status;
            this.onchange(this.Status);
        });
    }
    onchange=_=>{};
}
customElements.define('menu-status-btn', MenuStatusBtn);




class MenuClickBtn extends MenuBtnBase{
    get Status(){
        return this.style['background-color'] === PRESS_COL;
    }
    set Status(value){
        if(value !== (this.style['background-color'] === PRESS_COL))
            Menu$1.onChange(this);
        this.style['background-color'] =value?PRESS_COL:RELEASE_COL;
    }

    constructor(...params) {
        super(...params);
        this.addEventListener('click',evt=>this.onclick(evt));
        this.addEventListener('pointerdown', evt=>{this.Status = true;this.onpointerdown(evt);});
        this.addEventListener('pointerup', evt=>{this.Status = false;this.onpointerup(evt);});
    }

    onclick=_=>{};
    onpointerdown=_=>{};
    onpointerup=_=>{};

}
customElements.define('menu-click-btn', MenuClickBtn);




class MenuGroupStatus extends HTMLElement{
    group = [];
    constructor(name, names, params=[]) {
        super();
        this.id = name;
        for(const name of names){
            const childBtn = new MenuStatusBtn(name);
            this.group.push(childBtn);
            this.appendChild(childBtn);
        }
    }


}

customElements.define('menu-group-btn', MenuGroupStatus);

function getImg(name, size){
    if(!menuPics.children[name])
        ;

    const source = menuPics.children[name];

    const img = new Image();
    img.src = source.src;
    img.width = img.height = size;
    // return new Promise(res=>img.onload_=_=>res(img));
    return img;
}
function createBtn(name, menu,  onClick = null,size = 32){
    const btn = new MenuClickBtn(name);
    menu.appendChild(btn);
    if(onClick)
        btn.onclick =  onClick;
    return btn;

}
function createStatus(name, menu,  onChange = null,size = 32){
    const btn = new MenuStatusBtn(name);
    menu.appendChild(btn);
    if(onChange)
        btn.onchange =  onChange;
    return btn;
}
function createGrpBtn(name, imgs, menu,onClicks){

    const grp = new MenuGroupStatus(name, imgs);
    menu.appendChild(grp);
    return grp;
}

function findBranchEnds(out, element){

    if(element instanceof MenuBtnBase && element.id)
        out.push(element);
    else
        for(const child of [...element.children])
            findBranchEnds(out, child);
}
function findParents(out, element){
    out.unshift(element);
    if(!element.parentElement || !(element.parentElement.id)) return;
    findParents(out, element.parentElement);
}
function refreshIDByHierachy(element){
    const hierachyList = [];
    findParents(hierachyList, element);
    element.id = hierachyList.map(ele=>ele.id).join('/');
    Menu$1.btns[element.id] = element;
}
function refreshIds(root){
    const branchEnds = [];
    findBranchEnds(branchEnds, root);
    for(const end of branchEnds)
        refreshIDByHierachy( end);


}

const menu = document.getElementById('menu');
const menuPics = document.getElementById('menuPics');

function createMenu(){
    if(!(menu&&menuPics)) debugger;
    createBtn('logo',menu, _=>{});
    createGrpBtn('inputStatus', ['mouse','trackpad'], menu);
    createStatus('lock',menu, _=>{});
    createBtn('save',menu, _=>Event.Instance.save('files'));
    createBtn('save',menu, _=>Event.Instance.save('history'));

    refreshIds(menu);
}

window.Menu = Menu$1;

class PaletteEvt extends Event$1{

    constructor(){
        super();
    }



}

class UICanvas extends implement(UIWindow, IUICanvas, IToolAction) {

    // scrollY = 0;
    mode = 0;
    static MODE = common$1.setting.CANVAS_MODE;

    set Mode (value){
        this.mode = value;
    }
    get Mode (){
        return this.mode;
    }

    get Content(){
        return this.contentLayout;
    }

    constructor(...args) {
        super(...args);
    }

    async init(){
        await super.init();

        ////////////////////////////////////////////
        ////////////////////////////////////////////
        // TOOLs
        ////////////////////////////////////////////
        ////////////////////////////////////////////
        const canvasLayout = new Canvas2DLayout('canvasLayout');
        await this.Body.appendChild(canvasLayout);
        await canvasLayout.initialize();
        Layout.linkHierachy(this.Body, canvasLayout);

        this.contentLayout = canvasLayout;


        await this.initToolBox();
    }
    _moveCanvas(evt){

        const camTransform = this.Content.ContentLayout.Camera.transform;
        let origin = [0,0],
            scale = camTransform.scale[0],
            pos = camTransform.position.slice();
        this.Content.onDrag(evt,
            (x,y)=> {
                origin[0] = x, origin[1] = y;
                scale = camTransform.scale[0];
                pos = camTransform.position.slice();
                this.ToolMode |= UICanvas.TOOL_MODE.interactionStart;
            },
            (x,y)=> {
                let diffX = scale*(x - origin[0]),//
                    diffY = scale*(y - origin[1]);//

                camTransform.position[0] = pos[0] - diffX;
                camTransform.position[1] = pos[1] - diffY;
                camTransform.update();
             },
            _=>this.ToolMode |= UICanvas.TOOL_MODE.interactionEnd
        );
    }
    _toolInteractionOnPress(evt){
        const camTransform = this.Content.ContentLayout.Camera.transform;
        let startPos=[0,0],
            endPos=[0,0];
        this.Content.onDrag(evt,
            (x, y) => {
                startPos[0] = x, startPos[1] = y;
                Transform2D.multiply(startPos, camTransform, startPos);
                console.log('UICanvas.TOOL_MODE.interactionStart',UICanvas.TOOL_MODE.interactionStart);
                this.ToolMode |= UICanvas.TOOL_MODE.interactionStart;
                this.toolAction(startPos,startPos);
            },
            (x, y) => {

                endPos[0] = x, endPos[1] = y;
                Transform2D.multiply(endPos, camTransform, endPos);
                this.toolAction(startPos,endPos);
            },
            (x, y)=> {
                this.ToolMode |= UICanvas.TOOL_MODE.interactionEnd;
                endPos[0] = x, endPos[1] = y;
                Transform2D.multiply(endPos, camTransform, endPos);
                // this.toolAction(startPos,endPos);
            }
        );
    }

    initListeners(){
        super.initListeners();
        this.Content.addEventListener('press',evt=>{

            if (evt.isPrimary == false)
                return;


            if(this.ToolMode & UICanvas.TOOL_MODE.camTumble){

                this._moveCanvas(evt);

            }else {
                this._toolInteractionOnPress(evt);
            }


        });

        let _scale = null;
        const onGesture = (evt,controller,TOUCH_STATE)=>{
            if((controller.touchState & TOUCH_STATE.start) && !(controller.touchState & TOUCH_STATE.change)){
                _scale = this.Content.getScale();
            } else if(controller.touchState & TOUCH_STATE.change){

                const MAXSCALE = editorSetting.setting.CANVAS_MAXSCALE;
                const scale = (_scale * evt.gesture.scale).clamp(1/MAXSCALE, MAXSCALE);
                $assert($isNumber$1(scale));
                if(evt.gesture.mode === 'zoom'){
                    this.Content.setScale(scale);
                    this.Content.scaleUpdateCanvas(evt, [evt.localX , evt.localY]);
                }else if(evt.gesture.mode === 'pan'){
                    this.Content.moveCanvas(evt.gesture.dx, evt.gesture.dy);
                }
            }else if(!(controller.touchState & TOUCH_STATE.start)){
                _scale = null;
            }
        }, onWheel = (evt,controller,TOUCH_STATE)=>{

            if(!(this.ToolMode & UICanvas.TOOL_MODE.interactionStart)){
                if(!(this.ToolMode & UICanvas.TOOL_MODE.camZoom)){       //
                    this.onUIActionStart('camTumble');
                }
                this.ToolMode |= UICanvas.TOOL_MODE.interactionStart;
            }

            if(this.ToolMode & UICanvas.TOOL_MODE.camZoom){

                this.Content.updateScrollY(evt.deltaY);
                this.Content.scaleUpdateCanvas(evt, [evt.localX , evt.localY]);
            }
            if(this.ToolMode & UICanvas.TOOL_MODE.camTumble){
                this.Content.moveCanvas(evt.deltaX, evt.deltaY);
            }

            if(!(controller.touchState & TOUCH_STATE.start)){
                debugger;
                this.ToolMode |= UICanvas.TOOL_MODE.interactionEnd;
                if(this.ToolMode & UICanvas.TOOL_MODE.camTumble)
                    this.onUIActionEnd('camTumble');
            }
        };
        this.Content.addEventListener('gesture',(evt)=>{



            const IS_TRACK_PAD = window.Menu.btns['menu/inputStatus/trackpad'].Status;
                window.Menu.btns['menu/inputStatus/mouse'].Status;
                const controller = evt.controller,
                  Controller = controller.constructor,
                TOUCH_STATE = Controller.TOUCH_STATE;

            if(controller.touchState & TOUCH_STATE.gesture){
                if(IS_TRACK_PAD)
                    onGesture(evt,controller,TOUCH_STATE);
                else
                    onWheel(evt,controller,TOUCH_STATE);

            }

            evt.preventDefault(true);//prevent $infinityDesktop wheel
        });





        // this.Content.addEventListener('zoom',(evt)=>{
        //     debugger;
        //     this.Content.scaleUpdateCanvas(evt, [evt.localX , evt.localY]);
        // });


    }


    registEvt() {//OutlineEvent.Instance
        super.registEvt();

        this.Event.on(common$1.setting.EVT_TYPES.onUIAction,(evt, status, cmd)=>{
            if(status == 'start')
                this.onUIActionStart(cmd);
            else if(status == 'end')
                this.onUIActionEnd(cmd);
        },{subscriber:this});





    }


    delete(){
        this.Event.remove({subscriber:this});
        super.delete();
    }






    toolModeStack = [];

    onUIActionStart(cmd){
        if(!UICanvas.TOOL_MODE[cmd])
            return;
        //start btn blinking animation
        this.status |= UICanvas.STATUS.animation;
        const last = this.toolModeStack[this.toolModeStack.length-1];
        if(!last || last.cmd !== cmd)
            this.toolModeStack.push({cmd, timestamp: Date.now()});

        if(last){
            const toolModeStr = $getToolModeStr(editorSetting,this.ToolMode, this.constructor.name,UICanvas.TOOL_MODE);
            if(this[toolModeStr+'End'] && (this.ToolMode&UICanvas.TOOL_MODE.interactionStart))
                this[toolModeStr+'End']();
        }


        const mode = this.ToolMode & ~UICanvas.TOOL_MODE.all;
        this.ToolMode = mode|UICanvas.TOOL_MODE[cmd];
        $assert( this.toolBoxLayout.Children[cmd]);
        this.toolBoxLayout.Children[cmd].Mode |= KImage.MODE.colorFilterAnimation;
        this.toolBoxLayout.Children[cmd].Mode |= KImage.MODE.background;



    }
    static HOLD_TIME_THRESHOLD = 300;
    onUIActionEnd(cmd){
        if(!UICanvas.TOOL_MODE[cmd])
            return;

        //stop btn blinking animation
        this.Status &= ~UICanvas.STATUS.animation;

        const curCMD = this.toolModeStack[this.toolModeStack.length-1];
        $assert(curCMD);
        const
            isShortHold = Date.now()-curCMD.timestamp<UICanvas.HOLD_TIME_THRESHOLD,
            isInterrupted = (this.ToolMode & UICanvas.TOOL_MODE.interactionStart)&&
                                !(this.ToolMode & UICanvas.TOOL_MODE.interactionEnd);
        if(isShortHold || isInterrupted){
            for(const tool of this.toolModeStack){
                const oldCMD = tool.cmd;
                if(oldCMD ===  cmd)
                    continue;
                this.toolBoxLayout.Children[oldCMD].Mode &= ~KImage.MODE.colorFilterAnimation;
                this.toolBoxLayout.Children[oldCMD].Mode &= ~KImage.MODE.background;
            }
            this.toolModeStack = [curCMD];
        }else {
            const curCMDIndex = this.toolModeStack.findIndex(ele=>JSON.stringify(curCMD) === JSON.stringify(ele)),
                oldCMDIndex = curCMDIndex-1;
            if(oldCMDIndex < 0)
                return;


            const
                lastCMD = this.toolModeStack[oldCMDIndex],
                oldCMD = lastCMD.cmd;

            this.ToolMode &= ~UICanvas.TOOL_MODE[cmd];
            this.ToolMode |= UICanvas.TOOL_MODE[oldCMD];
            if(oldCMD != cmd){
                this.toolModeStack.splice(curCMDIndex,1);
                this.toolBoxLayout.Children[cmd].Mode &= ~KImage.MODE.colorFilterAnimation;
                this.toolBoxLayout.Children[cmd].Mode &= ~KImage.MODE.background;
            }
        }
    }






    onSelecting(startPos,endPos = startPos){

        const   start = [0,0],
            end = [0,0];

        this.selectedTimeOffset = Date.now();


        if(this.Mode & UICanvas.MODE.isometric){
            $screenPos2isoIndex(start, startPos,this.CellSize, this.numOfGrids);
            $screenPos2isoIndex(end, endPos,this.CellSize, this.numOfGrids);
        }else if(this.Mode & UICanvas.MODE.regular){
            $screenPos2RegularIndex(start, startPos,this.CellSize);
            $screenPos2RegularIndex(end, endPos,this.CellSize);
        }
        const boundary = [0,0,0,0];
        $selection2Boundary(boundary, [start, end]);

        if(this.ToolMode & UICanvas.TOOL_MODE.addSelection)//ShortCutsMapping.isShortCutOf(ShortCutsMapping.CMDs.addSelection)
            this.addSelection(boundary);

        if(this.ToolMode & UICanvas.TOOL_MODE.removeSelection)//ShortCutsMapping.isShortCutOf(ShortCutsMapping.CMDs.removeSelection)
            this.removeSelection(boundary);

        this.selection.length = 0;
        this.addSelection(boundary);

        $throttle(_=>this.Event.emit(common$1.setting.EVT_TYPES.onPaletteSelectionChange,this, [this.selection]),2000);

    }
}
customElements.define('ui-canvas', UICanvas);

class UIPalette extends implement(UICanvas, ILoad) {

    set ToolMode(value){

        if(!this.pathID) return;
        const oldValue = super.ToolMode;
        const toolModeStr = $getToolModeStr(editorSetting,value, this.constructor.name,UICanvas.TOOL_MODE);
        if(!(oldValue & UICanvas.TOOL_MODE.interactionStart) && (value & UICanvas.TOOL_MODE.interactionStart))
            if(this[toolModeStr+'Start']){
                console.log('ToolMode==============',toolModeStr+'Start');
                this[toolModeStr+'Start']();
            }

        if(!(oldValue & UICanvas.TOOL_MODE.interactionEnd) && (value & UICanvas.TOOL_MODE.interactionEnd)){
            if(this[toolModeStr+'End']){
                console.log('ToolMode==============',toolModeStr+'End');
                this[toolModeStr+'End']();
            }
            value &= ~(UICanvas.TOOL_MODE.interactionStart+UICanvas.TOOL_MODE.interactionEnd);
            // $debounce(_=> super.ToolMode &= ~(UICanvas.TOOL_MODE.interactionStart+UICanvas.TOOL_MODE.interactionEnd), 50);
        }




        super.ToolMode = value;
    }
    get ToolMode(){
        return super.ToolMode;
    }


    selection = [];
    pathID = null;
    paletteComponent = null;
    paletteBakeCanvas = null;

    selectedTimeOffset = null;
    cellSize = null;
    numOfGrids = null;
    lineWidth = 1;
    constructor(name='__test', params={style:{}}){
        super(name,params);
        // this['klass'] = 'palette';
    }

    async open(pathID){

        this.clear();

        await this.initData(pathID);

        if(!window.config.outline) return;

        const entry = $getFileEntry(pathID);
        $assert(pathID&&entry);
        if(entry.Status & common$1.setting.BASIC_STATUS.error)
            this.onError(pathID);
    }
    registEvt(){
        super.registEvt();



        Event.Instance.on(common$1.setting.EVT_TYPES.setAttr,
            this.onActive((evt,fullPath,params)=>{
                const
                    {folder,fileNm,nakedPath} = $readPath(fullPath);
                if(this.pathID === null) return;
                if($path2ID(nakedPath) !== this.pathID) return;

                
                //if br.source == null changed source
                // if(params == null) return this.open(nakedPath);

            }), {subscriber:this});


        const deleteFile = (evt,paths)=>{

            if(this.pathID === null) return;

            let isDeleted = $readPath(this.pathID) === undefined;
            // isDeleted |= paths.reduce((acc,path)=>
            //     acc |= this.pathID === $readPath(path), false);
            if(isDeleted)
                return this.clear();
        };


        this.Event.on(common$1.setting.EVT_TYPES.deleteFile, this.onActive(deleteFile),{subscriber:this});

        this.Event.on(common$1.setting.EVT_TYPES.onPaletteRenderChange,
            this.onActive((..._)=>this.onRenderChange(..._)), {subscriber:this});

    }

    onErrorFixed(path){
        if(this.pathID == null ||
            !$compareID(path, this.pathID)) return false;

        const status = common$1.setting.BASIC_STATUS;
        this.status &= ~status.error;
        this.Title.status &= ~status.error;
        this.status |= common$1.setting.STATUS.updating;
        return true;
    }
    onError( path){

        if(this.pathID == null||
            !$compareID(path, this.pathID)) return false;
        const status = common$1.setting.BASIC_STATUS;
        this.status |= status.error;
        this.Title.status |= status.error;
        this.status |= common$1.setting.STATUS.updating;
        return true;
    }


    onRenderChange(evt,targetPath){
        if(targetPath != this.pathID)
            return;


        this.status |= common$1.setting.STATUS.updating;
    }

    _preDraw(ctx,cam){
        if( this.status & common$1.setting.STATUS.updating){
            const canvas = this.paletteBakeCanvas;

            this.drawContents(canvas);
            this.status &= ~common$1.setting.STATUS.updating;
        }

        this.drawGrid(ctx);
        const canvas = this.paletteBakeCanvas;
        if(canvas.width&&canvas.height )
            ctx.drawImage(canvas,0,0);
    }
    _drawHandler(ctx,cam){//this = component

        // if(this.ToolMode & UICanvas.TOOL_MODE.select)
        //     // this.drawSelectedBoundary(ctx);
        // if(this.ToolMode & UICanvas.TOOL_MODE.cut){
        //     // this.drawSelectedBoundary(ctx);
        //     this.drawCuttingBoundary(ctx);
        // }
    }
    _postDraw(ctx){
        this.drawSelectedBoundary(ctx);
    }
    initComponentListener(){

    }
    async initPaletteComponent(parent, width,height){
        const LAYOUT_MODE = common$1.setting.LAYOUT_MODE;
        const paletteComponent = new Component('paletteComponent',{
            layoutMode:LAYOUT_MODE.vertical|LAYOUT_MODE.resizeX|LAYOUT_MODE.resizeY,
            width, height
        });
        paletteComponent.drawHandler = ctx=>{//this = component
            this._preDraw(ctx);
            this._drawHandler(ctx);
            this._postDraw(ctx);
        };
        await parent.appendChild(paletteComponent);
        await paletteComponent.initialize();
        parent.refresh();
        return paletteComponent;
    }

    async initCanvas(width,height){
        if(this.paletteComponent) return;

        this.paletteBakeCanvas = document.createElement('canvas');
        this.paletteComponent = await this.initPaletteComponent(this.Content.ContentLayout,width,height);

        this.centerCanvas( [width,height],[this.Content.Width, this.Content.Height]);


        $assert(this.paletteBakeCanvas);

        const canvas = this.paletteBakeCanvas,
            ctx = canvas.getContext('2d');
        ctx.clearRect(0,0,canvas.width,canvas.height);
        canvas.width = width;
        canvas.height = height;
        this.initComponentListener();
    }

    delete(){
        super.delete();
        this.pathID = null;
        this.paletteComponent = null;
        this.paletteBakeCanvas = null;
        this.selectedTimeOffset = null;
        this.selection.length = 0;
    }

    clear(){
        this.paletteComponent = null;
        this.pathID = null;
        this.selection.length = 0;
        return super.clear();//async
    }

    centerCanvas(srcSize, dstSize){
        const
            srcWidth = srcSize[0],
            srcHeight = srcSize[1],
            dstWidth = dstSize[0],
            dstHeight = dstSize[1],
            scale = dstWidth/srcWidth>dstHeight/srcHeight?dstHeight/srcHeight:dstWidth/srcWidth;
        //this.contentLayout.clear();
        this.contentLayout.setScale(1/scale);
        this.contentLayout.scaleUpdateCanvas();
    }




    selectStart(){
        this.selection.length = 0;
    }
    selectEnd(){

    }

    addSelection(boundary){
        this.selection.push(boundary);
    }

    removeSelection(removeBoundary){
        const sel = this.selection.slice();
        for(const boundary of sel){
            const intersect = $intersectSelBoundary(boundary,removeBoundary);
            for(const i in intersect){
                intersect[i];
                        const dirs = ['y', 'x'];
                if(intersect.includes('+')) $splitBoundaries(this.selection, dirs[i], removeBoundary[0]);
                if(intersect.includes('-')) $splitBoundaries(this.selection, dirs[i], removeBoundary[0]+removeBoundary[2]);
                else if(intersect.includes('='))
                    $splitBoundaries(this.selection, dirs[i], removeBoundary[0]),
                        $splitBoundaries(this.selection, dirs[i], removeBoundary[0]+removeBoundary[2]);
            }
        }
    }

    initData(pathID){
        this.pathID = $path2ID(pathID);
        this.refreshTitle($readPath(pathID).fileNm);
    }
    drawContents(){

    }


    drawGrid(ctx){

        ctx.strokeStyle = editorSetting.setting.PALETTE.gridStrokeColor;
        ctx.lineWidth = editorSetting.setting.PALETTE.gridLineWidth;
        const [COL,ROW] = this.numOfGrids;
        for(let col =0; col<COL; col++){
            for(let row =0; row<ROW; row++){
                $drawCell(this,ctx, col,row, 'stroke');
            }
        }

        ctx.lineWidth = this.lineWidth;

    }

    drawSelectedBoundary(ctx) {

        ctx.fillStyle = editorSetting.setting.PALETTE.selectedGridColor;

        ctx.filter = `brightness(${(Math.sin((Date.now()-this.selectedTimeOffset)/1000 * this.shinningSpeed) + 2) * 0.5})`;


        // for (let sel of this.selection) {
        //     const [col,row] = sel.index;
        //     $drawCell(this,ctx, col, row);
        // }

        for(const [col,row,width,height] of this.selection){
            $drawCell(this,ctx, col, row, 'fill', width,height);
        }

    }
}

function checkFileEntry(evt,palette){
    if(!palette.pathID) return;
    if(!evt.customDataTransfer.getData('dragInfo')) return;

    const info = evt.customDataTransfer.getData('dragInfo');
    $assert(info);
    const
        dragInfo = JSON.parse(info),
        path = dragInfo.element,
        brushData = $getAttr$1(path),
        brushEntry = $getFileEntry(dragInfo.element),
        type = FileExt2Meta[$readPath(path).fileExt];

    if(!(type & FILE_TYPES.brush))
        return;
    if(brushEntry.Status & common$1.setting.BASIC_STATUS.error)
        return;

    ({path:dragInfo.element});


    return {brushData, path}

}

function GenDragDataImgInfo(brushData, path){

    const dragDataImgInfo = {path},
        type = FileExt2Meta[$readPath(path).fileExt];
    if(type & FILE_TYPES.tileBrush){
        const
            imgPath = brushData['source'],
            img = $getAttr$1(imgPath);

        const boundaryArr = $genIsometricSliceBoundary([0,0], brushData['slices']),
            indexMaxShift = boundaryArr.reduce((acc,{index,boundary})=>{
                acc[0] = Math.max(acc[0], index[0]+boundary[2]);
                acc[1] = Math.max(acc[1], index[1]+boundary[2]);
                return acc;
            },[0,0]);

        dragDataImgInfo['type'] = type;
        dragDataImgInfo['img'] = img;
        dragDataImgInfo['indexMaxShift'] = indexMaxShift;

    }else  if(type & FILE_TYPES.autoBrush){
        const firstRule = brushData['autoTile'][0];
        dragDataImgInfo['indexMaxShift'] = [1,1];//following lines is async function
        $genAutoTileImg(brushData['source'], firstRule.boundary).then(canvas=> {
            dragDataImgInfo['type'] = type;
            dragDataImgInfo['img'] = canvas;
            dragDataImgInfo['indexMaxShift'] = [1,1];
        }).catch(err=>{
            debugger;
        });
    }
    return dragDataImgInfo;
}


function dragOverComponent(evt, palette,targetStartIndex,indexMaxShift){

        if(!evt.customDataTransfer.getData('dragInfo')) return;
        const
            info = evt.customDataTransfer.getData('dragInfo');
        $assert(info);

        const dragInfo = JSON.parse(info);
            $getAttr$1(dragInfo.element);

        if(!(FileExt2Meta[$readPath(dragInfo.element).fileExt] & FILE_TYPES.brush))
            return;


        palette.ToolMode |= UICanvas.TOOL_MODE.import;

        const paintPos = [evt.localX,evt.localY];


        if(palette.Mode & UICanvas.MODE.isometric){
            $screenPos2isoIndex(targetStartIndex, paintPos,palette.CellSize, palette.numOfGrids);
        }else if(palette.Mode & UICanvas.MODE.regular){
            $screenPos2RegularIndex(targetStartIndex, paintPos,palette.CellSize);
        }


        $assert(indexMaxShift);

        const targetEndIndex = [targetStartIndex[0]+indexMaxShift[0],targetStartIndex[1]+indexMaxShift[1]];

        return targetEndIndex;
}


function getDropSource(evt, palette){

    const
        info = evt.customDataTransfer.getData('dragInfo');
    if(!info) return;

    const dragInfo = JSON.parse(info),
        sourcePath = dragInfo.element,
        targetPath = palette.pathID;

    $assert(sourcePath&&targetPath);

    const msg = sourcePath + 'the type of file is invalid';
        common$1.error.ERR_TYPE.illegalPath;
    $assert((sourcePath!=targetPath), msg);


    return sourcePath
}

function bakeTileBr(ctx,col,row,paletteData,boundary,tileData){
    $assert(tileData);
    const
        cellSize = paletteData['cellSize'],
        numOfGrids = paletteData['numOfGrids'],
        mode = paletteData['mode'],
        pos = [0, 0];


    // let {boundary,source} = content;
    // boundary = $genBoundary(boundary);
    // $assert(source);
    const
        tileCellSize = $getNumber(tileData['cellSize']);


    let width = tileCellSize,
        height = tileCellSize,
        targetWidth = cellSize,
        targetHeight = cellSize;

    if(mode & UICanvas.MODE.isometric){
        //TODO: this.numOfGrids is col width for baking target
        $gridIndex2isoScreenPos(pos, [parseInt(col),parseInt(row)], cellSize, numOfGrids[0]);
        width = boundary[2]*tileCellSize,
        height = boundary[3]*tileCellSize,
        targetWidth = boundary[2]*cellSize,
        targetHeight = boundary[3]*cellSize;

        const gridOffsetY = $isoBottomOffsetY(boundary[2], boundary[3]);

        pos[0] += -0.5*targetWidth;
        pos[1] += -gridOffsetY*boundary[3]*cellSize;


    }else if(mode & UICanvas.MODE.regular){

        $gridIndex2regularScreenPos(pos, [parseInt(col),parseInt(row)], cellSize);
    }else
        $assert(true);


    ctx.imageSmoothingEnabled = false;
    $assert(tileData['~rawImg']);//，{path:source}
    ctx.drawImage(tileData['~rawImg'],
        boundary[0]*tileCellSize, boundary[1]*tileCellSize, width,height,
        ...pos, targetWidth, targetHeight);
}

const ERR_COLOR$1 = editorSetting.setting.PALETTE.gridErrorColor;

class Palette extends implement(UIPalette, ILoad) {
    #paintPos = [0,0];
    #targetEndIndex = [0,0];
    #targetStartIndex =  [0,0];
    #paintDummyContents = [];
    #paintTargetIndice = null;
    #dragDataImgInfo = null;
    #paintOperation = null;

    #sortedContents = [];

    #tileSrcBoundaries = [];





    constructor(name='__test', params={style:{}}){
        super(name,params);
        // this['klass'] = 'Palette';
    }

    get Event (){return PaletteEvt.Instance;}








    async init() {
        await super.init();
        this.Title.Text = 'Palette';

        this.ToolMode |= Palette.TOOL_MODE.camTumble;
        this.onUIActionStart('camTumble');
        // this.onUIActionEnd('camTumble');



        this.shinningSpeed = editorSetting.setting.COMPONENTS.image.shinningSpeed;

    }


    toolAction(startPos,  endPos){
        if(this.ToolMode & UICanvas.TOOL_MODE.select)
            this.onSelecting(startPos.slice(), endPos.slice());
        else if(this.ToolMode & UICanvas.TOOL_MODE.paint)
            this.onPainting(startPos.slice(), endPos.slice());

    }
    selectEnd(){
        super.selectEnd();


        this.#tileSrcBoundaries.length = 0;
        for(const boundary of this.selection)
            this.#tileSrcBoundaries.push(...$pickByPaintSolver(this.pathID, boundary));
    }


    paintStart(){//ToolMode auto hookup
        this.#paintOperation = {};
        this.#paintDummyContents = [];
        this.#paintTargetIndice = [];
        console.log('paintStart');
    }
    onPainting(startPos,endPos = startPos){

        console.log('onPainting ======================================================================');

        const targetIndex = [0,0];

            $getAttr$1(`${this.pathID}|.contents`);

        if(this.Mode & UICanvas.MODE.isometric)
            $screenPos2isoIndex(targetIndex, endPos,this.CellSize, this.numOfGrids);//.slice()
        else if(this.Mode & UICanvas.MODE.regular)
            $screenPos2RegularIndex(targetIndex, endPos,this.CellSize);//.slice()

        if(!this.#paintTargetIndice) debugger;
        
        if(!this.#paintTargetIndice.find(ele=>ele[0] === targetIndex[0] && ele[1] === targetIndex[1]))
            this.#paintTargetIndice.push(targetIndex.slice());

        $checkPaletteSrc(this.pathID, targetIndex, this.selection,
            boundary=> $boundary2Indice(boundary)
                            .forEach(dstIndex=>
                                this.#paintOperation[targetIndex.toString()] = {
                                    operation:'erase',
                                }),
            (dstIndex,originData)=>
                this.#paintOperation[dstIndex.toString()] = {
                operation:'paint',
                ...originData,
            });


        $sortingGrid(this.#paintDummyContents,this.pathID,this.#paintOperation, this.numOfGrids[0], SORT_MODE.none);
    }
    async paintEnd(){//ToolMode auto hookup
        if(this.#paintTargetIndice == null) debugger;

        console.log(`paintEnd ******************************START`);
        if(this.selection.length)
            await Event$1.Instance.emit(common$1.setting.EVT_TYPES.paint, [
                this.pathID, //source
                this.pathID, //target
                this.selection.slice(),
                this.#paintTargetIndice.slice(),
            ]);

        console.log(`paintEnd ******************************END`);

        this.#paintDummyContents.length = 0;
        this.#paintOperation = {};
        this.#paintTargetIndice.length = 0;
    }




    initComponentListener(){
        const component = this.paletteComponent;
        //body/canvasLayout/kCanvas/group/paletteComponent
        component.addEventListener('over',evt=>{
            if(!$isDragging(evt)) return;

            const entryInfo = checkFileEntry(evt,this);
            if(!entryInfo) return;
            const {brushData, path} = entryInfo;
            $cancelGhostImg();
            this.#dragDataImgInfo = GenDragDataImgInfo(brushData, path);
        });
        //body/canvasLayout/kCanvas/group/paletteComponent
        component.addEventListener('out', evt=>{

            if(!this.pathID)
                return;

            $resumeGhostImg();
            if(this.ToolMode&UICanvas.TOOL_MODE.import)
                this.ToolMode &= ~UICanvas.TOOL_MODE.import;
            this.#dragDataImgInfo = null;
        });

        //body/canvasLayout/kCanvas/group/paletteComponent
        component.addEventListener('move',
            evt=>{
                if(!$isDragging(evt)) return;

                if(!this.pathID) return;
                if(!this.#dragDataImgInfo) return;
                this.#paintPos[0] = evt.localX;
                this.#paintPos[1] = evt.localY;
                this.#targetEndIndex =
                    dragOverComponent(evt,this, this.#targetStartIndex,
                                    this.#dragDataImgInfo.indexMaxShift);

            });
        component.addEventListener("drop",async evt=>{
            if(!this.pathID) return;

            const entryInfo = checkFileEntry(evt,this);
            if(!entryInfo) return;


            this.ToolMode &= ~UICanvas.TOOL_MODE.import;
            
            const srcPathID = $path2ID(getDropSource(evt,this));

            await Event$1.Instance.emit(common$1.setting.EVT_TYPES.import, [
                srcPathID, //source
                this.pathID,
                this.#targetStartIndex.slice(),
            ]);


            this.#dragDataImgInfo = null;
        }, {capture:false});
    }


    get CellSize(){
        return this.cellSize;
    }


    async initData(path, value){
        super.initData(path,value);


        const data = $getAttr$1(path);

        const
            {cellSize,numOfGrids, mode}= data,
            [COL,ROW] = $getNumber(numOfGrids);


        this.cellSize = $getNumber(cellSize);
        this.numOfGrids = $getNumber(numOfGrids);

        let width = COL*this.cellSize,
            height = ROW*this.cellSize;
        this.Mode &= ~UICanvas.MODE.gridModes;
        this.Mode |= $getNumber(mode);

        const widthGrids = this.numOfGrids[0];
        if(this.Mode & UICanvas.MODE.isometric){
            const leftBottom = [0,ROW],
                topRight = [COL, 0],
                topLeft = [0,0],
                rightBottom = [COL,ROW];
            $gridIndex2isoScreenPos(leftBottom, leftBottom.slice(), cellSize, widthGrids);
            $gridIndex2isoScreenPos(topRight, topRight.slice(), cellSize, widthGrids);
            width = topRight[0] - leftBottom[0];

            $gridIndex2isoScreenPos(rightBottom, rightBottom.slice(), cellSize, widthGrids);
            $gridIndex2isoScreenPos(topLeft, topLeft.slice(), cellSize, widthGrids);
            height = rightBottom[1] - topLeft[1];
        }


        await this.initCanvas(width,height);
        Event$1.Instance.emit(common$1.setting.EVT_TYPES.onPaletteRenderChange,[this.pathID]);



    }



    set Style(value){
        for(let name in value)
            this.style[name] = value[name];
    }





    preDraw(ctx, cam) {
        ctx.save();

        let matrix = cam.matrix?cam.matrix:cam;
        ctx.setTransform(matrix[0], matrix[1], matrix[2], matrix[3], matrix[4], matrix[5]);
    };

    postDraw(ctx) {
        ctx.restore();

    };

    drawSelectedBoundary(ctx) {
        super.drawSelectedBoundary(ctx);

        if(!this.pathID) return;

        const data= this.pathID?$getAttr$1(this.pathID):{'.contents':{}};
        const tileBoundaries = this.#tileSrcBoundaries
            .filter(([col,row])=>data['.contents'][[col,row].toString()]);

        const drawBoundaries = (this.Mode & UICanvas.MODE.isometric)?
            tileBoundaries.slice():
            tileBoundaries.map(boundary=>$isoMap2Bottom(boundary));


        ctx.filter = 'none';
        ctx.fillStyle = editorSetting.setting.PALETTE.selectedContentColor;
        for(const [col,row,width,height] of drawBoundaries)
            $drawCell(this,ctx,col,row, 'fill', width,height);

    }
    drawContents(canvas) {// hook up by parent class

        super.drawContents(canvas);
        const ctx = canvas.getContext('2d');
        ctx.clearRect(0,0,canvas.width,canvas.height);
        const   paletteData = this.pathID?$getAttr$1(this.pathID):{'.contents':{}},
                contents = paletteData['.contents'],
                sources = paletteData['sources'];


        const sortMode = (this.Mode & UICanvas.MODE.isometric)?SORT_MODE.bulk:SORT_MODE.none;

        $sortingGrid(this.#sortedContents, this.pathID, contents,this.numOfGrids[0], sortMode);
        const autoBrs =
            Object.entries(sources)
                .filter(([key,value])=>value)
                .map(([key,{source}])=>source)
                .filter(source=> source&&FileExt2Meta[$readPath(source).fileExt] ==FILE_TYPES.autoBrush);
        let grp4Baking = [];
        if(autoBrs.length){
            for(const source of autoBrs){
                grp4Baking = $genAutoBrBakingInfo(source,this.pathID);
            }
        }

        // const tileBrs = {};
        for(const {index,data} of this.#sortedContents) {

            const
                [col,row] = index,
                {srcIndex,boundary} = data,
                {source} = sources[srcIndex];

            const tileData = $getAttr$1(source);
            if(!tileData['~rawImg'])
                ;

            // if(source&&!tileBrs[source])
            //     tileBrs[source] = $getFileEntry(source);

            if(this.Status & common$1.setting.BASIC_STATUS.error) //||(this.Status & common.setting.BASIC_STATUS.error)
                $drawErrCell(this,ctx,col,row, ERR_COLOR$1);
            else {
                const type = FileExt2Meta[$readPath(source).fileExt];
                try{
                    if(type === FILE_TYPES.tileBrush){
                        bakeTileBr(ctx,col,row, paletteData,$genBoundary(boundary),$getAttr$1(source));//{source,boundary}
                    }if(type === FILE_TYPES.autoBrush){
                        const {source,boundary} = grp4Baking.find(ele=>ele.index[0] === col && ele.index[1] === row);
                        bakeTileBr(ctx,col,row,paletteData,$genBoundary(boundary),$getAttr$1(source));//{source,boundary}
                    }
                }catch (err){
                    debugger;
                    $drawErrCell(this,ctx,col,row, ERR_COLOR$1);
                }
            }
        }

    }

    drawingImportDummy(ctx){
        $assert(this.#dragDataImgInfo&&this.#dragDataImgInfo.img);
        const {path,img,imgScale} = this.#dragDataImgInfo;
        $assert(img);



        $assert(img instanceof HTMLCanvasElement ||img instanceof Image);
        $assert(this.#paintPos&&$isNumber$1(this.#paintPos[0])&&$isNumber$1(this.#paintPos[1]),
            'this.#paintPos internal err', common$1.error.ERR_TYPE.internalErr);

        const drawPos = this.#paintPos.slice();
            $getAttr$1(path);
        ctx.drawImage(img,...drawPos);

        //for(let {boundary} of $readFileDataValue(`${path}|slices`)){

        //     boundary = $genBoundary(boundary);
        //
        //     const
        //         tileSize = $readFileDataValue(`${path}|cellSize`),
        //         srcPos = [boundary[0]*tileSize, boundary[1]*tileSize],
        //         COL = boundary[2] - boundary[0],
        //         ROW = boundary[3] - boundary[1],
        //         srcSize = [tileSize*COL, tileSize*ROW],
        //         dstSize = [this.cellSize*COL,this.cellSize*ROW];
        //     drawPos[1] += ROW*this.cellSize;
        //     ctx.drawImage(img, ...srcPos, ...srcSize ,  ...drawPos, ...dstSize);
        // }



        ctx.fillStyle = editorSetting.setting.PALETTE.selectedGridColor;

        $assert(this.#targetEndIndex);
        $drawCell(this,ctx,...this.#targetStartIndex, 'fill',
            this.#targetEndIndex[0] - this.#targetStartIndex[0],
            this.#targetEndIndex[1] - this.#targetStartIndex[1]);

    }
    drawingPaintDummy(ctx){
        if(!this.#paintDummyContents) return;

        ctx.globalAlpha = 0.7;
        try{
        for(const ele of this.#paintDummyContents) {
            const
                {index,data} = ele,
                {  operation, boundary,srcIndex} = data,
                [col,row] = index;


            if (operation === 'paint') {
                let source = $getAttr$1(`${this.pathID}|sources`)[srcIndex]['source'],
                    drawBoundary = null;

                if(!source) continue;

                if(FileExt2Meta[$readPath(source).fileExt] & FILE_TYPES.autoBrush){
                    const autoBrData =  $getAttr$1(source);
                    source = autoBrData['source'];
                    drawBoundary = autoBrData['autoTile'][0]['boundary'];
                }else
                    drawBoundary = $genBoundary(boundary);
                const
                    tileData = $getAttr$1(source),
                    tileCellSize = $getNumber(tileData['cellSize']),
                    srcPos = [drawBoundary[0]*tileCellSize, drawBoundary[1]*tileCellSize],
                    img = tileData['~rawImg'];

                const pos = [0, 0];

                if(!(this.Status&common$1.setting.BASIC_STATUS.error)){

                    if(this.Mode & UICanvas.MODE.isometric){
                        $gridIndex2isoScreenPos(pos, [col,row], this.CellSize, this.numOfGrids[0]);

                        const width = drawBoundary[2]*tileCellSize,
                            height = drawBoundary[3]*tileCellSize,
                            targetWidth = drawBoundary[2]*this.CellSize,
                            targetHeight = drawBoundary[3]*this.CellSize;

                        const gridOffsetY = $isoBottomOffsetY(drawBoundary[2], drawBoundary[3]);

                        pos[0] += -0.5*targetWidth;
                        pos[1] += -gridOffsetY*drawBoundary[3]*this.CellSize;
                        ctx.drawImage(img,...srcPos,width,height,
                            ...pos, targetWidth, targetHeight);

                    }else if(this.Mode & UICanvas.MODE.regular){

                        $gridIndex2regularScreenPos(pos, [col,row], this.CellSize);
                        ctx.drawImage(img,...srcPos,tileCellSize,tileCellSize,
                            ...pos, this.CellSize, this.CellSize);
                    }
                }else
                    $drawErrCell(this,ctx,col,row, ERR_COLOR$1);


            } else if(operation === 'erase'){//erase
                ctx.fillStyle = 'black';
                $drawCell(this,ctx,  Number(col),Number(row));
            }

            ctx.globalAlpha = 1;

        }
        }catch (e) {
            debugger;
        }

        // qb
    }

    #drawingISOSelectedJump(ctx, data, callback=_=>{}){

        for(const {content,index} of data){
            const   [col, row] = index;
            $assert(content);
            let {srcIndex,boundary} = content,
                source = $getAttr$1(`${this.pathID}|sources`)[srcIndex]['source'];
                    //this.data['sources'][srcIndex];
            boundary = $genBoundary(boundary);

            const
                tileData = $getAttr$1(source),
                tileCellSize = $getNumber(tileData['cellSize']),
                width = boundary[2]*tileCellSize,
                height = boundary[3]*tileCellSize,
                targetWidth = boundary[2]*this.cellSize,
                targetHeight = boundary[3]*this.cellSize;
            const pos = [0, 0];
            $gridIndex2isoScreenPos(pos, [col,row], this.CellSize, this.numOfGrids[0]);

            const gridOffsetY = $isoBottomOffsetY(boundary[2], boundary[3]);


            pos[0] += -0.5*boundary[2]*this.cellSize;
            pos[1] +=-gridOffsetY*boundary[3]*this.cellSize;

            const
                multiplier= editorSetting.setting.PALETTE.selectedOffsetYMultiplier,
                offsetY = this.cellSize*multiplier,
                time = (Date.now()-this.selectedTimeOffset)/1000;
            pos[1] -= (Math.sin(time * this.shinningSpeed)*offsetY).clamp(0,offsetY);


            ctx.globalAlpha = 0.7;


            if(source&&$isOulineExist()&&(($getFileEntry(source)?.Status ) & common$1.setting.BASIC_STATUS.error))
                $drawErrCell(this,ctx,col,row, ERR_COLOR$1);
            else
                ctx.drawImage(tileData['~rawImg'],
                    boundary[0]*tileCellSize, boundary[1]*tileCellSize, width,height,
                    ...pos, targetWidth, targetHeight);
            callback(...pos, {content,index});
            ctx.globalAlpha = 1;



        }
    }
    // _preDraw(ctx,cam){
    //
    //     super._preDraw(ctx);
    // }
    _drawHandler(ctx,cam){//this = component

        // const cls = interfaces.convertTo(this,'UIPalette');
        // super.drawHandler(ctx,cam);
        super._drawHandler(ctx);


        if(this.ToolMode & UICanvas.TOOL_MODE.import){//dragging img
            if(!(this.Status&common$1.setting.BASIC_STATUS.error))
                this.drawingImportDummy(ctx);
        }else if(this.ToolMode&UICanvas.TOOL_MODE.paint && this.ToolMode&UICanvas.TOOL_MODE.interactionStart){
            // if(!(this.Status&common.setting.BASIC_STATUS.error))
                this.drawingPaintDummy(ctx);
        }else  if(this.ToolMode & UICanvas.TOOL_MODE.select && this.Mode & UICanvas.MODE.isometric) {
            const data= this.pathID?$getAttr$1(this.pathID):{'.contents':{}};
            const contents = this.#tileSrcBoundaries
                .filter(([col,row])=>data['.contents'][[col,row].toString()])
                .map(([col,row])=>{return {content: data['.contents'][[col,row].toString()], index:[col,row]}});

            // for(let [col,row]  of  this.#tileSrcBoundaries)
            //     contents.push({content: data['.contents'][[col,row].toString()], index:[col,row]});


            this.#drawingISOSelectedJump(ctx,contents);
        }

        if(this.authors.length&& this.Mode & UICanvas.MODE.isometric){
            const data = //this.pathID??{'.contents':[]};
                this.pathID?$getAttr$1(this.pathID):{'.contents':{}};
            const contents = [];
            for(const {indice} of this.authors)
                for(const index of indice)
                    if(data['.contents'][index.toString()])
                        contents.push({content:data['.contents'][index.toString()], index});


            this.#drawingISOSelectedJump(ctx,contents, (x,y, {index})=>{
                ctx.textBaseline = 'top';
                ctx.fillStyle =  this.fontParams.color;

                ctx.font =  this.Font;
                const finder = this.authors.find(({indice})=>indice.find(ele=>ele.toString() == index.toString())),
                    {device} = finder;
                let usrName = device.split('-')[0];
                usrName = usrName||'';
                ctx.fillText(usrName, x,y);
            });
        }
    }
    _postDraw(ctx){
        super._postDraw(ctx);
    }



    registEvt() {
        super.registEvt();


    }
    // GROUP_LENGTH = 5;
    authors = [];
    onRenderChange(evt,targetPath){
        super.onRenderChange(evt,targetPath);
        const history = EventDispatcher.Publishers.slice().reverse(),
            paintCMD = history.find(({type})=>new RegExp(common$1.setting.EVT_TYPES.paint).test(type));
        if(!paintCMD) return; //skip when %open onRenderChange
        const device = paintCMD.evt.options.device??'',
            target = paintCMD.params[1],
            indice = paintCMD.params[3];
        if(target === this.pathID){
            this.authors.push({device,target,indice});
            setTimeout(_=>this.authors.shift(),2000);
        }
        // if(this.authors.length>this.GROUP_LENGTH)
        //     this.authors.shift();
    }
    clear(){
        // this.refresh();
        this.#dragDataImgInfo = null;
        this.#paintOperation = null;
        this.#paintDummyContents = null;

        return super.clear();//async
    }

    delete(){
        super.delete();
        debugger;
        this.#paintPos = null;
        this.#paintTargetIndice = null;
        this.#dragDataImgInfo = null;
        this.#paintOperation = null;
    }





    static async  onLoad(){
        const img = document.getElementById('keanuSrc'),
            toolIcons = {},
            TOOLS = editorSetting.setting.TOOLS_BOX[this.name]??[];
        for(const toolNm of TOOLS)
            toolIcons[toolNm] =
                await $imgCrop( img, ...editorSetting.setting.PALETTE.icon[toolNm]);

        return Promise.resolve({toolIcons});

    }
    onFinishLoad({toolIcons}){
        this.toolIcons = toolIcons;
    }


}
customElements.define('palette-editor', Palette);

class BrushEvt extends Event$1{

    constructor(){
        super();
    }



}

class Brush extends implement(UIPalette) {


    #selectedTimeOffset = null;

    selection = [];
    startPos = [0,0];

    #twoPanelBody = null;



    constructor(name='__test', params={style:{}}){
        super(name,params);
        // this['klass'] = 'Brush';
    }

    get Event (){return BrushEvt.Instance;}

    onErrorFixed(path){
        if(super.onErrorFixed(path) === false) return false;

        this.#rawImg = $getAttr$1(path)['~rawImg']??null;
    }
    async initData(path){
        super.initData(path);

        const data = $getAttr$1(path);
        this.#rawImg = data['~rawImg']??null;
        const
            {cellSize,offset,padding, slices}= data;
        this.cellSize = $getNumber(cellSize);
        this.padding = $getNumber(padding);
        this.offset = $getNumber(offset);

        const img = $getAttr$1(data.source);
        let    {width,height} = img;


        if(width === undefined || height === undefined){
            const bounds = [-1,-1];
            slices.forEach(({boundary})=> {
               const maxX = boundary[0]+(boundary[2]??0),
                    maxY = boundary[1]+(boundary[3]??0);
                bounds[0] = Math.max(bounds[0], maxX);
                bounds[1] = Math.max(bounds[0], maxY);
            });
            width =     bounds[0]*this.cellSize;
            height =    bounds[1]*this.cellSize;
            this.numOfGrids = bounds;
        }else
            this.numOfGrids = [Math.ceil(width/this.cellSize), Math.ceil(height/this.cellSize)];
        await this.initCanvas(width,height);





        Event$1.Instance.emit(common$1.setting.EVT_TYPES.onPaletteRenderChange,[this.pathID]);
    }





    async init() {
        await super.init();
        this.Title.Text = 'Brush';

        this.ToolMode |= Brush.TOOL_MODE.camTumble;
        this.onUIActionStart('camTumble');
        // this.onUIActionEnd('camTumble');

        this.Mode |=  UICanvas.MODE.regular;

    }

    initialized(){

        // this.testGrid({cellSize:16, numOfGrids:[10,10]});
    }



    // async testGrid({cellSize, numOfGrids}){
    //     this.numOfGrids = numOfGrids;
    //     this.cellSize = $getNumber(cellSize);
    //     const width = numOfGrids[0]*this.cellSize,
    //         height = numOfGrids[1]*this.cellSize;
    //
    //     await this.initCanvas(width,height);
    // }
    #rawImg = null;
    // async open(pathID){
    //
    //     const
    //         entry = $getFileEntry(pathID),
    //         data = entry.EntryData;
    //     this.#rawImg = data['~rawImg'];
    //
    //     if((entry.Status & common.setting.BASIC_STATUS.error) || !this.#rawImg){
    //         this.refreshTitle('FILE_ERR');
    //         this.clear();
    //     } else
    //         await super.open(pathID);
    //
    // }

    async open(pathID){
        this.#rawImg =  $getAttr$1(`${pathID}|~rawImg`);
            //$getFileEntry(pathID).EntryData['~rawImg'];
        await super.open(pathID);
    }


    toolAction(startPos,  endPos){
        if(this.ToolMode & UICanvas.TOOL_MODE.select)
            this.onSelecting(startPos.slice(), endPos.slice());
        else if(this.ToolMode & UICanvas.TOOL_MODE.cut){
            this.onSelecting(startPos.slice(), endPos.slice());
            this.onCutting(startPos.slice(), endPos.slice());
        }else if(this.ToolMode & UICanvas.TOOL_MODE.copy)
            this.onCopying(startPos.slice(), endPos.slice());

    }


    cutStart(){
        this.selection.length = 0;
    }
    async cutEnd(){
        if(this.selection.length == 0) return;
        const gridIndex =  this.selection[0].slice(), pos = [0,0];
        $gridIndex2regularScreenPos(pos, gridIndex, this.CellSize);
        //this.addTextBox(pos);


        const
            slices = $getAttr$1(`${this.pathID}|slices`);
        if(!slices) return;
        const length = slices.length;
            JSON.parse(JSON.stringify(this.selection));

        const boundary = this.selection[0];





        if(slices.find(ele=>ele.boundary.toString() == boundary.toString()));else
            await Event$1.Instance.emit(common$1.setting.EVT_TYPES.setAttr, [
                this.pathID, {slices:{
                        [length]:{
                            // name,
                            boundary
                        }}}
            ]);

        this.selection.length = 0;
        return Event$1.Instance.emit(common$1.setting.EVT_TYPES.onPaletteRenderChange,[this.pathID]);

    }


    copyStart(e){
        debugger;
    }
    copyEnd(){

    }
    onCopying(){

    }




    onCutting(startPos,endPos = startPos){

        const   start = [0,0],
            end = [0,0];

        this.#selectedTimeOffset = Date.now();


        $assert(this.Mode & UICanvas.MODE.regular);

        $screenPos2RegularIndex(start, startPos,this.CellSize);
        $screenPos2RegularIndex(end, endPos,this.CellSize);


        // const boundary = [0,0,0,0];
        // $selection2Boundary(boundary, [start, end]);
        //
        // this.selection.length = 0;
        // this.addSelection(boundary);
        //
        // console.log('onPaletteSelectionChange onCutting');
        // this.Event.emit(common.setting.EVT_TYPES.onPaletteSelectionChange,this, [this.selection]);
    }







    get CellSize(){
        return this.cellSize;
    }


    drawSelectedBoundary(ctx) {
        super.drawSelectedBoundary(ctx);
        if(!this.pathID) return;
        const slices = $getAttr$1(`${this.pathID}|slices`);
        if(!slices) return;
        let selectedSlices = [];
        for(const selBoundary of this.selection )
            selectedSlices = slices.filter(({boundary})=>$isBoundaryOverlap(boundary,selBoundary));

        selectedSlices = selectedSlices.map(({boundary})=>boundary);

        ctx.filter = 'none';
        ctx.fillStyle = editorSetting.setting.PALETTE.selectedContentColor;
        for(const [col,row,width,height] of selectedSlices)
            $drawCell(this,ctx,col,row, 'fill', width, height);
    }


    drawCuttingBoundary(ctx) {

        ctx.strokeStyle = editorSetting.setting.PALETTE.cuttedBoundaryStrokeColor;
        ctx.lineWidth = editorSetting.setting.PALETTE.cuttedLineWidth;

        ctx.filter = `brightness(${(Math.sin((Date.now()-this.#selectedTimeOffset)/1000 * this.shinningSpeed) + 2) * 0.5})`;

        const boundary = [0,0,0,0];
        $selection2Boundary(boundary,this.selection.map(ele=>ele.index));
        $assert(this.Mode & UICanvas.MODE.regular);
        if(this.selection.length)
            $drawCell(this,ctx, boundary[0], boundary[1], 'stroke', boundary[2], boundary[3]);
    }




    drawContents(canvas) {// hook up by parent class
        super.drawContents(canvas);

        const
            slices = $getAttr$1(`${this.pathID}|slices`),
            img = $getAttr$1(`${this.pathID}|~rawImg`),//this.data['~rawImg'],
            cellSize = this.cellSize;

        const ctx = canvas.getContext('2d');
        ctx.save();
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        ctx.globalAlpha = 1.0;
        try{
        for(const {boundary}  of slices) {
            const bound = $genBoundary(boundary),
                pos = [bound[0]*cellSize,bound[1]*cellSize],
                size = [(bound[2])*cellSize,(bound[3])*cellSize];

            if(this.Status & common$1.setting.BASIC_STATUS.error){
                for(let col = bound[0]; col<bound[0]+bound[2]; col++)
                    for(let row = bound[1]; row<bound[1]+bound[3]; row++)
                        $drawErrCell({cellSize},ctx,col,row, ERR_COLOR);
            }else
                ctx.drawImage(img,...pos, ...size,...pos, ...size);
        }
        }catch (e){debugger;}
        ctx.globalAlpha = 0.5;

        if(!(this.Status & common$1.setting.BASIC_STATUS.error))
            ctx.drawImage(this.#rawImg,0,0);
        ctx.restore();
    }

    registEvt() {
        super.registEvt();

        this.Event.on(common$1.setting.EVT_TYPES.setAttr, this.onActive((evt, path, value)=>{
            const brush = evt.subscriber,
                {nakedPath, attrKeys} = $readPath(path);

            if(brush.path !== nakedPath) return;
            brush.initData(nakedPath);
        }), {subscriber:this} );


    }



    delete(){
        super.delete();
        this.toolIcons = null;
        this.selection.length = 0;
    }

    drawHandler=(ctx,cam)=>{//this = component

        if(this.ToolMode & Brush.TOOL_MODE.cut){
            // this.drawSelectedBoundary(ctx);
            this.drawCuttingBoundary(ctx);
        }



    }

    _preDraw(ctx,cam){
        super._preDraw(ctx);
    }
    _drawHandler(ctx,cam){
        super._drawHandler(ctx);
    }
    _postDraw(ctx){
        super._postDraw(ctx);
    }





    static async  onLoad(){
        const img = document.getElementById('keanuSrc'),
            toolIcons = {},
            TOOLS = editorSetting.setting.TOOLS_BOX[this.name]??[];
        for(const toolNm of TOOLS)
            toolIcons[toolNm] =
                await $imgCrop( img, ...editorSetting.setting.PALETTE.icon[toolNm]);

        return Promise.resolve({toolIcons});

    }
    onFinishLoad({toolIcons}){
        this.toolIcons = toolIcons;
    }


}
customElements.define('brush-editor', Brush);

const BUTTONS = common$1.setting.MOUSE_BUTTONS;
function  getPath(out,ele){
    out.path.push(ele.getAttribute('cmd'));
    // if(out.writeHistory == null)
    //     out.writeHistory = ele.getAttribute('writeHistory')=='false'?false:true;
    if(ele.parentElement.getAttribute('cmd'))
        return getPath(out,ele.parentElement);

}

function hideAllChildren(ele){


    for(const child of ele.children){
        child.style['display'] = 'none';
        child.style['background-color'] = 'white';
        child.style['font-weight'] = 'initial';
        hideAllChildren(child);
    }
}

function reset(ele){

    if(ele.parentElement instanceof Menu){
        const otherSilblings =[...ele.parentElement.children].filter(child=>child!=ele);
        otherSilblings.forEach(sibling=>{
            sibling.style['background-color'] = 'white';
            sibling.style['font-weight'] = 'initial';
        });
    }

    hideAllChildren(ele);
}

class Menu  extends implement(HTMLBaseElement){
    static instance;
    static MODE = {active:1};

    mode = 0;
    set Mode(value){
        if(!(this.mode & Menu.MODE.active) && value & Menu.MODE.active){
            Event$1.Instance.emit(common$1.setting.EVT_TYPES.onPopupMenu, this.target, ['open',this.target.FullName]);

        } else if( this.mode & Menu.MODE.active && !(value & Menu.MODE.active)){
            Event$1.Instance.emit(common$1.setting.EVT_TYPES.onPopupMenu, this.target, ['close',this.target.FullName]);
        }

        this.mode = value;

    }
    get Mode(){return this.mode;}
    constructor(...args) {
        super(args);



        this.target = null;

        this.style['display'] = "none";
        this.style['position'] = "relative";
        this.style['top'] = "-20px";
        this.style['left'] = "100%";
        this.style['width'] = "80px";
    }

    //only root exe initialize
    initialize(){

        this.menuSetting = {};
        Menu.instance = this;

        this.style['position'] = "absolute";
        this.setAttribute('text','☰ MENU>');
        this.classList.add('pop-menu');

        if(__ua.sysFlag & common$1.system.SYS_FLAG.Desktop)
            window.addEventListener("contextmenu",evt=> evt.preventDefault());



        //TODO:regist window
        // window.addEventListener("pointerdown", evt => {
        //     const isClickOnMenu =  (evt.target instanceof Menu);
        //     if(!isClickOnMenu && this.Mode & Menu.MODE.active && evt.buttons&BUTTONS.leftBtn){
        //         this.hide();
        //         evt.stopPropagation();
        //     }else if(__ua.sysFlag & common.system.SYS_FLAG.Desktop && evt.buttons&BUTTONS.rightBtn) {
        //         const {target, menuSetting} = this.getTarget(evt)??{target:null, menuSetting:null};
        //         if(target == null) return;
        //         this.show(target,menuSetting,[evt.clientX,evt.clientY]);
        //         evt.stopPropagation();
        //     }
        // },true);


        // this.addEventListener('pointerup',evt=>{
        //
        //     let result = {path:[], writeHistory:null};
        //     getPath(result,evt.target);
        //     const isLeafEnd = evt.target.childElementCount == 0;
        //     if(isLeafEnd){
        //         Event.Instance.emit(result.path.reverse().join('/'), [this.target.name],{writeHistory:false});//result.writeHistory
        //         this.hide();
        //         evt.stopPropagation();
        //     }
        // });

    }

    regist(def){
        this.menuSetting = def; //JSON.parse(JSON.stringify(def));
    }

    create(curEle = this, def){
        curEle.addEventListener('pointerdown',evt =>{

            if(evt.target != evt.currentTarget)//click current node not bubbling
                return;

            reset(curEle);

            curEle.style['font-weight'] = 'bold';
            curEle.style['background-color'] = 'gray';
            for(const child of curEle.children)
                child.style['display'] = 'block';

        });
        for(let obj of def){
            // let ele = document.createElement('popup-menu');
            const ele = new Menu();
            ele.setAttribute('cmd',obj.cmd);

            const text = obj.cmd.slice(1);
            ele.classList.add('pop-menu');


            if(obj.children){
                ele.setAttribute('text',`☰${text}>`);
                this.create(ele, obj.children);
            }else
                ele.setAttribute('text',`${text}`);

            curEle.append(ele);
        }


    }

    hide(evt){

        // $assert(evt.target);
        // debugger;
        // const editorName = evt.target.getAttribute('editorName');
        // $assert(editorName);
        //
        // const editor = Keanu.editors.objs[editorName];
        //
        // const controller = editor.Controller;
        //
        // const TOUCH_STATE = controller.constructor.TOUCH_STATE;
        // controller.touchState &= ~TOUCH_STATE.menu;

        this.Mode &= ~Menu.MODE.active;
        this.style['display'] = "none";
        this.target = null;
    }
    checkMenuSetting(fullName){
        const settings = Object.values(this.menuSetting),
            menuSetting = settings.find(ele=>ele.pathRegExp.test(fullName));
        return menuSetting;
    }
    getTarget(evt){
        $assert(evt&&evt.target);
        const editorName = evt.target.getAttribute('editorName');
        console.log(evt.target);
        $assert(editorName);

        Keanu.editors.objs[editorName];


        const capturedEles = $captureDeep(evt, false);

        if(capturedEles.length ==0) return null;

        const fullName = capturedEles[0].fullName,
            target = $findByFullName(fullName),
            menuSetting = this.checkMenuSetting(fullName);

        if(!menuSetting)
            return null;

        return {target, menuSetting};
    }


    show(target,menuSetting, pos){
        reset(this);
        const oldTarget = this.target;
        this.target = target;
        this.Mode |= Menu.MODE.active;

        if(oldTarget != this.target){
            this.clear();
            this.create(this, menuSetting.menus);
        }
        this.style['display'] = "block";
        this.style.left = (pos[0] - 10) + "px";
        this.style.top = (pos[1] - 10) + "px";
    }

    handler = evt=>{
        const quit = _=>{
            this.hide(evt);
            evt.stopPropagation();
            Controller.removeEventListener('release',this.handler);
        };
        const isClickOnMenu =  (evt.target instanceof Menu);
        if(!isClickOnMenu)
            return quit();
        else if(this.Mode & Menu.MODE.active && !(evt.buttons&BUTTONS.leftBtn))
            return quit();

        let result = {path:[], writeHistory:null};
        getPath(result,evt.target);
        const isClickLeafEnd = evt.target.childElementCount == 0;
        if(isClickLeafEnd){
            $assert(this.target);
            Event$1.Instance.emit(result.path.reverse().join('/'), [this.target.FullName],{writeHistory:false});//result.writeHistory
            return quit();
        }
    };

    active(target,menuSetting, pos, Controller){
        if(!(this.Mode & Menu.MODE.active))
            Controller.addEventListener('release',this.handler);

        this.show(target,menuSetting, pos);




    }


    clear() {
        for (let i = this.children.length - 1; i >= 0; i--) {
            this.removeChild(this.children[i]);
        }

    }



}
customElements.define('pop-menu-element', Menu);

class HistoryEvent extends Event$1 {

    constructor(){
        super();

    }

}

class HistoryEntry extends implement(EntryLayout,ILoad){
    headImg = null;

    constructor(params={cmd:{type:'test'}}){
        super(params);
    }

    set Mode(val){
        super.Mode = val;


        if(val & EntryLayout.MODE.cmd){
            switch (this.params.cmd.type){
                case common$1.setting.EVT_TYPES.select:
                    this.iconItem.Image = Keanu.loadedItems['selectIcon'];
                    break;
                case common$1.setting.EVT_TYPES.setAttr:
                    this.iconItem.Image = Keanu.loadedItems['setAttrIcon'];
                    break;
            }
        }

    }

    get Mode(){return super.Mode;}



    // set Color(val){
    //     debugger;
    //     super.Color = val;
    // }
    //
    // get Color(){return super.Color;}

    resize(size=[this.Width,this.Height]){
        debugger;
        super.resize(size);
    }


    static async  onLoad(){
        window.config['contributors']; const projInfo = {};
        for(let contributor of window.config['contributors']){
            // projInfo[contributor.username] = await loadImg(contributor.headImgURL);
        }
        Keanu.loadedItems['projInfo'] = projInfo;
        const srcImg = document.getElementById('keanuSrc');
        Keanu.loadedItems['selectIcon'] = await $imgCrop( srcImg,  ...editorSetting.setting.OUTLINE.selectIcon);
        Keanu.loadedItems['setAttrIcon'] = await $imgCrop( srcImg,  ...editorSetting.setting.OUTLINE.setAttrIcon);
    }



    async initialize(){


        super.initialize();

        this.color = this.params.color??editorSetting.setting.HISTORY.color;
        this.text = this.params.cmd.type.match(/[a-zA-Z]+/)[0];
        this.layoutMode |= HistoryEntry.LAYOUT_MODE.resizeX;

        const fontParams =  {
            bold:editorSetting.setting.HISTORY.fontParams.bold,
            size:editorSetting.setting.HISTORY.fontParams.size,
            font:editorSetting.setting.HISTORY.fontParams.font,
            color:editorSetting.setting.HISTORY.fontParams.color
        };
        const indexLabel = new TextBox(this.name + '-textLabel', {
            color:this.color,
            text:this.params.cmd.index,
            fontParams,
            mode :TextBox.MODE.omit,
            layoutMode:HistoryEntry.LAYOUT_MODE.resizeY|HistoryEntry.LAYOUT_MODE.lockRatio
        });
        await this.appendChild(indexLabel);
        indexLabel.initialize();


        const iconItem = new KImage(this.name+'-CMDicon',{
            layoutMode:HistoryEntry.LAYOUT_MODE.resizeY|HistoryEntry.LAYOUT_MODE.lockRatio
        });
        await this.appendChild(iconItem);
        iconItem.initialize();
        this.iconItem = iconItem;


        const textLabel = new Label(this.name + '-textLabel', {
            color:this.color,
            text:this.text,fontParams,
            preferredSize:2*editorSetting.setting.OUTLINE.entryHeight,
            layoutMode:HistoryEntry.LAYOUT_MODE.resizeX|HistoryEntry.LAYOUT_MODE.resizeY
        });
        await this.appendChild(textLabel);
        textLabel.initialize();

        const headImg = new KImage(this.name+'-headImg',{
            layoutMode:HistoryEntry.LAYOUT_MODE.resizeY|HistoryEntry.LAYOUT_MODE.lockRatio
        });
        headImg.Image = Keanu.loadedItems['projInfo'][this.params.cmd.usrName];
        await this.appendChild(headImg);
        headImg.initialize();


        const dateText = formatDate(this.params.cmd.timestamp);
        let dateLabel = new Label(this.name + '-dateLabel', {
            color:this.color,
            text:dateText,fontParams,
            preferredSize:4*editorSetting.setting.OUTLINE.entryHeight,
            layoutMode:HistoryEntry.LAYOUT_MODE.resizeX|HistoryEntry.LAYOUT_MODE.resizeY
        });
        await this.appendChild(dateLabel);
        dateLabel.initialize();


        if(this.params.mode) this.Mode = this.params.mode;
    }


}

async function onHistoryAdd(evt,index,cmd,historyEditor){

    const cmdEntry = new HistoryEntry({
                    cmd,
                    mode: HistoryEntry.MODE.cmd
        });

    historyEditor.Content.insertChild(0, cmdEntry);
    await cmdEntry.initialize();
    historyEditor.refresh();

    const children = historyEditor.Content.group.Children.reverseArray;
    for(const entry of children) {

        entry.Mode &= ~HistoryEntry.MODE.selecting;
        const decedents = depthFirstSearch(entry);
        for(const decedent of decedents)
            decedent.Color = editorSetting.setting.HISTORY.color;
    }

    const highlightIndex = historyEditor.event.HistoryIndex-1;
    $assert(children[highlightIndex]);
    children[highlightIndex].Mode |= HistoryEntry.MODE.selecting;
    const decedents = depthFirstSearch( children[highlightIndex]);
    for(const decedent of decedents)
        decedent.Color = editorSetting.setting.HISTORY.selectColor;

}

function onHistoryDel(evt,index){
    const historyEditor = window.Keanu.editors.objs['History'],
        children = historyEditor.Content.group.Children.reverseArray.slice();

    for(const entry of children)
        if(entry.params.cmd.index>=index)
            entry.delete();

    historyEditor.refresh();
}


function lock(editor){
    editor.Status &= ~Controller.STATUS.active;
    //editor.Controller.Status &= ~Controller.STATUS.active;
    for(let child of editor.Controller.Children)
        child.Status &= ~Controller.STATUS.active;
    setGrayScale(editor, 0.7);

    editor.Controller.addEventListener('click',unlock);
}
async function unlock(editor){
    //filter: grayscale(0%);
    await Event.Instance.endRecalling();



    editor.Status |= Controller.STATUS.active;
    // editor.Controller.Status |= Controller.STATUS.active;
    for(let child of editor.Controller.Children)
        child.Status |= Controller.STATUS.active;
    setGrayScale(editor, 0.0);


    editor.Controller.removeEventListener('click',unlock);
}

function undoRedo(evt,historyEditor){
    const   children = historyEditor.Content.group.Children.reverseArray,
            highlightIndex = children.findIndex(ele=>ele.Mode&HistoryEntry.MODE.selecting);


    const activeIndex = EventDispatcher$1.getSubscriberResult(evt, undoRedo$1) - 1;

    if(children.length == 0)
        return;

    if(children[highlightIndex]){
        children[highlightIndex].Mode &= ~HistoryEntry.MODE.selecting;

        const decedents = depthFirstSearch(children[highlightIndex]);
        for(const decedent of decedents)
            decedent.Color = editorSetting.setting.HISTORY.color;
    }



    if(children[activeIndex]) {
        children[activeIndex].Mode |= HistoryEntry.MODE.selecting;
        const decedents = depthFirstSearch(children[activeIndex]);
        for(const decedent of decedents)
            decedent.Color = editorSetting.setting.HISTORY.selectColor;
    }

}

class History extends implement(UIScrollable) {
    static MODE = {recalling:1}





    mode = 0;

    constructor(name='__test',params){
        super(name,params);
    }

    get Event (){return HistoryEvent.Instance;}


    registEvt(){
        super.registEvt();

        this.Event.on(common$1.setting.EVT_TYPES.undo,  this.onActive((..._)=>
            undoRedo(..._, this)
        ), {subscriber:this});
        this.Event.on(common$1.setting.EVT_TYPES.redo,  this.onActive((..._)=>
            undoRedo(..._, this)
        ), {subscriber:this});

        this.Event.on(common$1.setting.EVT_TYPES.lock,  this.onActive(_=>lock(this)), {subscriber:this});
        this.Event.on(common$1.setting.EVT_TYPES.unlock,  this.onActive(_=>unlock(this)), {subscriber:this});


        this.Event.on(common$1.setting.EVT_TYPES.onHistoryStackAdd,   this.onActive((..._)=>onHistoryAdd(..._,this)), {subscriber:this});
        this.Event.on(common$1.setting.EVT_TYPES.onRecallingStart,  this.onActive((...params)=>{
            this.mode |= History.MODE.recalling;
            // evtHandler.lock(this);//...params
        }), {subscriber:this});
        this.Event.on(common$1.setting.EVT_TYPES.onRecallingEnd,  this.onActive((...params)=>{
            this.mode &= ~History.MODE.recalling;
            onHistoryDel(...params);
        }), {subscriber:this});

    }

    initListeners(){
        super.initListeners();
    }


    async init(){
        await super.init();
        this.Title.Text = 'history';
        // this.test();
    }





    delete() {
        super.delete();
    }



    test(){

        const historyEditor = window.Keanu.editors.objs['History'];
            historyEditor.event.History;

        for(let i=0;i<10;i++){
            const cmdEntry = new HistoryEntry({
                cmd:{type:'select',
                    timestamp:Date.now()},

                mode: HistoryEntry.MODE.cmd,
                height: editorSetting.setting.OUTLINE.entryHeight,
            });
            historyEditor.Content.insertChild(0, cmdEntry);
            cmdEntry.initialize();
        }

        const children = historyEditor.Content.group.Children;
        for(const entry of children)
            entry.Mode&=~HistoryEntry.MODE.selecting;

        children[0].Mode|=HistoryEntry.MODE.selecting;

        historyEditor.refresh();
    }

}
customElements.define('history-editor', History);

/**
 * @fileoverview
 * - modified davidshimjs/qrcodejs library for use in node.js
 * - Using the 'QRCode for Javascript library'
 * - Fixed dataset of 'QRCode for Javascript library' for support full-spec.
 * - this library has no dependencies.
 *
 * @version 0.9.1 (2016-02-12)
 * @author davidshimjs, papnkukn
 * @see <a href="http://www.d-project.com/" target="_blank">http://www.d-project.com/</a>
 * @see <a href="http://jeromeetienne.github.com/jquery-qrcode/" target="_blank">http://jeromeetienne.github.com/jquery-qrcode/</a>
 * @see <a href="https://github.com/davidshimjs/qrcodejs" target="_blank">https://github.com/davidshimjs/qrcodejs</a>
 */

//---------------------------------------------------------------------
// QRCode for JavaScript
//
// Copyright (c) 2009 Kazuhiko Arase
//
// URL: http://www.d-project.com/
//
// Licensed under the MIT license:
//   http://www.opensource.org/licenses/mit-license.php
//
// The word "QR Code" is registered trademark of
// DENSO WAVE INCORPORATED
//   http://www.denso-wave.com/qrcode/faqpatent-e.html
//
//---------------------------------------------------------------------
function QR8bitByte(data) {
    this.mode = QRMode.MODE_8BIT_BYTE;
    this.data = data;
    this.parsedData = [];

    // Added to support UTF-8 Characters
    for (var i = 0, l = this.data.length; i < l; i++) {
        var byteArray = [];
        var code = this.data.charCodeAt(i);

        if (code > 0x10000) {
            byteArray[0] = 0xF0 | ((code & 0x1C0000) >>> 18);
            byteArray[1] = 0x80 | ((code & 0x3F000) >>> 12);
            byteArray[2] = 0x80 | ((code & 0xFC0) >>> 6);
            byteArray[3] = 0x80 | (code & 0x3F);
        } else if (code > 0x800) {
            byteArray[0] = 0xE0 | ((code & 0xF000) >>> 12);
            byteArray[1] = 0x80 | ((code & 0xFC0) >>> 6);
            byteArray[2] = 0x80 | (code & 0x3F);
        } else if (code > 0x80) {
            byteArray[0] = 0xC0 | ((code & 0x7C0) >>> 6);
            byteArray[1] = 0x80 | (code & 0x3F);
        } else {
            byteArray[0] = code;
        }

        this.parsedData.push(byteArray);
    }

    this.parsedData = Array.prototype.concat.apply([], this.parsedData);

    if (this.parsedData.length != this.data.length) {
        this.parsedData.unshift(191);
        this.parsedData.unshift(187);
        this.parsedData.unshift(239);
    }
}

QR8bitByte.prototype = {
    getLength: function (buffer) {
        return this.parsedData.length;
    },
    write: function (buffer) {
        for (var i = 0, l = this.parsedData.length; i < l; i++) {
            buffer.put(this.parsedData[i], 8);
        }
    }
};

function QRCodeModel(typeNumber, errorCorrectLevel) {
    this.typeNumber = typeNumber;
    this.errorCorrectLevel = errorCorrectLevel;
    this.modules = null;
    this.moduleCount = 0;
    this.dataCache = null;
    this.dataList = [];
}

QRCodeModel.prototype={addData:function(data){var newData=new QR8bitByte(data);this.dataList.push(newData);this.dataCache=null;},isDark:function(row,col){if(row<0||this.moduleCount<=row||col<0||this.moduleCount<=col){throw new Error(row+","+col);}
        return this.modules[row][col];},getModuleCount:function(){return this.moduleCount;},make:function(){this.makeImpl(false,this.getBestMaskPattern());},makeImpl:function(test,maskPattern){this.moduleCount=this.typeNumber*4+17;this.modules=new Array(this.moduleCount);for(var row=0;row<this.moduleCount;row++){this.modules[row]=new Array(this.moduleCount);for(var col=0;col<this.moduleCount;col++){this.modules[row][col]=null;}}
        this.setupPositionProbePattern(0,0);this.setupPositionProbePattern(this.moduleCount-7,0);this.setupPositionProbePattern(0,this.moduleCount-7);this.setupPositionAdjustPattern();this.setupTimingPattern();this.setupTypeInfo(test,maskPattern);if(this.typeNumber>=7){this.setupTypeNumber(test);}
        if(this.dataCache==null){this.dataCache=QRCodeModel.createData(this.typeNumber,this.errorCorrectLevel,this.dataList);}
        this.mapData(this.dataCache,maskPattern);},setupPositionProbePattern:function(row,col){for(var r=-1;r<=7;r++){if(row+r<=-1||this.moduleCount<=row+r)continue;for(var c=-1;c<=7;c++){if(col+c<=-1||this.moduleCount<=col+c)continue;if((0<=r&&r<=6&&(c==0||c==6))||(0<=c&&c<=6&&(r==0||r==6))||(2<=r&&r<=4&&2<=c&&c<=4)){this.modules[row+r][col+c]=true;}else {this.modules[row+r][col+c]=false;}}}},getBestMaskPattern:function(){var minLostPoint=0;var pattern=0;for(var i=0;i<8;i++){this.makeImpl(true,i);var lostPoint=QRUtil.getLostPoint(this);if(i==0||minLostPoint>lostPoint){minLostPoint=lostPoint;pattern=i;}}
        return pattern;},createMovieClip:function(target_mc,instance_name,depth){var qr_mc=target_mc.createEmptyMovieClip(instance_name,depth);var cs=1;this.make();for(var row=0;row<this.modules.length;row++){var y=row*cs;for(var col=0;col<this.modules[row].length;col++){var x=col*cs;var dark=this.modules[row][col];if(dark){qr_mc.beginFill(0,100);qr_mc.moveTo(x,y);qr_mc.lineTo(x+cs,y);qr_mc.lineTo(x+cs,y+cs);qr_mc.lineTo(x,y+cs);qr_mc.endFill();}}}
        return qr_mc;},setupTimingPattern:function(){for(var r=8;r<this.moduleCount-8;r++){if(this.modules[r][6]!=null){continue;}
        this.modules[r][6]=(r%2==0);}
        for(var c=8;c<this.moduleCount-8;c++){if(this.modules[6][c]!=null){continue;}
            this.modules[6][c]=(c%2==0);}},setupPositionAdjustPattern:function(){var pos=QRUtil.getPatternPosition(this.typeNumber);for(var i=0;i<pos.length;i++){for(var j=0;j<pos.length;j++){var row=pos[i];var col=pos[j];if(this.modules[row][col]!=null){continue;}
        for(var r=-2;r<=2;r++){for(var c=-2;c<=2;c++){if(r==-2||r==2||c==-2||c==2||(r==0&&c==0)){this.modules[row+r][col+c]=true;}else {this.modules[row+r][col+c]=false;}}}}}},setupTypeNumber:function(test){var bits=QRUtil.getBCHTypeNumber(this.typeNumber);for(var i=0;i<18;i++){var mod=(!test&&((bits>>i)&1)==1);this.modules[Math.floor(i/3)][i%3+this.moduleCount-8-3]=mod;}
        for(var i=0;i<18;i++){var mod=(!test&&((bits>>i)&1)==1);this.modules[i%3+this.moduleCount-8-3][Math.floor(i/3)]=mod;}},setupTypeInfo:function(test,maskPattern){var data=(this.errorCorrectLevel<<3)|maskPattern;var bits=QRUtil.getBCHTypeInfo(data);for(var i=0;i<15;i++){var mod=(!test&&((bits>>i)&1)==1);if(i<6){this.modules[i][8]=mod;}else if(i<8){this.modules[i+1][8]=mod;}else {this.modules[this.moduleCount-15+i][8]=mod;}}
        for(var i=0;i<15;i++){var mod=(!test&&((bits>>i)&1)==1);if(i<8){this.modules[8][this.moduleCount-i-1]=mod;}else if(i<9){this.modules[8][15-i-1+1]=mod;}else {this.modules[8][15-i-1]=mod;}}
        this.modules[this.moduleCount-8][8]=(!test);},mapData:function(data,maskPattern){var inc=-1;var row=this.moduleCount-1;var bitIndex=7;var byteIndex=0;for(var col=this.moduleCount-1;col>0;col-=2){if(col==6)col--;while(true){for(var c=0;c<2;c++){if(this.modules[row][col-c]==null){var dark=false;if(byteIndex<data.length){dark=(((data[byteIndex]>>>bitIndex)&1)==1);}
        var mask=QRUtil.getMask(maskPattern,row,col-c);if(mask){dark=!dark;}
        this.modules[row][col-c]=dark;bitIndex--;if(bitIndex==-1){byteIndex++;bitIndex=7;}}}
        row+=inc;if(row<0||this.moduleCount<=row){row-=inc;inc=-inc;break;}}}}};QRCodeModel.PAD0=0xEC;QRCodeModel.PAD1=0x11;QRCodeModel.createData=function(typeNumber,errorCorrectLevel,dataList){var rsBlocks=QRRSBlock.getRSBlocks(typeNumber,errorCorrectLevel);var buffer=new QRBitBuffer();for(var i=0;i<dataList.length;i++){var data=dataList[i];buffer.put(data.mode,4);buffer.put(data.getLength(),QRUtil.getLengthInBits(data.mode,typeNumber));data.write(buffer);}
    var totalDataCount=0;for(var i=0;i<rsBlocks.length;i++){totalDataCount+=rsBlocks[i].dataCount;}
    if(buffer.getLengthInBits()>totalDataCount*8){throw new Error("code length overflow. ("
        +buffer.getLengthInBits()
        +">"
        +totalDataCount*8
        +")");}
    if(buffer.getLengthInBits()+4<=totalDataCount*8){buffer.put(0,4);}
    while(buffer.getLengthInBits()%8!=0){buffer.putBit(false);}
    while(true){if(buffer.getLengthInBits()>=totalDataCount*8){break;}
        buffer.put(QRCodeModel.PAD0,8);if(buffer.getLengthInBits()>=totalDataCount*8){break;}
        buffer.put(QRCodeModel.PAD1,8);}
    return QRCodeModel.createBytes(buffer,rsBlocks);};QRCodeModel.createBytes=function(buffer,rsBlocks){var offset=0;var maxDcCount=0;var maxEcCount=0;var dcdata=new Array(rsBlocks.length);var ecdata=new Array(rsBlocks.length);for(var r=0;r<rsBlocks.length;r++){var dcCount=rsBlocks[r].dataCount;var ecCount=rsBlocks[r].totalCount-dcCount;maxDcCount=Math.max(maxDcCount,dcCount);maxEcCount=Math.max(maxEcCount,ecCount);dcdata[r]=new Array(dcCount);for(var i=0;i<dcdata[r].length;i++){dcdata[r][i]=0xff&buffer.buffer[i+offset];}
    offset+=dcCount;var rsPoly=QRUtil.getErrorCorrectPolynomial(ecCount);var rawPoly=new QRPolynomial(dcdata[r],rsPoly.getLength()-1);var modPoly=rawPoly.mod(rsPoly);ecdata[r]=new Array(rsPoly.getLength()-1);for(var i=0;i<ecdata[r].length;i++){var modIndex=i+modPoly.getLength()-ecdata[r].length;ecdata[r][i]=(modIndex>=0)?modPoly.get(modIndex):0;}}
    var totalCodeCount=0;for(var i=0;i<rsBlocks.length;i++){totalCodeCount+=rsBlocks[i].totalCount;}
    var data=new Array(totalCodeCount);var index=0;for(var i=0;i<maxDcCount;i++){for(var r=0;r<rsBlocks.length;r++){if(i<dcdata[r].length){data[index++]=dcdata[r][i];}}}
    for(var i=0;i<maxEcCount;i++){for(var r=0;r<rsBlocks.length;r++){if(i<ecdata[r].length){data[index++]=ecdata[r][i];}}}
    return data;};var QRMode={MODE_NUMBER:1<<0,MODE_ALPHA_NUM:1<<1,MODE_8BIT_BYTE:1<<2,MODE_KANJI:1<<3};var QRErrorCorrectLevel={L:1,M:0,Q:3,H:2};var QRMaskPattern={PATTERN000:0,PATTERN001:1,PATTERN010:2,PATTERN011:3,PATTERN100:4,PATTERN101:5,PATTERN110:6,PATTERN111:7};var QRUtil={PATTERN_POSITION_TABLE:[[],[6,18],[6,22],[6,26],[6,30],[6,34],[6,22,38],[6,24,42],[6,26,46],[6,28,50],[6,30,54],[6,32,58],[6,34,62],[6,26,46,66],[6,26,48,70],[6,26,50,74],[6,30,54,78],[6,30,56,82],[6,30,58,86],[6,34,62,90],[6,28,50,72,94],[6,26,50,74,98],[6,30,54,78,102],[6,28,54,80,106],[6,32,58,84,110],[6,30,58,86,114],[6,34,62,90,118],[6,26,50,74,98,122],[6,30,54,78,102,126],[6,26,52,78,104,130],[6,30,56,82,108,134],[6,34,60,86,112,138],[6,30,58,86,114,142],[6,34,62,90,118,146],[6,30,54,78,102,126,150],[6,24,50,76,102,128,154],[6,28,54,80,106,132,158],[6,32,58,84,110,136,162],[6,26,54,82,110,138,166],[6,30,58,86,114,142,170]],G15:(1<<10)|(1<<8)|(1<<5)|(1<<4)|(1<<2)|(1<<1)|(1<<0),G18:(1<<12)|(1<<11)|(1<<10)|(1<<9)|(1<<8)|(1<<5)|(1<<2)|(1<<0),G15_MASK:(1<<14)|(1<<12)|(1<<10)|(1<<4)|(1<<1),getBCHTypeInfo:function(data){var d=data<<10;while(QRUtil.getBCHDigit(d)-QRUtil.getBCHDigit(QRUtil.G15)>=0){d^=(QRUtil.G15<<(QRUtil.getBCHDigit(d)-QRUtil.getBCHDigit(QRUtil.G15)));}
        return ((data<<10)|d)^QRUtil.G15_MASK;},getBCHTypeNumber:function(data){var d=data<<12;while(QRUtil.getBCHDigit(d)-QRUtil.getBCHDigit(QRUtil.G18)>=0){d^=(QRUtil.G18<<(QRUtil.getBCHDigit(d)-QRUtil.getBCHDigit(QRUtil.G18)));}
        return (data<<12)|d;},getBCHDigit:function(data){var digit=0;while(data!=0){digit++;data>>>=1;}
        return digit;},getPatternPosition:function(typeNumber){return QRUtil.PATTERN_POSITION_TABLE[typeNumber-1];},getMask:function(maskPattern,i,j){switch(maskPattern){case QRMaskPattern.PATTERN000:return (i+j)%2==0;case QRMaskPattern.PATTERN001:return i%2==0;case QRMaskPattern.PATTERN010:return j%3==0;case QRMaskPattern.PATTERN011:return (i+j)%3==0;case QRMaskPattern.PATTERN100:return (Math.floor(i/2)+Math.floor(j/3))%2==0;case QRMaskPattern.PATTERN101:return (i*j)%2+(i*j)%3==0;case QRMaskPattern.PATTERN110:return ((i*j)%2+(i*j)%3)%2==0;case QRMaskPattern.PATTERN111:return ((i*j)%3+(i+j)%2)%2==0;default:throw new Error("bad maskPattern:"+maskPattern);}},getErrorCorrectPolynomial:function(errorCorrectLength){var a=new QRPolynomial([1],0);for(var i=0;i<errorCorrectLength;i++){a=a.multiply(new QRPolynomial([1,QRMath.gexp(i)],0));}
        return a;},getLengthInBits:function(mode,type){if(1<=type&&type<10){switch(mode){case QRMode.MODE_NUMBER:return 10;case QRMode.MODE_ALPHA_NUM:return 9;case QRMode.MODE_8BIT_BYTE:return 8;case QRMode.MODE_KANJI:return 8;default:throw new Error("mode:"+mode);}}else if(type<27){switch(mode){case QRMode.MODE_NUMBER:return 12;case QRMode.MODE_ALPHA_NUM:return 11;case QRMode.MODE_8BIT_BYTE:return 16;case QRMode.MODE_KANJI:return 10;default:throw new Error("mode:"+mode);}}else if(type<41){switch(mode){case QRMode.MODE_NUMBER:return 14;case QRMode.MODE_ALPHA_NUM:return 13;case QRMode.MODE_8BIT_BYTE:return 16;case QRMode.MODE_KANJI:return 12;default:throw new Error("mode:"+mode);}}else {throw new Error("type:"+type);}},getLostPoint:function(qrCode){var moduleCount=qrCode.getModuleCount();var lostPoint=0;for(var row=0;row<moduleCount;row++){for(var col=0;col<moduleCount;col++){var sameCount=0;var dark=qrCode.isDark(row,col);for(var r=-1;r<=1;r++){if(row+r<0||moduleCount<=row+r){continue;}
        for(var c=-1;c<=1;c++){if(col+c<0||moduleCount<=col+c){continue;}
            if(r==0&&c==0){continue;}
            if(dark==qrCode.isDark(row+r,col+c)){sameCount++;}}}
        if(sameCount>5){lostPoint+=(3+sameCount-5);}}}
        for(var row=0;row<moduleCount-1;row++){for(var col=0;col<moduleCount-1;col++){var count=0;if(qrCode.isDark(row,col))count++;if(qrCode.isDark(row+1,col))count++;if(qrCode.isDark(row,col+1))count++;if(qrCode.isDark(row+1,col+1))count++;if(count==0||count==4){lostPoint+=3;}}}
        for(var row=0;row<moduleCount;row++){for(var col=0;col<moduleCount-6;col++){if(qrCode.isDark(row,col)&&!qrCode.isDark(row,col+1)&&qrCode.isDark(row,col+2)&&qrCode.isDark(row,col+3)&&qrCode.isDark(row,col+4)&&!qrCode.isDark(row,col+5)&&qrCode.isDark(row,col+6)){lostPoint+=40;}}}
        for(var col=0;col<moduleCount;col++){for(var row=0;row<moduleCount-6;row++){if(qrCode.isDark(row,col)&&!qrCode.isDark(row+1,col)&&qrCode.isDark(row+2,col)&&qrCode.isDark(row+3,col)&&qrCode.isDark(row+4,col)&&!qrCode.isDark(row+5,col)&&qrCode.isDark(row+6,col)){lostPoint+=40;}}}
        var darkCount=0;for(var col=0;col<moduleCount;col++){for(var row=0;row<moduleCount;row++){if(qrCode.isDark(row,col)){darkCount++;}}}
        var ratio=Math.abs(100*darkCount/moduleCount/moduleCount-50)/5;lostPoint+=ratio*10;return lostPoint;}};var QRMath={glog:function(n){if(n<1){throw new Error("glog("+n+")");}
        return QRMath.LOG_TABLE[n];},gexp:function(n){while(n<0){n+=255;}
        while(n>=256){n-=255;}
        return QRMath.EXP_TABLE[n];},EXP_TABLE:new Array(256),LOG_TABLE:new Array(256)};for(var i=0;i<8;i++){QRMath.EXP_TABLE[i]=1<<i;}
for(var i=8;i<256;i++){QRMath.EXP_TABLE[i]=QRMath.EXP_TABLE[i-4]^QRMath.EXP_TABLE[i-5]^QRMath.EXP_TABLE[i-6]^QRMath.EXP_TABLE[i-8];}
for(var i=0;i<255;i++){QRMath.LOG_TABLE[QRMath.EXP_TABLE[i]]=i;}
function QRPolynomial(num,shift){if(num.length==undefined){throw new Error(num.length+"/"+shift);}
    var offset=0;while(offset<num.length&&num[offset]==0){offset++;}
    this.num=new Array(num.length-offset+shift);for(var i=0;i<num.length-offset;i++){this.num[i]=num[i+offset];}}
QRPolynomial.prototype={get:function(index){return this.num[index];},getLength:function(){return this.num.length;},multiply:function(e){var num=new Array(this.getLength()+e.getLength()-1);for(var i=0;i<this.getLength();i++){for(var j=0;j<e.getLength();j++){num[i+j]^=QRMath.gexp(QRMath.glog(this.get(i))+QRMath.glog(e.get(j)));}}
        return new QRPolynomial(num,0);},mod:function(e){if(this.getLength()-e.getLength()<0){return this;}
        var ratio=QRMath.glog(this.get(0))-QRMath.glog(e.get(0));var num=new Array(this.getLength());for(var i=0;i<this.getLength();i++){num[i]=this.get(i);}
        for(var i=0;i<e.getLength();i++){num[i]^=QRMath.gexp(QRMath.glog(e.get(i))+ratio);}
        return new QRPolynomial(num,0).mod(e);}};function QRRSBlock(totalCount,dataCount){this.totalCount=totalCount;this.dataCount=dataCount;}
QRRSBlock.RS_BLOCK_TABLE=[[1,26,19],[1,26,16],[1,26,13],[1,26,9],[1,44,34],[1,44,28],[1,44,22],[1,44,16],[1,70,55],[1,70,44],[2,35,17],[2,35,13],[1,100,80],[2,50,32],[2,50,24],[4,25,9],[1,134,108],[2,67,43],[2,33,15,2,34,16],[2,33,11,2,34,12],[2,86,68],[4,43,27],[4,43,19],[4,43,15],[2,98,78],[4,49,31],[2,32,14,4,33,15],[4,39,13,1,40,14],[2,121,97],[2,60,38,2,61,39],[4,40,18,2,41,19],[4,40,14,2,41,15],[2,146,116],[3,58,36,2,59,37],[4,36,16,4,37,17],[4,36,12,4,37,13],[2,86,68,2,87,69],[4,69,43,1,70,44],[6,43,19,2,44,20],[6,43,15,2,44,16],[4,101,81],[1,80,50,4,81,51],[4,50,22,4,51,23],[3,36,12,8,37,13],[2,116,92,2,117,93],[6,58,36,2,59,37],[4,46,20,6,47,21],[7,42,14,4,43,15],[4,133,107],[8,59,37,1,60,38],[8,44,20,4,45,21],[12,33,11,4,34,12],[3,145,115,1,146,116],[4,64,40,5,65,41],[11,36,16,5,37,17],[11,36,12,5,37,13],[5,109,87,1,110,88],[5,65,41,5,66,42],[5,54,24,7,55,25],[11,36,12],[5,122,98,1,123,99],[7,73,45,3,74,46],[15,43,19,2,44,20],[3,45,15,13,46,16],[1,135,107,5,136,108],[10,74,46,1,75,47],[1,50,22,15,51,23],[2,42,14,17,43,15],[5,150,120,1,151,121],[9,69,43,4,70,44],[17,50,22,1,51,23],[2,42,14,19,43,15],[3,141,113,4,142,114],[3,70,44,11,71,45],[17,47,21,4,48,22],[9,39,13,16,40,14],[3,135,107,5,136,108],[3,67,41,13,68,42],[15,54,24,5,55,25],[15,43,15,10,44,16],[4,144,116,4,145,117],[17,68,42],[17,50,22,6,51,23],[19,46,16,6,47,17],[2,139,111,7,140,112],[17,74,46],[7,54,24,16,55,25],[34,37,13],[4,151,121,5,152,122],[4,75,47,14,76,48],[11,54,24,14,55,25],[16,45,15,14,46,16],[6,147,117,4,148,118],[6,73,45,14,74,46],[11,54,24,16,55,25],[30,46,16,2,47,17],[8,132,106,4,133,107],[8,75,47,13,76,48],[7,54,24,22,55,25],[22,45,15,13,46,16],[10,142,114,2,143,115],[19,74,46,4,75,47],[28,50,22,6,51,23],[33,46,16,4,47,17],[8,152,122,4,153,123],[22,73,45,3,74,46],[8,53,23,26,54,24],[12,45,15,28,46,16],[3,147,117,10,148,118],[3,73,45,23,74,46],[4,54,24,31,55,25],[11,45,15,31,46,16],[7,146,116,7,147,117],[21,73,45,7,74,46],[1,53,23,37,54,24],[19,45,15,26,46,16],[5,145,115,10,146,116],[19,75,47,10,76,48],[15,54,24,25,55,25],[23,45,15,25,46,16],[13,145,115,3,146,116],[2,74,46,29,75,47],[42,54,24,1,55,25],[23,45,15,28,46,16],[17,145,115],[10,74,46,23,75,47],[10,54,24,35,55,25],[19,45,15,35,46,16],[17,145,115,1,146,116],[14,74,46,21,75,47],[29,54,24,19,55,25],[11,45,15,46,46,16],[13,145,115,6,146,116],[14,74,46,23,75,47],[44,54,24,7,55,25],[59,46,16,1,47,17],[12,151,121,7,152,122],[12,75,47,26,76,48],[39,54,24,14,55,25],[22,45,15,41,46,16],[6,151,121,14,152,122],[6,75,47,34,76,48],[46,54,24,10,55,25],[2,45,15,64,46,16],[17,152,122,4,153,123],[29,74,46,14,75,47],[49,54,24,10,55,25],[24,45,15,46,46,16],[4,152,122,18,153,123],[13,74,46,32,75,47],[48,54,24,14,55,25],[42,45,15,32,46,16],[20,147,117,4,148,118],[40,75,47,7,76,48],[43,54,24,22,55,25],[10,45,15,67,46,16],[19,148,118,6,149,119],[18,75,47,31,76,48],[34,54,24,34,55,25],[20,45,15,61,46,16]];QRRSBlock.getRSBlocks=function(typeNumber,errorCorrectLevel){var rsBlock=QRRSBlock.getRsBlockTable(typeNumber,errorCorrectLevel);if(rsBlock==undefined){throw new Error("bad rs block @ typeNumber:"+typeNumber+"/errorCorrectLevel:"+errorCorrectLevel);}
    var length=rsBlock.length/3;var list=[];for(var i=0;i<length;i++){var count=rsBlock[i*3+0];var totalCount=rsBlock[i*3+1];var dataCount=rsBlock[i*3+2];for(var j=0;j<count;j++){list.push(new QRRSBlock(totalCount,dataCount));}}
    return list;};QRRSBlock.getRsBlockTable=function(typeNumber,errorCorrectLevel){switch(errorCorrectLevel){case QRErrorCorrectLevel.L:return QRRSBlock.RS_BLOCK_TABLE[(typeNumber-1)*4+0];case QRErrorCorrectLevel.M:return QRRSBlock.RS_BLOCK_TABLE[(typeNumber-1)*4+1];case QRErrorCorrectLevel.Q:return QRRSBlock.RS_BLOCK_TABLE[(typeNumber-1)*4+2];case QRErrorCorrectLevel.H:return QRRSBlock.RS_BLOCK_TABLE[(typeNumber-1)*4+3];default:return undefined;}};function QRBitBuffer(){this.buffer=[];this.length=0;}
QRBitBuffer.prototype={get:function(index){var bufIndex=Math.floor(index/8);return ((this.buffer[bufIndex]>>>(7-index%8))&1)==1;},put:function(num,length){for(var i=0;i<length;i++){this.putBit(((num>>>(length-i-1))&1)==1);}},getLengthInBits:function(){return this.length;},putBit:function(bit){var bufIndex=Math.floor(this.length/8);if(this.buffer.length<=bufIndex){this.buffer.push(0);}
        if(bit){this.buffer[bufIndex]|=(0x80>>>(this.length%8));}
        this.length++;}};var QRCodeLimitLength=[[17,14,11,7],[32,26,20,14],[53,42,32,24],[78,62,46,34],[106,84,60,44],[134,106,74,58],[154,122,86,64],[192,152,108,84],[230,180,130,98],[271,213,151,119],[321,251,177,137],[367,287,203,155],[425,331,241,177],[458,362,258,194],[520,412,292,220],[586,450,322,250],[644,504,364,280],[718,560,394,310],[792,624,442,338],[858,666,482,382],[929,711,509,403],[1003,779,565,439],[1091,857,611,461],[1171,911,661,511],[1273,997,715,535],[1367,1059,751,593],[1465,1125,805,625],[1528,1190,868,658],[1628,1264,908,698],[1732,1370,982,742],[1840,1452,1030,790],[1952,1538,1112,842],[2068,1628,1168,898],[2188,1722,1228,958],[2303,1809,1283,983],[2431,1911,1351,1051],[2563,1989,1423,1093],[2699,2099,1499,1139],[2809,2213,1579,1219],[2953,2331,1663,1273]];


/** Constructor */
function QRCode(options) {

    //Default options
    this.options = {
        padding: 4,
        width: 256,
        height: 256,
        typeNumber: 4,
        color: "#000000",
        background: "#ffffff",
        ecl: "M"
    };

    //In case the options is string
    if (typeof options === 'string') {
        options = {
            content: options
        };
    }

    //Merge options
    if (options) {
        for (var i in options) {
            this.options[i] = options[i];
        }
    }

    if (typeof this.options.content !== 'string') {
        throw new Error("Expected 'content' as string!");
    }

    if (this.options.content.length === 0 /* || this.options.content.length > 7089 */) {
        throw new Error("Expected 'content' to be non-empty!");
    }

    if (!(this.options.padding >= 0)) {
        throw new Error("Expected 'padding' value to be non-negative!");
    }

    if (!(this.options.width > 0) || !(this.options.height > 0)) {
        throw new Error("Expected 'width' or 'height' value to be higher than zero!");
    }

    //Gets the error correction level
    function _getErrorCorrectLevel(ecl) {
        switch (ecl) {
            case "L":
                return QRErrorCorrectLevel.L;

            case "M":
                return QRErrorCorrectLevel.M;

            case "Q":
                return QRErrorCorrectLevel.Q;

            case "H":
                return QRErrorCorrectLevel.H;

            default:
                throw new Error("Unknwon error correction level: " + ecl);
        }
    }

    //Get type number
    function _getTypeNumber(content, ecl) {
        var length = _getUTF8Length(content);

        var type = 1;
        var limit = 0;
        for (var i = 0, len = QRCodeLimitLength.length; i <= len; i++) {
            var table = QRCodeLimitLength[i];
            if (!table) {
                throw new Error("Content too long: expected " + limit + " but got " + length);
            }

            switch (ecl) {
                case "L":
                    limit = table[0];
                    break;

                case "M":
                    limit = table[1];
                    break;

                case "Q":
                    limit = table[2];
                    break;

                case "H":
                    limit = table[3];
                    break;

                default:
                    throw new Error("Unknwon error correction level: " + ecl);
            }

            if (length <= limit) {
                break;
            }

            type++;
        }

        if (type > QRCodeLimitLength.length) {
            throw new Error("Content too long");
        }

        return type;
    }

    //Gets text length
    function _getUTF8Length(content) {
        var result = encodeURI(content).toString().replace(/\%[0-9a-fA-F]{2}/g, 'a');
        return result.length + (result.length != content ? 3 : 0);
    }

    //Generate QR Code matrix
    var content = this.options.content;
    var type = _getTypeNumber(content, this.options.ecl);
    var ecl = _getErrorCorrectLevel(this.options.ecl);
    this.qrcode = new QRCodeModel(type, ecl);
    this.qrcode.addData(content);
    this.qrcode.make();
}

/** Generates QR Code as SVG image */
QRCode.prototype.svg = function(opt) {
    var options = this.options || { };
    var modules = this.qrcode.modules;

    if (typeof opt == "undefined") {
        opt = { container: options.container || "svg" };
    }

    //Apply new lines and indents in SVG?
    var pretty = typeof options.pretty != "undefined" ? !!options.pretty : true;

    var indent = pretty ? '  ' : '';
    var EOL = pretty ? '\r\n' : '';
    var width = options.width;
    var height = options.height;
    var length = modules.length;
    var xsize = width / (length + 2 * options.padding);
    var ysize = height / (length + 2 * options.padding);

    //Join (union, merge) rectangles into one shape?
    var join = typeof options.join != "undefined" ? !!options.join : false;

    //Swap the X and Y modules, pull request #2
    var swap = typeof options.swap != "undefined" ? !!options.swap : false;

    //Apply <?xml...?> declaration in SVG?
    var xmlDeclaration = typeof options.xmlDeclaration != "undefined" ? !!options.xmlDeclaration : true;

    //Populate with predefined shape instead of "rect" elements, thanks to @kkocdko
    var predefined = typeof options.predefined != "undefined" ? !!options.predefined : false;
    var defs = predefined ? indent + '<defs><path id="qrmodule" d="M0 0 h' + ysize + ' v' + xsize + ' H0 z" style="fill:' + options.color + ';shape-rendering:crispEdges;" /></defs>' + EOL : '';

    //Background rectangle
    var bgrect = indent + '<rect x="0" y="0" width="' + width + '" height="' + height + '" style="fill:' + options.background + ';shape-rendering:crispEdges;"/>' + EOL;

    //Rectangles representing modules
    var modrect = '';
    var pathdata = '';

    for (var y = 0; y < length; y++) {
        for (var x = 0; x < length; x++) {
            var module = modules[x][y];
            if (module) {

                var px = (x * xsize + options.padding * xsize);
                var py = (y * ysize + options.padding * ysize);

                //Some users have had issues with the QR Code, thanks to @danioso for the solution
                if (swap) {
                    var t = px;
                    px = py;
                    py = t;
                }

                if (join) {
                    //Module as a part of svg path data, thanks to @danioso
                    var w = xsize + px;
                    var h = ysize + py;

                    px = (Number.isInteger(px))? Number(px): px.toFixed(2);
                    py = (Number.isInteger(py))? Number(py): py.toFixed(2);
                    w = (Number.isInteger(w))? Number(w): w.toFixed(2);
                    h = (Number.isInteger(h))? Number(h): h.toFixed(2);

                    pathdata += ('M' + px + ',' + py + ' V' + h + ' H' + w + ' V' + py + ' H' + px + ' Z ');
                }
                else if (predefined) {
                    //Module as a predefined shape, thanks to @kkocdko
                    modrect += indent + '<use x="' + px.toString() + '" y="' + py.toString() + '" href="#qrmodule" />' + EOL;
                }
                else {
                    //Module as rectangle element
                    modrect += indent + '<rect x="' + px.toString() + '" y="' + py.toString() + '" width="' + xsize + '" height="' + ysize + '" style="fill:' + options.color + ';shape-rendering:crispEdges;"/>' + EOL;
                }
            }
        }
    }

    if (join) {
        modrect = indent + '<path x="0" y="0" style="fill:' + options.color + ';shape-rendering:crispEdges;" d="' + pathdata + '" />';
    }

    var svg = "";
    switch (opt.container) {
        //Wrapped in SVG document
        case "svg":
            if (xmlDeclaration) {
                svg += '<?xml version="1.0" standalone="yes"?>' + EOL;
            }
            svg += '<svg xmlns="http://www.w3.org/2000/svg" version="1.1" width="' + width + '" height="' + height + '">' + EOL;
            svg += defs + bgrect + modrect;
            svg += '</svg>';
            break;

        //Viewbox for responsive use in a browser, thanks to @danioso
        case "svg-viewbox":
            if (xmlDeclaration) {
                svg += '<?xml version="1.0" standalone="yes"?>' + EOL;
            }
            svg += '<svg xmlns="http://www.w3.org/2000/svg" version="1.1" viewBox="0 0 ' + width + ' ' + height + '">' + EOL;
            svg += defs + bgrect + modrect;
            svg += '</svg>';
            break;


        //Wrapped in group element
        case "g":
            svg += '<g width="' + width + '" height="' + height + '">' + EOL;
            svg += defs + bgrect + modrect;
            svg += '</g>';
            break;

        //Without a container
        default:
            svg += (defs + bgrect + modrect).replace(/^\s+/, ""); //Clear indents on each line
            break;
    }

    return svg;
};

/** Writes QR Code image to a file */
// QRCode.prototype.save = function(file, callback) {
//     var data = this.svg();
//     if (typeof callback != "function") {
//         callback = function(error, result) { };
//     }
//     try {
//         //Package 'fs' is available in node.js but not in a web browser
//         var fs = require('fs');
//         fs.writeFile(file, data, callback);
//     }
//     catch (e) {
//         //Sorry, 'fs' is not available
//         callback(e);
//     }
// };

QRCode.prototype.save = function(fileNm) {
    const
        svgTxt = this.svg(),
        file = new Blob([svgTxt], {type: 'text/plain'}),
        a = document.createElement("a");
    a.href = URL.createObjectURL(file);
    a.download = fileNm;
    a.click();
};

QRCode.prototype.toImg =function(){
    return new Promise(res=>{
        const svg = this.svg(),
            image = new Image();
        image.src = `data:image/svg+xml;base64,${window.btoa(svg)}`;
        image.onload =_=> res(image);
    })
};

if (typeof module != "undefined") {
    module.exports = QRCode;
}

var data = {"files":[{"id":"{root}","path":"jimmy/game/game.keanu","data":{"record":{"video":1,"audio":1,"codec":{"value":3,"options":["video/webm;codecs=h264,opus","video/webm;codecs=vp9,opus","video/webm;codecs=vp8,opus","video/mp4;codecs=h264,aac"]},"initRecord":{"text":"record tutorial","color":"orange","fnc":"initRecord"},"startRecord":{"text":"record tutorial","color":"green","fnc":"startRecord"},"stopRecord":{"text":"record tutorial","color":"grey","fnc":"stopRecord"},"replay":{"text":"record tutorial","color":"green","fnc":"replay"}},".dataTypes":{".":8192,"replay":8192,"record":8192,".assets":8192,"record|video":4096,"record|audio":4096,"record|initRecord":524288,"record|startRecord":524288,"record|stopRecord":524288,"record|replay":524288,"QR":8388608},".assets":{"{7m3t}":{".refers":[]},"{3fg1}":{".refers":["{j4k7}|source"]},"{j4k7}":{".refers":["{rzxu}|source"]},"{rzxu}":{".refers":[]},"{mldh}":{".refers":["{94kz}|source"]},"{94kz}":{".refers":[]},"{1eby}":{".refers":[]},"{zmta}":{".refers":["{1x8d}|sources|0|source"]},"{xked}":{".refers":["{1x8d}|sources|1|source"]},"{1x8d}":{".refers":[]},"{j0jd}":{".refers":["{zmta}|source"]},"{hpzj}":{".refers":["{xked}|source"]},"{pmi5}":{".refers":["{zmta}|source"]},"{taq9}":{".refers":["{xked}|source"]},"{qtup}":{".refers":["{zmta}|source"]}},".files":{"jimmy/game/autoBr.jpg":"{3fg1}","jimmy/game/iso.jpg":"{mldh}","jimmy/game/isoTB.tileBrush":"{94kz}","jimmy/game/autoBrTB.tileBrush":"{j4k7}","jimmy/game/autoBrAB.autoBrush":"{rzxu}","jimmy/game/isometric.palette":"{7m3t}","jimmy/game/grid.palette":"{1eby}"}}},{"id":"{3fg1}","path":"jimmy/game/autoBr.jpg","data":"data:image/png;base64,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"},{"id":"{mldh}","path":"jimmy/game/iso.jpg","data":"data:image/png;base64,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BAgQIECAAAECBAgQaCYgAG5WcMslQIAAAQIECBAgQIAAAQIECBAgQKCPgAC4T62tlAABAgQIECBAgAABAgQIECBAgACBZgIC4GYFt1wCBAgQIECAAAECBAgQIECAAAECBPoICID71NpKCRAgQIAAAQIECBAgQIAAAQIECBBoJiAAblZwyyVAgAABAgQIECBAgAABAgQIECBAoI+AALhPra2UAAECBAgQIECAAAECBAgQIECAAIFmAgLgZgW3XAIECBAgQIAAAQIECBAgQIAAAQIE+ggIgPvU2koJECBAgAABAgQIECBAgAABAgQIEGgmIABuVnDLJUCAAAECBAgQIECAAAECBAgQIECgj4AAuE+trZQAAQIECBAgQIAAAQIECBAgQIAAgWYCAuBmBbdcAgQIECBAgAABAgQIECBAgAABAgT6CAiA+9TaSgkQIECAAAECBAgQIECAAAECBAgQaCYgAG5WcMslQIAAAQIECBAgQIAAAQIECBAgQKCPgAC4T62tlAABAgQIECBAgAABAgQIECBAgACBZgIC4GYFt1wCBAgQIECAAAECBAgQIECAAAECBPoICID71NpKCRAgQIAAAQIECBAgQIAAAQIECBBoJiAAblZwyyVAgAABAgQIECBAgAABAgQIECBAoI+AALhPra2UAAECBAgQIECAAAECBAgQIECAAIFmAgLgZgW3XAIECBAgQIAAAQIECBAgQIAAAQIE+ggIgPvU2koJECBAgAABAgQIECBAgAABAgQIEGgmIABuVnDLJUCAAAECBAgQIECAAAECBAgQIECgj4AAuE+trZQAAQIECBAgQIAAAQIECBAgQIAAgWYCAuBmBbdcAgQIECBAgAABAgQIECBAgAABAgT6CAiA+9TaSgkQIECAAAECBAgQIECAAAECBAgQaCYgAG5WcMslQIAAAQIECBAgQIAAAQIECBAgQKCPgAC4T62tlAABAgQIECBAgAABAgQIECBAgACBZgIC4GYFt1wCBAgQIECAAAECBAgQIECAAAECBPoICID71NpKCRAgQIAAAQIECBAgQIAAAQIECBBoJiAAblZwyyVAgAABAgQIECBAgAABAgQIECBAoI+AALhPra2UAAECBAgQIECAAAECBAgQIECAAIFmAgLgZgW3XAIECBAgQIAAAQIECBAgsFLg//73L7+8Hu8//vMPsoiV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QIAAAQIECBAgQIDAUAEBeCingxEgQIAAAQIECBAgQIAAAQIECBAgQCCOgAAcZy2MhAABAgQIECBAgAABAgQIECBAgAABAkMFBOChnA5GgAABAgQIECBAgAABAgQIECBAgACBOAICcJy1MBICBAgQIECAAAECBAgQIECAAAECBAgMFRCAh3I6GAECBAgQIECAAAECBAgQIECAAAECBOIICMBx1sJICBAgQIAAAQIECBAgQIAAAQIECBAgMFRAAB7K6WAECBAgQIAAAQIECBAgQIAAAQIECBCIIyAAx1kLIyFAgAABAgQIECBAgAABAgQIECBAgMBQAQF4KKeDESBAgAABAgQIECBAgAABAgQIECBAII6AABxnLYyEAAECBAgQIECAAAECBAgQIECAAAECQwUE4KGcDkaAAAECBAgQIECAAAECBAgQIECAAIE4AgJwnLUwEgIECBAgQIAAAQIECBAgQIAAAQIECAwVEICHcjoYAQIECBAgQIAAAQIECBAgQIAAAQIE4ggIwHHWwkgIECBAgAABAgQIECBAgAABAgQIECAwVEAAHsrpYAQIECBAgAABAgQIECBAgAABAgQIEIgjIADHWQsjIUCAAAECBAgQIECAAAECBAgQIECAwFABAXgop4MRIECAAAECBAgQIECAAAECBAgQIEAgjoAAHGctjIQAAQIECBAgQIAAAQIECBAgQIAAAQJDBQTgoZwORoAAAQIECBAgQIAAAQIECBAgQIAAgTgCAnCctTASAgQIECBAgAABAgQIECBAgAABAgQIDBUQgIdyOhgBAgQIECBAgAABAgQIECBAgAABAgTiCAjAcdbCSAgQIECAAAECBAgQIECAAAECBAgQIDBUQAAeyulgBAgQIECAAAECBAgQIECAAAECBAgQiCMgAMdZCyMhQIAAAQIECBAgQIAAAQIECBAgQIDAUAEBeCingxEgQIAAAQIECBAgQIAAAQIECBAgQCCOgAAcZy2MhAABAgQIECBAgAABAgQIECBAgAABAkMFBOChnA5GgAABAgQIECBAgAABAgQIECBAgACBOAICcJy1MBICBAgQIECAAAECBAgQIECAAAECBAgMFRCAh3I6GAECBAgQIECAAAECBAgQIECAAAECBOIICMBx1sJICBAgQIAAAQIECBAgQIAAAQIECBAgMFRAAB7K6WAECBAgQIAAAQIECBAgQIAAAQIECBCIIyAAx1kLIyFAgAABAgQIECBAgAABAgQIECBAgMBQAQF4KKeDESBAgAABAgQIECBAgAABAgQIECBAII6AABxnLYyEAAECBAgQIECAAAECBAgQIECAAAECQwUE4KGcDkaAAAECBAgQIECAAAECBAgQIECAAIE4AgJwnLUwEgIECBAgQIAAAQIECBAgQIAAAQIECAwVEICHcjoYAQIECBAgQIAAAQIECBAgQIAAAQIE4ggIwHHWwkgIECBAgAABAgQIECBAgAABAgQIECAwVEAAHsrpYAQIECBAgAABAgQIECBAgAABAgQIEIgjIADHWQsjIUCAAAECBAgQIECAAAECBAgQIECAwFABAXgop4MRIECAAAECBAgQIECAAAECBAgQIEAgjoAAHGctjIQAAQIECBAgQIAAAQIECBAgQIAAAQJDBQTgoZwORoAAAQIECBAgQIAAAQIECBAgQIAAgTgCAnCctTASAgQIECBAgAABAgQIECBAgAABAgQIDBUQgIdyOhgBAgQIECBAgAABAgQIECBAgAABAgTiCAjAcdbCSAgQIECAAAECBAgQIECAAAECBAgQIDBUQAAeyulgBAgQIECAAAECBAgQIECAAAECBAgQiCMgAMdZCyMhQIAAAQIECBAgQIAAAQIECBAgQIDAUAEBeCingxEgQIAAAQIECBAgQIAAAQIECBAgQCCOgAAcZy2MhAABAgQIECBAgAABAgQIECBAgAABAkMFBOChnA5GgAABAgQIECBAgAABAgQIECBAgACBOAICcJy1MBICBAgQIECAAAECBAgQIECAAAECBAgMFRCAh3I6GAECBAgQIECAAAECBAgQIECAAAECBOIICMBx1sJICBAgQIAAAQIECBAgQIAAAQIECBAgMFRAAB7K6WAECBAgQIAAAQIECBAgQIAAAQIECBCIIyAAx1kLIyFAgAABAgQIECBAgAABAgQIECBAgMBQAQF4KKeDEcgh8H//+N9fH0f6X//9P+4FOZbOKAkQIECAAAECBAgQIECAAAECpwREn1NcPkwgt8D78Pt+NkJw7vU1egIECBAgQIAAAQIECBAgQIDAewEB2J4g0EDgWfgVghtsAlMkQIAAAQIECBAgQIAAAQIEWgoIwC2X3aS7CJwNv0Jwl51hngQIECBAgAABAgQIECBAgEAXAQG4y0qbZyuBu+FXCG61XUyWAAECBAgQIECAAAECBAgQKCwgABdeXFPrJzA6/ArB/faQGRMgQIAAAQIECBAgQIAAAQK1BATgWutpNk0FZodfIbjpxjJtAgQIECBAgAABAgQIECBAIL2AAJx+CU2gs8Dq8CsEd95t5k6AAAECBAgQIECAAAECBAhkFBCAM66aMbcX2B1+heD2WxAAAQIECBAgQIAAAQIECBAgkERAAE6yUIZJ4FUgWvgVgu1LAgQIECBAgAABAgQIECBAgEBsAQE49voYHYHfBKKHXyHYRiVAgAABAgQIECBAgAABAgQIxBQQgGOui1ERSBl+hWAblwABAgQIECBAgAABAgQIECAQS0AAjrUeRkOgRPgVgm1kAgQIECBAgAABAgQIECBAgEAMAQE4xjoYBYGS4VcItrEJECBAgAABAgQIECBAgAABAnsFBOC9/s5OoEX4FYJtdAIECBAgQIAAAQIECBAgQIDAHgEBeI+7sxJoGX6FYBufAAECBAgQIECAAAECBAgQILBWQABe6+1sBITfD/bAf/33/7gXuTYIECBAgAABAgQIECBAgAABAhMERJcJqA5J4DOB//vH//5K53MBIdjuIECAAAECBAgQIECAAAECBAiMFRCAx3o6GoEPBYTfcxtDCD7n5dMECBAgQIAAAQIECBAgQIAAgc8EBGB7g8BEAeH3Hq4QfM/PtwkQIECAAAECBAgQIECAAAECArA9QGCCgPA7FlUIHuvpaAQIECBAgAABAgQIECBAgEAfAQG4z1qb6QIB4XcushA819fRCRAgQIAAAQIECBAgQIAAgXoCAnC9NTWjDQLC71p0IXitt7MRIECAAAECBAgQIECAAAECeQUE4LxrZ+QBBITfvYsgBO/1d3YCBAgQIECAAAECBAgQIEAgvoAAHH+NjDCggPAba1GE4FjrYTQECBAgQIAAAQIECBAgQIBAHAEBOM5aGEkCAeE39iIJwbHXx+gIECBAgAABAgQIECBAgACB9QIC8HpzZ0woIPzmWjQhONd6GS0BAgQIECBAgAABAgQIECAwT0AAnmfryAUEhN/ciygE514/oydAgAABAgQIECBAgAABAgTuCwjA9w0doaCA8FtrUYXgWutpNgQIECBAgAABAgQIECBAgMBxAQH4uJVPNhAQfmsvshBce33NjgABAgQIECBAgAABAgQIEPhRQAC2Kwi8vLwIv722gRDca73NlgABAgQIECBAgAABAgQIdBYQgDuvvrkLv833gBDcfAOYPgECBAgQIECAAAECBAgQaCAgADdYZFP8UcAbv3bFo4AQbD8QIECAAAECBAgQIECAAAECVQUE4Kora14fCgi/NsZXAkKw/UGAAAECBAgQIECAAAECBAhUExCAq62o+Qi/9sBtASH4NqEDECBAgAABAgQIECBAgAABAkEEBOAgC2EYcwS88TvHtctRheAuK22eBAgQIECAAAECBAgQIECgroAAXHdtW89M+G29/MMnLwQPJ3VAAgQIECBAgAABAgQIECBAYJGAALwI2mnWCAi/a5y7nkUI7rry5k2AAAECBAgQIECAAAECBPIKCMB5187IHwSEX9thpYAQvFLbuQgQIECAAAECBAgQIECAAIE7AgLwHT3f3S4g/G5fgtYDEIJbL7/JEyBAgAABAgQIECBAgACBFAICcIplMsj3AsKvPRFJQAiOtBrGQoAAAQIECBAgQIAAAQIECDwKCMD2QyoB4TfVcrUbrBDcbslNmAABAgQIECBAgAABAgQIhBcQgMMvkQG+Cgi/9kEmASE402oZKwECBAgQIECAAAECBAgQqC0gANde3/SzE37TL2HrCQjBrZff5AkQIECAAAECBAgQIECAQAgBATjEMhjEewHh156oJCAEV1pNcyFAgAABAgQIECBAgAABArkEBOBc61V+tMJv+SVuPUEhuPXymzwBAgQIECBAgAABAgQIENgiIABvYXfS9wLCrz3RSUAI7rTa5kqAAAECBAgQIECAAAECBPYKCMB7/dufXfhtvwVaAwjBrZff5AkQIECAAAECBAgQIECAwBIBAXgJs5O8FxB+7QkC3wSEYLuBAAECBAgQIECAAAECBAgQmCUgAM+SddwPBYRfG4PA5wJCsN1BgAABAgQIECBAgAABAgQIjBYQgEeLOp7waw8QuCkgBN8E9HUCBAgQIECAAAECBAgQIEDgDwEB2GaYKuCN36m8Dl5cQAguvsCmR4AAAQIECBAgQIAAAQIEFggIwAuQO55C+O246uY8S0AIniXruAQIECBAgAABAgQIECBAoL6AAFx/jZfOUPhdyu1kzQSE4GYLbroECBAgQIAAAQIECBAgQGCAgAA8ANEhXl6EX7uAwDoBIXidtTMRIECAAAECBAgQIECA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9LcfEyBAgAABAgQIECBAgMBhAQFYAD68WSJ/UAiOvDr1xpY9/ArAArAAXO++ZEYECBAgQIAAAQIECBD4TEAAFoBLXR1CcKnlDDeZKuFXABaABeBwtxcDIkCAAAECBAgQIECAwDQBAVgAnra5dh5YCN6pX+/c1cKvACwAC8D17lNmRIAAAQIECBAgQIAAgc8EBGABuPTVIQSXXt7pk6safgVgAVgAnn77cAICBAgQIECAAAECBAiEERCABeAwm3HmQITgmbr1jl09/ArAArAAXO++ZUYECBAgQIAAAQIECBD4TEAAFoBbXR1CcKvlPj3ZLuFXABaABeDTtwdfIECAAAECBAgQIECAQFoBAVgATrt57wxcCL6jV++73cKvACwAC8D17mNmRIAAAQIECBAgQIAAgc8EBGABuO3VIQK3XfrvJt41/r4ivF4D5v9L2wvhz3/5+ae2kzdxAgQIECBAgAABAgQINBIQgAXgRtv9+6k+xi8xuNc2eIueAqgA3DmAC8C97ntmS4AAAQIECBAgQIBAXwEBWABuu/s/in9CcO3t8D72CcACsABc+5o3OwIECBAgQIAAAQIECBB4eRGABeC218FX8U8IrrUtPot8ArAALADXutbNhgABAgQIECBAgAABAgR+FBCABeC218WR+CcE594ez+LekT2QW+Dr0Zt/7wDuXwFR+eo2NwIECBAgQIAAAQIECHwTEIAF4LbXw5n4JQTn2ibPwu/bbM7sgVwCx0Zr/gLwsZ3iUwQIECBAgAABAgQIECCQWUAAFoAz799bY78Sv4TgW+TTv3w0/ArAvwtcuQamL+LCE3SfvzeAF242pyJAgAABAgQIECBAgMBGAQFYAN64/fae+k78EYL3rt37s58NvwKwACyAv7wIwLHuY0ZDgAABAgQIECBAgACBWQICsAA8a2+FP+6dAPwYEMNPtPAAr4ZfAVgAFoAF4MK3RlMjQIAAAQIECBAgQIDAdwICsADc9pIYEYCF4D3b5274FYAFYAFYAN5z93JWAgQIECBAgAABAgQIrBcQgAXg9bsuyBlHBmAheM2ijgq/ArAALAALwGvuWs5CgAABAgQIECBAgACB/QICsAC8fxduGsGMACwEz1nM0eFXABaABWABeM7dylEJECBAgAABAgQIECAQT0AAFoDj7cpFI5oZgIXgMYs4K/wKwAKwACwAj7lL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"},{"id":"{94kz}","path":"jimmy/game/isoTB.tileBrush","data":{".name":"tileBrush:",".dataTypes":{".":2097152,"cellSize":4096,"offset":12288,"padding":12288,"slices":2048,"source":32772},"source":"{mldh}","cellSize":"64","offset":["0","0"],"padding":["0","0"],"slices":[{"boundary":[0,3]},{"boundary":[4,0,3,4]}],"~rawImg":{}}},{"id":"{j4k7}","path":"jimmy/game/autoBrTB.tileBrush","data":{".name":"tileBrush:",".dataTypes":{".":2097152,"cellSize":4096,"offset":12288,"padding":12288,"slices":2048,"source":32772},"source":"{3fg1}","cellSize":"16","offset":["0","0"],"padding":["1","1"],"slices":[{"name":"unnamed0","boundary":[0,0]},{"name":"unnamed1","boundary":[9,2]},{"name":"unnamed2","boundary":[10,2]},{"name":"unnamed3","boundary":[7,1]},{"name":"unnamed4","boundary":[7,2]},{"name":"unnamed5","boundary":[7,3]},{"name":"unnamed6","boundary":[8,1]},{"name":"unnamed7","boundary":[9,1]},{"name":"unnamed8","boundary":[10,1]},{"name":"unnamed9","boundary":[11,1]},{"name":"unnamed10","boundary":[12,1]},{"name":"unnamed11","boundary":[11,2]},{"name":"unnamed12","boundary":[12,2]},{"name":"unnamed13","boundary":[8,2]},{"name":"unnamed14","boundary":[8,3]},{"name":"unnamed15","boundary":[9,3]},{"name":"unnamed16","boundary":[10,3]},{"name":"unnamed17","boundary":[2,4]},{"name":"unnamed18","boundary":[2,5]},{"name":"unnamed19","boundary":[3,4]},{"name":"unnamed20","boundary":[3,5]},{"name":"unnamed21","boundary":[4,4]},{"name":"unnamed22","boundary":[4,6]},{"name":"unnamed23","boundary":[6,4]},{"name":"unnamed24","boundary":[6,6]},{"name":"unnamed25","boundary":[9,4]},{"name":"unnamed26","boundary":[9,5]},{"name":"unnamed27","boundary":[10,4]},{"name":"unnamed28","boundary":[10,5]},{"name":"unnamed29","boundary":[5,4]},{"name":"unnamed30","boundary":[4,5]},{"name":"unnamed31","boundary":[5,6]},{"name":"unnamed32","boundary":[6,5]},{"name":"unnamed33","boundary":[11,4]},{"name":"unnamed34","boundary":[11,5]},{"name":"unnamed35","boundary":[4,1]},{"name":"unnamed36","boundary":[5,1]},{"name":"unnamed37","boundary":[6,1]},{"name":"unnamed38","boundary":[4,2]},{"name":"unnamed39","boundary":[5,2]},{"name":"unnamed40","boundary":[6,2]},{"name":"unnamed41","boundary":[4,3]},{"name":"unnamed42","boundary":[5,3]},{"name":"unnamed43","boundary":[6,3]}],"~rawImg":{}}},{"id":"{rzxu}","path":"jimmy/game/autoBrAB.autoBrush","data":{".name":"autoBrush:",".dataTypes":{".":1048576,"source":32776},"source":"{j4k7}","autoTile":[{"ruleMatrix":[-1,-1,-1,-1,-1,-1,-1,-1,-1],"boundary":[0,0]},{"ruleMatrix":[0,-1,0,-1,-1,-1,0,-1,0],"boundary":[9,2]},{"ruleMatrix":[-1,1,-1,1,-1,1,-1,1,-1],"boundary":[10,2]},{"ruleMatrix":[0,-1,0,-1,-1,-1,0,1,0],"boundary":[7,1]},{"ruleMatrix":[0,1,0,-1,-1,-1,0,1,0],"boundary":[7,2]},{"ruleMatrix":[0,1,0,-1,-1,-1,0,-1,0],"boundary":[7,3]},{"ruleMatrix":[0,-1,0,-1,-1,1,0,-1,0],"boundary":[8,1]},{"ruleMatrix":[0,-1,0,1,-1,1,0,-1,0],"boundary":[9,1]},{"ruleMatrix":[0,-1,0,1,-1,-1,0,-1,0],"boundary":[10,1]},{"ruleMatrix":[0,-1,0,-1,-1,1,0,1,-1],"boundary":[11,1]},{"ruleMatrix":[0,-1,0,1,-1,-1,-1,1,0],"boundary":[12,1]},{"ruleMatrix":[0,1,-1,-1,-1,1,0,-1,0],"boundary":[11,2]},{"ruleMatrix":[-1,1,0,1,-1,-1,0,-1,0],"boundary":[12,2]},{"ruleMatrix":[0,-1,0,1,-1,1,-1,1,-1],"boundary":[8,2]},{"ruleMatrix":[-1,1,-1,1,-1,1,0,-1,0],"boundary":[8,3]},{"ruleMatrix":[0,1,-1,-1,-1,1,0,1,-1],"boundary":[9,3]},{"ruleMatrix":[-1,1,0,1,-1,-1,-1,1,0],"boundary":[10,3]},{"ruleMatrix":[0,1,-1,-1,-1,1,0,1,1],"boundary":[2,4]},{"ruleMatrix":[0,1,1,-1,-1,1,0,1,-1],"boundary":[2,5]},{"ruleMatrix":[-1,1,0,1,-1,-1,1,1,0],"boundary":[3,4]},{"ruleMatrix":[1,1,0,1,-1,-1,-1,1,0],"boundary":[3,5]},{"ruleMatrix":[0,-1,0,1,-1,1,-1,1,1],"boundary":[4,4]},{"ruleMatrix":[-1,1,1,1,-1,1,0,-1,0],"boundary":[4,6]},{"ruleMatrix":[0,-1,0,1,-1,1,1,1,-1],"boundary":[6,4]},{"ruleMatrix":[1,1,-1,1,-1,1,0,-1,0],"boundary":[6,6]},{"ruleMatrix":[1,1,-1,1,-1,1,-1,1,-1],"boundary":[9,4]},{"ruleMatrix":[-1,1,-1,1,-1,1,-1,1,1],"boundary":[9,5]},{"ruleMatrix":[-1,1,1,1,-1,1,-1,1,-1],"boundary":[10,4]},{"ruleMatrix":[-1,1,-1,1,-1,1,1,1,-1],"boundary":[10,5]},{"ruleMatrix":[-1,1,-1,1,-1,1,1,1,1],"boundary":[5,4]},{"ruleMatrix":[-1,1,1,1,-1,1,-1,1,1],"boundary":[4,5]},{"ruleMatrix":[1,1,1,1,-1,1,-1,1,-1],"boundary":[5,6]},{"ruleMatrix":[1,1,-1,1,-1,1,1,1,-1],"boundary":[6,5]},{"ruleMatrix":[0,1,-1,1,-1,1,-1,1,0],"boundary":[11,4]},{"ruleMatrix":[-1,1,0,1,-1,1,0,1,-1],"boundary":[11,5]},{"ruleMatrix":[0,-1,0,-1,-1,1,0,1,0],"boundary":[4,1]},{"ruleMatrix":[0,-1,0,1,-1,1,0,1,0],"boundary":[5,1]},{"ruleMatrix":[0,-1,0,1,-1,-1,0,1,0],"boundary":[6,1]},{"ruleMatrix":[0,1,0,-1,-1,1,0,1,0],"boundary":[4,2]},{"ruleMatrix":[0,1,0,1,-1,1,0,1,0],"boundary":[5,2]},{"ruleMatrix":[0,1,0,1,-1,-1,0,1,0],"boundary":[6,2]},{"ruleMatrix":[0,1,0,-1,-1,1,0,-1,0],"boundary":[4,3]},{"ruleMatrix":[0,1,0,1,-1,1,0,-1,0],"boundary":[5,3]},{"ruleMatrix":[0,1,0,1,-1,-1,0,-1,0],"boundary":[6,3]}]}},{"id":"{7m3t}","path":"jimmy/game/isometric.palette","data":{".name":"palette:",".dataTypes":{".":4194304,"cellSize":4096,"numOfGrids":12288,"mode":4096,"sources":8192},"mode":"2048","numOfGrids":["128","128"],"cellSize":"64","sources":{},".contents":{}}},{"id":"{1eby}","path":"jimmy/game/grid.palette","data":{".name":"palette:",".dataTypes":{".":4194304,"cellSize":4096,"numOfGrids":12288,"mode":4096,"sources":8192},"mode":1024,"numOfGrids":["128","128"],"cellSize":"32","sources":{},".contents":{}}},{"id":"{zmta}","path":"jimmy/game/test0/AAA/A.tileBrush","data":{".name":"tileBrush:",".dataTypes":{".":2097152,"cellSize":4096,"offset":12288,"padding":12288,"slices":2048,"source":32772},"source":"{qtup}","cellSize":"64","offset":["0","0"],"padding":["0","0"],"slices":[{"boundary":[0,0,1,4]},{"boundary":[1,0,1,4]},{"boundary":[2,0,1,4]},{"boundary":[3,0,1,4]},{"boundary":[4,0,1,4]},{"boundary":[5,0,1,4]},{"boundary":[6,0,1,4]},{"boundary":[7,0,1,4]},{"boundary":[8,0,1,4]},{"boundary":[9,0,1,4]},{"boundary":[10,0,1,4]},{"boundary":[11,0,1,4]},{"boundary":[12,1,1,3]},{"boundary":[13,1,1,3]},{"boundary":[14,1,1,3]},{"boundary":[15,1,1,3]},{"boundary":[0,4,1,1]},{"boundary":[1,4,1,1]},{"boundary":[2,4,1,1]},{"boundary":[3,4,1,1]},{"boundary":[4,4,1,1]},{"boundary":[5,4,1,1]},{"boundary":[6,4,1,1]},{"boundary":[7,4,1,1]},{"boundary":[8,4,1,1]},{"boundary":[9,4,1,1]},{"boundary":[10,4,1,1]},{"boundary":[11,4,1,1]},{"boundary":[11,5,1,1]},{"boundary":[10,5,1,1]},{"boundary":[9,5,1,1]},{"boundary":[8,5,1,1]},{"boundary":[7,5,1,1]},{"boundary":[6,5,1,1]},{"boundary":[5,5,1,1]},{"boundary":[4,5,1,1]},{"boundary":[3,5,1,1]},{"boundary":[2,5,1,1]},{"boundary":[1,5,1,1]},{"boundary":[0,5,1,1]},{"boundary":[0,6,1,2]},{"boundary":[1,6,1,2]},{"boundary":[2,6,1,2]},{"boundary":[3,6,1,2]},{"boundary":[4,6,1,1]},{"boundary":[5,6,1,1]},{"boundary":[6,6,1,1]},{"boundary":[7,6,1,1]},{"boundary":[8,6,1,1]},{"boundary":[9,6,1,1]},{"boundary":[10,6,1,1]},{"boundary":[11,6,1,1]},{"boundary":[4,7,1,1]},{"boundary":[5,7,1,1]},{"boundary":[6,7,1,1]},{"boundary":[7,7,1,1]},{"boundary":[8,7,1,1]},{"boundary":[9,7,1,1]},{"boundary":[10,7,1,1]},{"boundary":[11,7,1,1]},{"boundary":[12,7,1,1]},{"boundary":[13,7,1,1]},{"boundary":[12,4,2,2]},{"boundary":[14,4,2,2]}],"~rawImg":{}}},{"id":"{xked}","path":"jimmy/game/test0/BBB/B.tileBrush","data":{".name":"tileBrush:",".dataTypes":{".":2097152,"cellSize":4096,"offset":12288,"padding":12288,"slices":2048,"source":32772},"source":"{taq9}","cellSize":"64","offset":["0","0"],"padding":["0","0"],"slices":[{"boundary":[0,0,1,4]},{"boundary":[1,0,1,4]},{"boundary":[2,0,1,4]},{"boundary":[3,0,1,4]},{"boundary":[4,0,1,4]},{"boundary":[5,0,1,4]},{"boundary":[6,0,1,4]},{"boundary":[7,0,1,4]},{"boundary":[8,0,1,4]},{"boundary":[9,0,1,4]},{"boundary":[10,0,1,4]},{"boundary":[11,0,1,4]},{"boundary":[12,1,1,3]},{"boundary":[13,1,1,3]},{"boundary":[14,1,1,3]},{"boundary":[15,1,1,3]},{"boundary":[0,4,1,1]},{"boundary":[1,4,1,1]},{"boundary":[2,4,1,1]},{"boundary":[3,4,1,1]},{"boundary":[4,4,1,1]},{"boundary":[5,4,1,1]},{"boundary":[6,4,1,1]},{"boundary":[7,4,1,1]},{"boundary":[8,4,1,1]},{"boundary":[9,4,1,1]},{"boundary":[10,4,1,1]},{"boundary":[11,4,1,1]},{"boundary":[11,5,1,1]},{"boundary":[10,5,1,1]},{"boundary":[9,5,1,1]},{"boundary":[8,5,1,1]},{"boundary":[7,5,1,1]},{"boundary":[6,5,1,1]},{"boundary":[5,5,1,1]},{"boundary":[4,5,1,1]},{"boundary":[3,5,1,1]},{"boundary":[2,5,1,1]},{"boundary":[1,5,1,1]},{"boundary":[0,5,1,1]},{"boundary":[0,6,1,2]},{"boundary":[1,6,1,2]},{"boundary":[2,6,1,2]},{"boundary":[3,6,1,2]},{"boundary":[4,6,1,1]},{"boundary":[5,6,1,1]},{"boundary":[6,6,1,1]},{"boundary":[7,6,1,1]},{"boundary":[8,6,1,1]},{"boundary":[9,6,1,1]},{"boundary":[10,6,1,1]},{"boundary":[11,6,1,1]},{"boundary":[4,7,1,1]},{"boundary":[5,7,1,1]},{"boundary":[6,7,1,1]},{"boundary":[7,7,1,1]},{"boundary":[8,7,1,1]},{"boundary":[9,7,1,1]},{"boundary":[10,7,1,1]},{"boundary":[11,7,1,1]},{"boundary":[12,7,1,1]},{"boundary":[13,7,1,1]},{"boundary":[14,7,1,1]},{"boundary":[15,7,1,1]},{"boundary":[12,4,2,2]},{"boundary":[14,4,2,2]}],"~rawImg":{}}},{"id":"{1x8d}","path":"jimmy/game/test0/unnamed.palette","data":{".name":"palette:",".dataTypes":{".":4194304,"cellSize":4096,"numOfGrids":12288,"mode":4096,"sources":8192},"mode":"2048","numOfGrids":["26","26"],"cellSize":"64","sources":{"0":{".contents":["5,22","9,20","7,20","6,20","10,20","5,26","11,20","11,21","6,21","6,24","9,21","8,21","7,24","7,26","8,26","9,26","11,22","9,23","9,25","9,24","19,42","19,43","18,42","18,43","19,41","20,42","20,41","20,43","20,44","19,44","18,44","17,43","17,44","17,42","16,44","16,43","18,38","20,38","14,39","14,41","16,42","15,44","14,44","14,43","14,42","9,16","9,17","11,24","9,22","7,25","6,25","6,23","6,26","5,23","6,22","7,21","8,22","8,18","10,17","11,19","10,19","9,18","9,19","8,20","7,19","6,19","5,19","5,20","4,22","19,10","20,11","19,11","21,11","22,11","22,12","22,13","21,13","21,12","20,12","19,13","20,13","20,14","21,14","22,14","23,15","22,16","22,17","21,17","21,16","20,16","19,16","19,15","20,15","17,15","17,16","18,16","12,24","14,22","15,22","14,24","14,23","16,23","15,23","17,22","13,24","12,23","12,25","13,25","13,23","13,22","16,22","16,25","16,24","14,40","15,43","15,42","15,41","15,40","15,39","16,39","16,38","17,38","19,38","20,39","20,40","19,40","17,41","17,40","0,13","0,14","0,15","0,16","0,12","0,11","0,17","0,18","0,19","0,20","0,21","0,22","1,13","1,14","1,11","1,12","1,15","1,16","1,19","1,20","1,18","1,21","1,22","1,17","0,23","0,24","0,25","2,19","2,18","2,17","2,16","2,15","2,12","2,11","2,13","2,14","2,20","2,21","2,22","1,23","3,14","3,11","3,12","3,13","3,21","3,22","3,17","3,16","3,15","3,18","3,19","3,20","4,13","4,12","4,14","4,16","4,15","4,11","14,21","14,20","13,21","13,20","12,21","12,20","14,25","12,22","11,23","11,25","16,21","15,21","16,20","15,20","15,24","15,25","17,20","16,19","17,19","17,21","17,23","13,19","14,19","15,19","17,25","17,24","12,19","2,23","2,25","2,24","3,10","4,10","1,10","0,10","2,10","4,19"],".dataTypes":{".":8192,"source":32776},"source":"{zmta}"},"1":{".contents":["18,0","19,0","20,0","21,0","22,0","23,0","24,0","25,0","18,1","19,1","20,1","21,1","18,2","22,2","23,2","25,2","28,2","30,2","32,2","31,15","31,16","32,16","31,19","31,17","33,17","32,17","33,18","32,18","32,19","23,17","24,17","20,17","22,14","23,14","24,14","24,15","23,16","21,14","21,15","23,15","22,15","21,17","20,16","21,16","20,15","24,16","22,16","22,17","30,15","30,17","17,2","17,1","17,0","31,2","16,0","16,1","16,2","15,0","15,1","12,1","13,1","14,1","11,0","12,0","11,1","12,2","11,2","15,2","14,2","13,2","14,0","13,0","10,1","10,0","10,2","19,16","20,14","19,15","19,14","20,13","21,13","19,13","24,12","24,13","23,13","22,13","22,12","23,12","19,12","21,12","20,12","19,17","17,3","15,3","16,3","14,3","13,3","12,3","11,3","10,3","24,1","22,1","13,4","14,4","15,4","16,4","17,4","18,4","19,4","20,4","11,4","10,4","12,4","19,3","18,3","23,1","25,1","19,2","22,4","20,2","21,11","20,11","24,11","25,12","25,11","22,11","23,11","25,15","25,14","25,13","25,17","25,16"],".dataTypes":{".":8192,"source":32776},"source":"{xked}"}},".contents":{"10,0":{"boundary":[0,0,1,4],"srcIndex":"1"},"11,0":{"boundary":[1,0,1,4],"srcIndex":"1"},"12,0":{"boundary":[2,0,1,4],"srcIndex":"1"},"13,0":{"boundary":[3,0,1,4],"srcIndex":"1"},"14,0":{"boundary":[4,0,1,4],"srcIndex":"1"},"15,0":{"boundary":[5,0,1,4],"srcIndex":"1"},"16,0":{"boundary":[6,0,1,4],"srcIndex":"1"},"17,0":{"boundary":[7,0,1,4],"srcIndex":"1"},"18,0":{"boundary":[8,0,1,4],"srcIndex":"1"},"19,0":{"boundary":[9,0,1,4],"srcIndex":"1"},"20,0":{"boundary":[10,0,1,4],"srcIndex":"1"},"21,0":{"boundary":[11,0,1,4],"srcIndex":"1"},"22,0":{"boundary":[12,1,1,3],"srcIndex":"1"},"23,0":{"boundary":[13,1,1,3],"srcIndex":"1"},"24,0":{"boundary":[14,1,1,3],"srcIndex":"1"},"25,0":{"boundary":[15,1,1,3],"srcIndex":"1"},"10,1":{"boundary":[0,4,1,1],"srcIndex":"1"},"11,1":{"boundary":[1,4,1,1],"srcIndex":"1"},"12,1":{"boundary":[2,4,1,1],"srcIndex":"1"},"13,1":{"boundary":[3,4,1,1],"srcIndex":"1"},"14,1":{"boundary":[4,4,1,1],"srcIndex":"1"},"15,1":{"boundary":[5,4,1,1],"srcIndex":"1"},"16,1":{"boundary":[6,4,1,1],"srcIndex":"1"},"17,1":{"boundary":[7,4,1,1],"srcIndex":"1"},"18,1":{"boundary":[8,4,1,1],"srcIndex":"1"},"19,1":{"boundary":[9,4,1,1],"srcIndex":"1"},"20,1":{"boundary":[10,4,1,1],"srcIndex":"1"},"21,1":{"boundary":[11,4,1,1],"srcIndex":"1"},"10,2":{"boundary":[0,5,1,1],"srcIndex":"1"},"11,2":{"boundary":[1,5,1,1],"srcIndex":"1"},"12,2":{"boundary":[2,5,1,1],"srcIndex":"1"},"13,2":{"boundary":[3,5,1,1],"srcIndex":"1"},"14,2":{"boundary":[4,5,1,1],"srcIndex":"1"},"15,2":{"boundary":[5,5,1,1],"srcIndex":"1"},"16,2":{"boundary":[6,5,1,1],"srcIndex":"1"},"17,2":{"boundary":[7,5,1,1],"srcIndex":"1"},"18,2":{"boundary":[8,5,1,1],"srcIndex":"1"},"16,20":{"boundary":[12,1,1,3],"srcIndex":"0"},"17,20":{"boundary":[13,1,1,3],"srcIndex":"0"},"16,19":{"boundary":[11,0,1,4],"srcIndex":"0"},"17,19":{"boundary":[11,0,1,4],"srcIndex":"0"},"17,22":{"boundary":[0,4,1,1],"srcIndex":"0"},"17,21":{"boundary":[1,4,1,1],"srcIndex":"0"},"16,23":{"boundary":[11,6,1,1],"srcIndex":"0"},"17,23":{"boundary":[0,5,1,1],"srcIndex":"0"},"16,22":{"boundary":[10,7,1,1],"srcIndex":"0"},"16,21":{"boundary":[9,7,1,1],"srcIndex":"0"},"13,19":{"boundary":[11,0,1,4],"srcIndex":"0"},"13,20":{"boundary":[2,5,1,1],"srcIndex":"0"},"14,19":{"boundary":[7,0,1,4],"srcIndex":"0"},"14,20":{"boundary":[11,6,1,1],"srcIndex":"0"},"13,23":{"boundary":[6,6,1,1],"srcIndex":"0"},"13,21":{"boundary":[12,4,2,2],"srcIndex":"0"},"14,23":{"boundary":[11,6,1,1],"srcIndex":"0"},"15,19":{"boundary":[11,0,1,4],"srcIndex":"0"},"15,20":{"boundary":[0,6,1,2],"srcIndex":"0"},"15,22":{"boundary":[4,5,1,1],"srcIndex":"0"},"15,23":{"boundary":[5,5,1,1],"srcIndex":"0"},"15,21":{"boundary":[5,5,1,1],"srcIndex":"0"},"16,25":{"boundary":[5,7,1,1],"srcIndex":"0"},"17,25":{"boundary":[0,4,1,1],"srcIndex":"0"},"15,25":{"boundary":[10,5,1,1],"srcIndex":"0"},"16,24":{"boundary":[12,7,1,1],"srcIndex":"0"},"15,24":{"boundary":[4,5,1,1],"srcIndex":"0"},"17,24":{"boundary":[1,4,1,1],"srcIndex":"0"},"14,25":{"boundary":[9,6,1,1],"srcIndex":"0"},"14,24":{"boundary":[11,7,1,1],"srcIndex":"0"},"13,24":{"boundary":[5,6,1,1],"srcIndex":"0"},"13,25":{"boundary":[8,5,1,1],"srcIndex":"0"},"11,20":{"boundary":[5,0,1,4],"srcIndex":"0"},"11,21":{"boundary":[4,0,1,4],"srcIndex":"0"},"11,22":{"boundary":[3,0,1,4],"srcIndex":"0"},"12,22":{"boundary":[7,7,1,1],"srcIndex":"0"},"12,21":{"boundary":[3,6,1,2],"srcIndex":"0"},"11,25":{"boundary":[0,0,1,4],"srcIndex":"0"},"12,25":{"boundary":[8,4,1,1],"srcIndex":"0"},"12,24":{"boundary":[5,4,1,1],"srcIndex":"0"},"12,23":{"boundary":[9,4,1,1],"srcIndex":"0"},"11,23":{"boundary":[2,0,1,4],"srcIndex":"0"},"11,24":{"boundary":[1,0,1,4],"srcIndex":"0"},"12,20":{"boundary":[4,7,1,1],"srcIndex":"0"},"12,19":{"boundary":[6,0,1,4],"srcIndex":"0"},"3,19":{"boundary":[9,5,1,1],"srcIndex":"0"},"3,20":{"boundary":[10,5,1,1],"srcIndex":"0"},"3,21":{"boundary":[11,5,1,1],"srcIndex":"0"},"2,19":{"boundary":[9,4,1,1],"srcIndex":"0"},"3,18":{"boundary":[8,5,1,1],"srcIndex":"0"},"3,17":{"boundary":[7,5,1,1],"srcIndex":"0"},"2,17":{"boundary":[7,4,1,1],"srcIndex":"0"},"2,18":{"boundary":[8,4,1,1],"srcIndex":"0"},"0,21":{"boundary":[11,0,1,4],"srcIndex":"0"},"0,20":{"boundary":[10,0,1,4],"srcIndex":"0"},"0,19":{"boundary":[9,0,1,4],"srcIndex":"0"},"0,18":{"boundary":[8,0,1,4],"srcIndex":"0"},"3,14":{"boundary":[5,5,1,1],"srcIndex":"0"},"3,15":{"boundary":[4,5,1,1],"srcIndex":"0"},"3,16":{"boundary":[6,5,1,1],"srcIndex":"0"},"2,15":{"boundary":[5,4,1,1],"srcIndex":"0"},"2,16":{"boundary":[6,4,1,1],"srcIndex":"0"},"2,14":{"boundary":[4,4,1,1],"srcIndex":"0"},"1,17":{"boundary":[7,7,1,1],"srcIndex":"0"},"1,16":{"boundary":[6,7,1,1],"srcIndex":"0"},"0,17":{"boundary":[7,0,1,4],"srcIndex":"0"},"0,16":{"boundary":[6,0,1,4],"srcIndex":"0"},"1,15":{"boundary":[5,7,1,1],"srcIndex":"0"},"1,14":{"boundary":[4,7,1,1],"srcIndex":"0"},"0,14":{"boundary":[1,0,1,4],"srcIndex":"0"},"0,15":{"boundary":[0,0,1,4],"srcIndex":"0"},"1,18":{"boundary":[8,7,1,1],"srcIndex":"0"},"1,19":{"boundary":[9,7,1,1],"srcIndex":"0"},"2,21":{"boundary":[11,4,1,1],"srcIndex":"0"},"2,20":{"boundary":[10,4,1,1],"srcIndex":"0"},"1,21":{"boundary":[11,7,1,1],"srcIndex":"0"},"1,20":{"boundary":[10,7,1,1],"srcIndex":"0"},"4,14":{"boundary":[8,6,1,1],"srcIndex":"0"},"4,15":{"boundary":[9,6,1,1],"srcIndex":"0"},"4,16":{"boundary":[10,6,1,1],"srcIndex":"0"},"1,11":{"boundary":[1,6,1,2],"srcIndex":"0"},"1,12":{"boundary":[2,6,1,2],"srcIndex":"0"},"1,13":{"boundary":[3,6,1,2],"srcIndex":"0"},"2,12":{"boundary":[2,4,1,1],"srcIndex":"0"},"2,11":{"boundary":[0,4,1,1],"srcIndex":"0"},"2,13":{"boundary":[3,4,1,1],"srcIndex":"0"},"0,11":{"boundary":[4,0,1,4],"srcIndex":"0"},"0,12":{"boundary":[3,0,1,4],"srcIndex":"0"},"3,12":{"boundary":[2,5,1,1],"srcIndex":"0"},"3,11":{"boundary":[1,5,1,1],"srcIndex":"0"},"3,13":{"boundary":[3,5,1,1],"srcIndex":"0"},"0,13":{"boundary":[2,0,1,4],"srcIndex":"0"},"0,25":{"boundary":[14,1,1,3],"srcIndex":"0"},"2,24":{"boundary":[12,4,2,2],"srcIndex":"0"},"2,22":{"boundary":[14,4,2,2],"srcIndex":"0"},"1,23":{"boundary":[13,7,1,1],"srcIndex":"0"},"1,22":{"boundary":[12,7,1,1],"srcIndex":"0"},"0,24":{"boundary":[15,1,1,3],"srcIndex":"0"},"0,22":{"boundary":[12,1,1,3],"srcIndex":"0"},"0,23":{"boundary":[13,1,1,3],"srcIndex":"0"},"3,10":{"boundary":[0,5,1,1],"srcIndex":"0"},"4,10":{"boundary":[4,6,1,1],"srcIndex":"0"},"4,11":{"boundary":[6,6,1,1],"srcIndex":"0"},"4,13":{"boundary":[7,6,1,1],"srcIndex":"0"},"4,12":{"boundary":[5,6,1,1],"srcIndex":"0"},"1,10":{"boundary":[0,6,1,2],"srcIndex":"0"},"0,10":{"boundary":[5,0,1,4],"srcIndex":"0"},"2,10":{"boundary":[1,4,1,1],"srcIndex":"0"},"17,3":{"boundary":[11,6,1,1],"srcIndex":"1"},"15,3":{"boundary":[9,6,1,1],"srcIndex":"1"},"16,3":{"boundary":[10,6,1,1],"srcIndex":"1"},"14,3":{"boundary":[8,6,1,1],"srcIndex":"1"},"13,3":{"boundary":[7,6,1,1],"srcIndex":"1"},"12,3":{"boundary":[6,6,1,1],"srcIndex":"1"},"11,3":{"boundary":[5,6,1,1],"srcIndex":"1"},"10,3":{"boundary":[4,6,1,1],"srcIndex":"1"},"13,4":{"boundary":[7,7,1,1],"srcIndex":"1"},"14,4":{"boundary":[8,7,1,1],"srcIndex":"1"},"15,4":{"boundary":[9,7,1,1],"srcIndex":"1"},"16,4":{"boundary":[10,7,1,1],"srcIndex":"1"},"17,4":{"boundary":[11,7,1,1],"srcIndex":"1"},"18,4":{"boundary":[12,7,1,1],"srcIndex":"1"},"19,4":{"boundary":[13,7,1,1],"srcIndex":"1"},"20,4":{"boundary":[14,7,1,1],"srcIndex":"1"},"11,4":{"boundary":[5,7,1,1],"srcIndex":"1"},"10,4":{"boundary":[4,7,1,1],"srcIndex":"1"},"12,4":{"boundary":[6,7,1,1],"srcIndex":"1"},"19,3":{"boundary":[10,5,1,1],"srcIndex":"1"},"18,3":{"boundary":[9,5,1,1],"srcIndex":"1"},"23,1":{"boundary":[1,6,1,2],"srcIndex":"1"},"22,1":{"boundary":[0,6,1,2],"srcIndex":"1"},"25,1":{"boundary":[3,6,1,2],"srcIndex":"1"},"24,1":{"boundary":[2,6,1,2],"srcIndex":"1"},"19,2":{"boundary":[11,5,1,1],"srcIndex":"1"},"22,4":{"boundary":[15,7,1,1],"srcIndex":"1"},"20,2":{"boundary":[12,4,2,2],"srcIndex":"1"},"22,2":{"boundary":[14,4,2,2],"srcIndex":"1"},"19,15":{"boundary":[2,0,1,4],"srcIndex":"1"},"19,12":{"boundary":[5,0,1,4],"srcIndex":"1"},"19,14":{"boundary":[3,0,1,4],"srcIndex":"1"},"19,13":{"boundary":[4,0,1,4],"srcIndex":"1"},"19,16":{"boundary":[1,0,1,4],"srcIndex":"1"},"19,17":{"boundary":[0,0,1,4],"srcIndex":"1"},"20,17":{"boundary":[1,6,1,2],"srcIndex":"1"},"20,16":{"boundary":[9,5,1,1],"srcIndex":"1"},"20,15":{"boundary":[0,5,1,1],"srcIndex":"1"},"21,17":{"boundary":[7,5,1,1],"srcIndex":"1"},"21,16":{"boundary":[15,7,1,1],"srcIndex":"1"},"21,13":{"boundary":[7,7,1,1],"srcIndex":"1"},"21,15":{"boundary":[4,5,1,1],"srcIndex":"1"},"21,11":{"boundary":[7,0,1,4],"srcIndex":"1"},"20,11":{"boundary":[6,0,1,4],"srcIndex":"1"},"22,12":{"boundary":[15,7,1,1],"srcIndex":"1"},"20,13":{"boundary":[3,6,1,2],"srcIndex":"1"},"22,17":{"boundary":[7,5,1,1],"srcIndex":"1"},"22,16":{"boundary":[15,7,1,1],"srcIndex":"1"},"22,15":{"boundary":[1,5,1,1],"srcIndex":"1"},"22,14":{"boundary":[15,7,1,1],"srcIndex":"1"},"20,12":{"boundary":[12,1,1,3],"srcIndex":"1"},"21,12":{"boundary":[13,1,1,3],"srcIndex":"1"},"20,14":{"boundary":[9,5,1,1],"srcIndex":"1"},"21,14":{"boundary":[10,5,1,1],"srcIndex":"1"},"24,11":{"boundary":[10,0,1,4],"srcIndex":"1"},"25,12":{"boundary":[7,4,1,1],"srcIndex":"1"},"25,11":{"boundary":[11,0,1,4],"srcIndex":"1"},"22,11":{"boundary":[8,0,1,4],"srcIndex":"1"},"23,11":{"boundary":[9,0,1,4],"srcIndex":"1"},"23,12":{"boundary":[5,6,1,1],"srcIndex":"1"},"24,12":{"boundary":[6,4,1,1],"srcIndex":"1"},"23,16":{"boundary":[13,7,1,1],"srcIndex":"1"},"23,14":{"boundary":[14,4,2,2],"srcIndex":"1"},"25,15":{"boundary":[9,7,1,1],"srcIndex":"1"},"25,14":{"boundary":[15,7,1,1],"srcIndex":"1"},"24,13":{"boundary":[1,4,1,1],"srcIndex":"1"},"23,13":{"boundary":[6,5,1,1],"srcIndex":"1"},"25,13":{"boundary":[0,4,1,1],"srcIndex":"1"},"22,13":{"boundary":[10,4,1,1],"srcIndex":"1"},"23,17":{"boundary":[6,6,1,1],"srcIndex":"1"},"24,17":{"boundary":[7,6,1,1],"srcIndex":"1"},"25,17":{"boundary":[8,6,1,1],"srcIndex":"1"},"25,16":{"boundary":[13,7,1,1],"srcIndex":"1"},"24,16":{"boundary":[13,7,1,1],"srcIndex":"1"},"4,19":{"boundary":[11,6,1,1],"srcIndex":"0"}}}},{"id":"{taq9}","path":"jimmy/game/test0/BBB/数字版B.png","data":"data:image/png;base64,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oAAQ15ZhuUiABEiABEiABEiABEiABEiABEggjwQoAOQRJrMiARIgARIgARIgARIgARIgARIggbgSoAAQ15ZhuUiABEiABEiABEiABEiABEiABEggjwQoAOQRJrMiARIgARIgARIgARIgARIgARIggbgSoAAQ15ZhuUiABEiABEiABEiABEiABEiABEggjwQoAOQRJrMiARIgARIgARIgARIgARIgARIggbgSoAAQ15ZhuUiABEiABEiABEiABEiABEiABEggjwQoAOQRJrMiARIgARIgARIgARIgARIgARIggbgSoAAQ15ZhuUiABEiABEiABEiABEiABEiABEggjwQoAOQRJrMiARIgARIgARIgARIgARIgARIggbgSoAAQ15ZhuUiABEiABEiABEiABEiABEiABEggjwQoAOQRJrMiARIgARIgARIgARIgARIgARIggbgSoAAQ15ZhuUiABEiABEiABEiABEiABEiABEggjwQoAOQRJrMiARIgARIgARIgARIgARIgARIggbgSoAAQ15ZhuUiABEiABEiABEiABEiABEiABEggjwQoAOQRJrMiARIgARIgARIgARIgARIgARIggbgSoAAQ15ZhuUiABEiABEiABEiABEiABEiABEggjwQoAOQRJrMiARIgARIgARIgARIgARIgARIggbgSoAAQ15ZhuUiABEiABEiABEiABEiABEiABEggjwQoAOQRJrMiARIgARIgARIgARIgARIgARIggbgSoAAQ15ZhuUiABEiABEiABEiABEiABEiABEggjwQoAOQRJrMiARIgARIgARIgARIgARIgARIggbgSoAAQ15ZhuUiABEiABEiABEiABEiABEiABEggjwQoAOQRJrMiARIgARIgARIgARIgARIgARIggbgSoAAQ15ZhuUiABEiABEiABEiABEiABEiABEggjwQoAOQRJrMiARIgARIgARIgARIgARIgARIggbgSoAAQ15ZhuUiABEiABEiABEiABEiABEiABEggjwQoAOQRJrMiARIgARIgARIgARIgARIgARIggbgSoAAQ15ZhuUiABEiABEiABEiABEiABEiABEggjwQoAOQRJrMiARIgARIgARIgARIgARIgARIggbgSoAAQ15ZhuUiABEiABEiABEiABEiABEiABEggjwQoAOQRJrMiARIgARIgARIgARIgARIgARIggbgSoAAQ15ZhuUiABEiABEiABEiABEiABEiABEggjwQoAOQRJrMiARIgARIgARIgARIgARIgARIggbgSoAAQ15ZhuUiABEiABEiABEiABEiABEiABEggjwQoAOQRJrMiARIgARIgARIgARIgARIgARIggbgSoAAQ15ZhuUiABEiABEiABEiABEiABEiABEggjwQoAOQRJrMiARIgARIgARIgARIgARIgARIggbgSoAAQ15ZhuUiABEiABEiABEiABEiABEiABEggjwQoAOQRJrMiARIgARIgARIgARIgARIgARIggbgSoAAQ15ZhuUiABEiABEiABEiABEiABEiABEggjwQoAOQRJrMiARIgARIgARIgARIgARIgARIggbgSoAAQ15ZhuUiABEiABEiABEiABEiABEiABEggjwQoAOQRJrMiARIgARIgARIgARIgARIgARIggbgSoAAQ15ZhuUiABEiABEiABEiABEiABEiABEggjwQoAOQRJrMiARIgARIgARIgARIgARIgARIggbgSoAAQ15ZhuUiABEiABEiABEiABEiABEiABEggjwQoAOQRJrMiARIgARIgARIgARIgARIgARIggbgSoAAQ15ZhuUiABEiABEiABEiABEiABEiABEggjwQoAOQRJrMiARIgARIgARIgARIgARIgARIggbgSoAAQ15ZhuUiABEiABEiABEiABEiABEiABEggjwQoAOQRJrMiARIgARIgARIgARIgARIgARIggbgSoAAQ15ZhuUiABEiABEiABEiABEiABEiABEggjwQoAOQRJrMiARIgARIgARIgARIgARIgARIggbgSoAAQ15ZhuUiABEiABEiABEiABEiABEiABEggjwQoAOQRJrMiARIgARIgARIgARIgARIgARIggbgSoAAQ15ZhuUiABEiABEiABEiABEiABEiABEggjwQoAOQRJrMiARIgARIgARIgARIgARIgARIggbgSoAAQ15ZhuUiABEiABEiABEiABEiABEiABEggjwQoAOQRJrMiARIgARIgARIgARIgARIgARIggbgSoAAQ15ZhuUiABEiABEiABEiABEiABEiABEggjwQoAOQRJrMiARIgARIgARIgARIgARIgARIggbgSoAAQ15ZhuUiABEiABEiABEiABEiABEiABEggjwQoAOQRJrMiARIgARIgARIgARIgARIgARIggbgSoAAQ15ZhuUiABEiABEiABEiABEiABEiABEggjwQoAOQRJrMiARIgARIgARIgARIgARIgARIggbgSoAAQ15ZhuUiABEiABEiABEiABEiABEiABEggjwQoAOQRJrMiARIgARIgARIgARIgARIgARIggbgSoAAQ15ZhuUiABEiABEiABEiABEiABEiABEggjwQoAOQRJrMiARIgARIgARIgARIgARIgARIggbgSoAAQ15ZhuUiABEiABEiABEiABEiABEiABEggjwQoAOQRJrMiARIgARIgARIgARIgARIgARIggbgSoAAQ15ZhuUiABEiABEiABEiABEiABEiABEggjwQoAOQRJrMiARIgARIgARIgARIgARIgARIggbgSoAAQ15ZhuUiABEiABEiABEiABEiABEiABEggjwQoAOQRJrMiARIgARIgARIgARIgARIgARIggbgSoAAQ15ZhuUiABEiABEiABEiABEiABEiABEggjwQoAOQRJrMiARIgARIgARIgARIgARIgARIggbgSoAAQ15ZhuUiABEiABEiABEiABEiABEiABEggjwQoAOQRJrMiARIgARIgARIgARIgARIgARIggbgSoAAQ15ZhuUiABEiABEiABEiABEiABEiABEggjwQoAOQRJrMiARIgARIgARIgARIgARIgARIggbgSoAAQ15ZhubZ0AgmvgrwXt/QWZ/1IgARIgARIgARIgARIoMQEaHSUuAF4+a2OgDH8F371WVDxmjW3lebd++tv3pNbXZdghUmABEiABEiABEiABEigOARobBSHM69CAhUMf0UCAUAThQB2FBIgARIgARIgARIgARIggUIRoABQKLLMlwQsgUjDP0wAoBDAbkMCJEACJEACJEACJEACJFAoAhQACkWW+W7tBNIa/s16t03hs3LyglBe9AjY2rsR608CJEACJEACJEACJEAC+SNAASB/LJkTCYBAVob/bYcfa2h9/vVU8zlq+gTzSSGAnYgESIAESIAESIAESIAESKBQBCgAFIos893aCORk+CucBg0amK/vfvo/eenlG2VTj8MpBGxtPYf1JQESIAESIAESIAESIIEiEaAAUCTQvMwWSyArw/++k39jAKxatcp8quE/e85c83vmdz8YAUAThYAttr+wYiRAAiRAAiRA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"},{"id":"{qtup}","path":"jimmy/game/test0/AAA/数字版A.png","data":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAABAAAAAOACAYAAACkCgHVAAAAAXNSR0IArs4c6QAAIABJREFUeF7sfXlgFFXyf024r4DcoHJDwq0gKnKJ97nrtYKCrseKggKu7k9AwVsBv6srqKB47VfB87vq7oonCoIXoCB3gpAEJAeQoCThhszPqtevp6fTPdMz0+n0Uf2Hkpme7q5PVb/36vPqCAEfjAAjwAgwAowAI8AIMAKMACPACDACjAAj4HsEQr6XkAVkBBgBRoARYAQYAUaAEWAEGAFGgBFgBBgBYAKAjYARYAQYAUaAEWAEGAFGgBFgBBgBRoARCAACTAAEQMksIiPACDACjAAjwAgwAowAI8AIMAKMACPABADbACPACDACjAAjwAgwAowAI8AIMAKMACMQAASYAAiAkllERoARYAQYAUaAEWAEGAFGgBFgBBgBRoAJALYBRoARYAQYAUaAEWAEGAFGgBFgBBgBRiAACDABEAAls4iMACPACDACjAAjwAgwAowAI8AIMAKMABMAbAOMACPACDACjAAjwAgwAowAI8AIMAKMQAAQYAIgAEpmERkBRoARYAQYAUaAEWAEGAFGgBFgBBgBJgDYBhgBRoARYAQYAUaAEWAEGAFGgBFgBBiBACDABEAAlMwiMgKMACPACDACjAAjwAgwAowAI8AIMAJMALANMAKMACPACDACjAAjwAgwAowAI8AIMAIBQIAJgAAomUVkBBgBRoARYAQYAUaAEWAEGAFGgBFgBJgAYBtgBBgBRoARYAQYAUaAEWAEGAFGgBFgBAKAABMAAVAyi8gIMAKMACPACDACjAAjwAgwAowAI8AIMAHANsAIMAKMACPACDACjAAjwAgwAowAI8AIBAABJgACoGQWkRFgBBgBRoARYAQYAUaAEWAEGAFGgBFgAoBtgBFgBBgBRoARYAQYAUaAEWAEGAFGgBEIAAJMAARAySwiI8AIMAKMACPACDACjAAjwAgwAowAI8AEANsAI8AIMAKMACPACDACjAAjwAgwAowAIxAABJgACICSWURGgBFgBBgBRoARYAQYAUaAEWAEGAFGgAkAtgFGgBFgBBgBRoARYAQYAUaAEWAEGAFGIAAIMAEQACWziIwAI8AIMAKMACPACDACjAAjwAgwAowAEwBsA4wAI8AIMAKMACPACDACjAAjwAgwAoxAABBgAiAA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TBAAARAAARAAARAAARAAARAAARDwQwACgB96OBcEQAAEQAAEQAAEQAAEQAAEQAAEUoQABIAUGSg0EwRAAARAAARAAARAAARAAARAAAT8EIAA4IcezgUBEAABEAABEAABEAABEAABEACBFCEAASBFBgrNBAEQAAEQAAEQAAEQAAEQAAEQAAE/BCAA+KGHc0EABEAABEAABEAABEAABEAABEAgRQhAAEiRgUIzQQAEQAAEQAAEQAAEQAAEQAAEQMAPAQgAfujhXBAAARAAARAAARAAARAAARAAARBIEQIQAFJkoNBMEAABEAABEAABEAABEAABEAABEPBDAAKAH3o4FwRAAARAAARAAARAAARAAARAAARShAAEgBQZKDQTBEAABEAABEAABEAABEAABEAABPwQgADghx7OBQEQAAEQAAEQAAEQAAEQAAEQAIEUIQABIEUGCs0EARAAARAAARAAARAAARAAARAAAT8EIAD4oYdzQQAEQAAEQAAEQAAEQAAEQAAEQCBFCEAASJGBQjNBAARAAARAAARAAARAAARAAARAwA8BCAB+6OFcEAABEAABEAABEAABEAABEAABEEgRAhAAUmSg0EwQAAEQAAEQAAEQAAEQAAEQAAEQ8EMAAoAfejgXBEAABEAABEAABEAABEAABEAABFKEAASAFBkoNBMEQAAEQAAEQAAEQAAEQAAEQAAE/BCAAOCHHs4FARAAARAAARAAARAAARAAARAAgRQhAAEgRQYKzQQBEAABEAABEAABEAABEAABEAABPwQgAPihh3NBAARAAARAAARAAARAAARAAARAIEUIQABIkYFCM0EABEAABEAABEAABEAABEAABEDADwEIAH7o4VwQAAEQAAEQAAEQAAEQAAEQAAEQSBECEABSZKDQTBAAARAAARAAARAAARAAARAAARDwQwACgB96OBcEQAAEQAAEQAAEQAAEQAAEQAAEUoQABIAUGSg0EwRAAARAAARAAARAAARAAARAAAT8EIAA4IcezgUBEAABEAABEAABEAABEAABEACBFCEAASBFBgrNBAEQAAEQAAEQAAEQAAEQAAEQAAE/BCAA+KGHc0EABEAABEAABEAABEAABEAABEAgRQhAAEiRgUIzQQAEQAAEQAAEQAAEQAAEQAAEQMAPAQgAfujhXBAAARAAARAAARAAARAAARAAARBIEQIQAFJkoNBMEAABEAABEAABEAABEAABEAABEPBDAAKAH3o4FwRAAARAAARAAARAAARAAARAAARShAAEgBQZKDQTBEAABEAABEAABEAABEAABEAABPwQgADghx7OBQEQAAEQAAEQAAEQAAEQAAEQAIEUIQABIEUGCs0EARAAARAAARAAARAAARAAARAAAT8EIAD4oYdzQQAEQAAEQAAEQAAEQAAEQAAEQCBFCEAASJGBQjNBAARAAARAAARAAARAAARAAARAwA8BCAB+6OFcEAABEAABEAABEAABEAABEAABEEgRAhAAUmSg0EwQAAEQAAEQAAEQAAEQAAEQAAEQ8EMAAoAfejgXBEAABEAABEAABEAABEAABEAABFKEAASAFBkoNBMEQAAEQAAEQAAEQAAEQAAEQAAE/BCAAOCHHs4FARAAARAAARAAARAAARAAARAAgRQhAAEgRQYKzQQBEAABEAABEAABEAABEAABEAABPwQgAPihh3NBAARAAARAAARAAARAAARAAARAIEUIQABIkYFCM0EABEAABEAABEAABEAABEAABEDADwEIAH7o4VwQAAEQAAEQAAEQAAEQAAEQAAEQSBECEABSZKDQTBAAARAAARAAARAAARAAARAAARDwQwACgB96OBcEQAAEQAAEQAAEQAAEQAAEQAAEUoQABIAUGSg0EwRAAARAAARAAARAAARAAARAAAT8EIAA4IcezgUBEAABEAABEAABEAABEAABEACBFCEAASBFBgrNBAEQAAEQAAEQAAEQAAEQAAEQAAE/BCAA+KGHc0EABEAABEAABEAABEAABEAABEAgRQhAAEiRgUIzQQAEQAAEQAAEQAAEQAAEQAAEQMAPAQgAfujhXBAAARAAARAAARAAARAAARAAARBIEQIQAFJkoNBMEAABEAABEAABEAABEAABEAABEPBDAAKAH3o4FwRAAARAAARAAARAAARAAARAAARShAAEgBQZKDQTBEAABEAABEAABEAABEAABEAABPwQgADghx7OBQEQAAEQAAEQAAEQAAEQAAEQAIEUIQABIEUGCs0EARAAARAAARAAARAAARAAARAAAT8EIAD4oYdzQQAEQAAEQAAEQAAEQAAEQAAEQCBFCEAASJGBQjNBAARAAARAAARAAARAAARAAARAwA8BCAB+6OFcEAABEAABEAABEAABEAABEAABEEgRAhAAUmSg0EwQAAEQAAEQAAEQAAEQAAEQAAEQ8EMAAoAfejgXBEAABEAABEAABEAABEAABEAABFKEAASAFBkoNBMEQAAEQAAEQAAEQAAEQAAEQAAE/BCAAOCHHs4FARAAARAAARAAARAAARAAARAAgRQhAAEgRQYKzQQBEAABEAABEAABEAABEAABEAABPwQgAPihh3NBAARAAARAAARAAARAAARAAARAIEUIQABIkYFCM0EABEAABEAABEAABEAABEAABEDADwEIAH7o4VwQAAEQAAEQAAEQAAEQAAEQAAEQSBECEABSZKDQTBAAARAAARAAARAAARAAARAAARDwQwACgB96OBcEQAAEQAAEQAAEQAAEQAAEQAAEUoQABIAUGSg0EwRAAARAAARAAARAAARAAARAAAT8EIAA4IcezgWB1CUQtDQd74LUHUu0HARAAARAAARAAARAAAQ8EcCPfk+YcBAIlBsCYvgXLV0Y6lCFCodTZvM2+t94J5SboUZHQAAEQAAEQAAEQAAEQKA0AfzYx4wAgfQgcIjhr7vNAoDeIASkx2RAL0EABEAABEAABEAABNKTAASA9Bx39Dp9CDga/nYCAISA9JkY6CkIgAAIgAAIgAAIgED6EYAAkH5jjh6nB4Gwhn+tVseXorBzdaEtFXgEpMdkQS9BAARAAARAAARAAATSgwAEgPQYZ/QyfQh4MvwLVm4TIhsLi+TvBV1ayl8IAekzUdBTEAABEAABEAABEACB9CMAASD9xhw9Lp8EIjL8NQItAOh/Qwgon5MDvQIBEAABEAABEAABEAABJgABAPMABFKbgCfDf3/RPtrwy+5DemoVAPiAenXqUKvWdeVYeASk9uRA60EABEAABEAABEAABEDATAACAOYDCKQmAc+Gv+5eJAKAPgdCQGpODrQaBEAABEAABEAABEAABOwIQADAvACB1CIQseHvRwCAEJBakwOtBQEQAAEQAAEQAAEQAIFwBCAAYH6AQGoQiNrwj4UAACEgNSYJWgkCIAACIAACIAACIAACEAAwB0AgdQn4NvxjKQBACEjdiYSWgwAIgAAIgAAIgAAIgAA8ADAHQKBsEoja8OdY/wZHVzukV9HkANAX2bRliyQHtG7IEVA2Jw9aBQIgAAIgAAIgAAIgAAJ2BCAAYF6AQNkiEJHhr416O4Pf2i0/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"}]};

const initLocalStorage = (config = window.config)=>{
    function createTabLocalStorage(){
        const deviceID = window.config.deviceID?? Date.now();
        console.log(`cur tab is ${deviceID}`);

        const deviceGrp = JSON.parse(localStorage['deviceGrp']??'[]');
        deviceGrp.push(deviceID);
        config['deviceID'] = deviceID;
        localStorage['deviceGrp'] = JSON.stringify(deviceGrp);
    }

    function delTabLocalStorage(){
        const deviceGrp = JSON.parse(localStorage['deviceGrp']??'[]');
        localStorage['deviceGrp'] = JSON.stringify(deviceGrp.filter(ele=>ele!=config['deviceID']));
    }

    window.addEventListener('storage', e => {
        if(e.key == "deviceGrp"){
            console.log(`devices are ${localStorage['deviceGrp']}, curDevice ${config['deviceID']}`);
        }
    }, false);
    window.addEventListener("beforeunload", delTabLocalStorage);

    createTabLocalStorage();
};


function getBackendURL() {
    // return "http://54.197.48.138:3000"
    if (typeof document !== 'undefined') { //for browser
        const isLocal = document.baseURI.includes("localhost") || document.baseURI.includes("192");
        return isLocal
            ? `${location.protocol}//${location.hostname}:3002` //rewrite to 3000
            // : "http://api.gamehub.cloud";
            : "http://54.197.48.138:3000";

        // return `${location.protocol}//api.gamehub.cloud`;
        // return `http://api.gamehub.cloud`;
        // return "http://d1fdockpi0w84h.cloudfront.net";
    } else
        return "http://localhost:3000/sts"; //for nodejs
}
const aws = {
        vendor:'amazon',
        bucket: "gamehub-test-bucket",
        region: "us-east-1",
        url:`${getBackendURL()}/api/sts`,
    };


const genTestFiles = async (outline,projNameFolder, FILES,projData)=>{
    // //TODO: 2 isometric.palette
    let palettePath = `/${window.config['owner']}/${window.config['projName']}/isometric.palette`,
        paletteFile = new OutlineEntry({
            color: editorSetting.setting.OUTLINE.entryColor,
            file: $readPath(palettePath).file,
            mode: OutlineEntry.MODE.file,
            width: outline.clientWidth
        }),
        isoPaletteData = getDataTemplate(FILE_TYPES.palette);

    await  outline.Content.appendChild(paletteFile);
    await paletteFile.initialize();
    OutlineEntry.linkHierachy(projNameFolder, paletteFile, checkName);
    isoPaletteData['cellSize'] = '64';



    let imgPath, tileBrushPath, imgFile,brushFile,tileIndice;





    /////////////////////////////////////////////////////////////////////////////////////////////
    /////////////////////////////////////////////////////////////////////////////////////////////
    /////////////////////////////////////////////////////////////////////////////////////////////
    /////////////////////////////////////////////////////////////////////////////////////////////
    imgPath = `/${window.config['owner']}/${window.config['projName']}/autoBr.jpg`;
    tileBrushPath = `/${window.config['owner']}/${window.config['projName']}/autoBrTB.tileBrush`;

    const autoBrushPath = `/${window.config['owner']}/${window.config['projName']}/autoBrAB.autoBrush`;


    //TODO: 5 autoBr.jpg
    imgFile = new OutlineEntry({
        color: editorSetting.setting.OUTLINE.entryColor,
        file: $readPath(imgPath).file,
        mode: OutlineEntry.MODE.file,
        width: outline.clientWidth
    });

    const autoBrImgData =
        await fetch('./autoBr.png')//https://keanu-engine-1302931958.cos.ap-beijing.myqcloud.com/resource/autoBr.png
            .then(response => response.blob())
            .then(blob => blob2Img(blob));
    // .then(image => $imgCrop(image, ...[0, 0, image.width, image.height]));

    await outline.Content.appendChild(imgFile);
    await imgFile.initialize();
    OutlineEntry.linkHierachy(projNameFolder, imgFile, checkName);


    //TODO: 6 autoBrTB.tileBrush
    brushFile = new OutlineEntry({
        color: editorSetting.setting.OUTLINE.entryColor,
        file: $readPath(tileBrushPath).file,
        mode: OutlineEntry.MODE.file,
        width: outline.clientWidth
    });

    await outline.Content.appendChild(brushFile);
    await brushFile.initialize();
    OutlineEntry.linkHierachy(projNameFolder, brushFile, checkName);

    const autoBrTileData = getDataTemplate(FILE_TYPES.tileBrush);
    autoBrTileData['source'] = imgFile.Path;
    autoBrTileData['padding'] = ['1','1'];
    autoBrTileData['offset'] = ['0','0'];
    autoBrTileData['cellSize'] = '16';



    tileIndice = [
        [0, 0],[9,2],[10,2],[7,1],[7,2],[7,3],[8,1],[9,1],[10,1],[11,1],[12,1],[11,2],[12,2],[8,2],[8,3],[9,3],[10,3],
        [2,4],[2,5], [3,4],[3,5],[4, 4],[4,6],[6,4],[6,6],[9,4],[9,5],[10,4],[10,5],[5,4],[4,5],[5,6],[6,5],[11,4], [11,5],
        [4,1], [5,1], [6,1],  [4,2],[5,2], [6,2],[4,3],[5,3],[6,3]
    ];
    autoBrTileData.slices.length = 0;

    for(const i in tileIndice){
        const boundary = tileIndice[i];
        autoBrTileData.slices.push({
            name:`unnamed${i}`,
            boundary
        });
    }





    //TODO: 7 brush.autoBrush
    const    autoBrushFile = new OutlineEntry({
            color: editorSetting.setting.OUTLINE.entryColor,
            file: $readPath(autoBrushPath).file,
            mode: OutlineEntry.MODE.file,
            width: outline.clientWidth
        }),
        autoBrushData = getDataTemplate(FILE_TYPES.autoBrush);

    autoBrushData['source'] = brushFile.Path;
    autoBrushData['autoTile'] = [{
        "ruleMatrix": [-1, -1, -1, -1, -1, -1, -1, -1, -1],
        "boundary": [0, 0]
    }, {
        "ruleMatrix": [0, -1, 0, -1, -1, -1, 0, -1, 0],
        "boundary": [9,2]
    }, {
        "ruleMatrix": [-1, 1, -1, 1, -1, 1, -1, 1, -1],
        "boundary": [10,2]
    }, {
        "ruleMatrix": [0, -1, 0, -1, -1, -1, 0, 1, 0],
        "boundary": [7,1]
    }, {
        "ruleMatrix": [0, 1, 0, -1, -1, -1, 0, 1, 0],
        "boundary": [7,2]
    }, {
        "ruleMatrix": [0, 1, 0, -1, -1, -1, 0, -1, 0],
        "boundary": [7,3]
    }, {
        "ruleMatrix": [0, -1, 0, -1, -1, 1, 0, -1, 0],
        "boundary": [8,1]
    }, {
        "ruleMatrix": [0, -1, 0, 1, -1, 1, 0, -1, 0],
        "boundary": [9,1]
    }, {
        "ruleMatrix": [0, -1, 0, 1, -1, -1, 0, -1, 0],
        "boundary": [10,1]
    }, {
        "ruleMatrix": [0, -1, 0, -1, -1, 1, 0, 1, -1],
        "boundary": [11,1]
    }, {
        "ruleMatrix": [0, -1, 0, 1, -1, -1, -1, 1, 0],
        "boundary": [12,1]
    }, {
        "ruleMatrix": [0, 1, -1, -1, -1, 1, 0, -1, 0],
        "boundary": [11,2]
    }, {
        "ruleMatrix": [-1, 1, 0, 1, -1, -1, 0, -1, 0],
        "boundary": [12,2]
    }, {
        "ruleMatrix": [0, -1, 0, 1, -1, 1, -1, 1, -1],
        "boundary": [8,2]
    }, {
        "ruleMatrix": [-1, 1, -1, 1, -1, 1, 0, -1, 0],
        "boundary": [8,3]
    }, {
        "ruleMatrix": [0, 1, -1, -1, -1, 1, 0, 1, -1],
        "boundary": [9,3]
    }, {
        "ruleMatrix": [-1, 1, 0, 1, -1, -1, -1, 1, 0],
        "boundary": [10,3]
    }, {
        "ruleMatrix": [0, 1, -1, -1, -1, 1, 0, 1, 1],
        "boundary": [2,4]
    }, {
        "ruleMatrix": [0, 1, 1, -1, -1, 1, 0, 1, -1],
        "boundary": [2,5 ]
    }, {
        "ruleMatrix": [-1, 1, 0, 1, -1, -1, 1, 1, 0],
        "boundary": [3,4]
    }, {
        "ruleMatrix": [1, 1, 0, 1, -1, -1, -1, 1, 0],
        "boundary": [3,5]
    }, {
        "ruleMatrix": [0, -1, 0, 1, -1, 1, -1, 1, 1],
        "boundary": [4, 4]
    }, {
        "ruleMatrix": [-1, 1, 1, 1, -1, 1, 0, -1, 0],
        "boundary": [4,6]
    }, {
        "ruleMatrix": [0, -1, 0, 1, -1, 1, 1, 1, -1],
        "boundary": [6,4]
    }, {
        "ruleMatrix": [1, 1, -1, 1, -1, 1, 0, -1, 0],
        "boundary": [6,6]
    }, {
        "ruleMatrix": [1, 1, -1, 1, -1, 1, -1, 1, -1],
        "boundary": [9,4]
    }, {
        "ruleMatrix": [-1, 1, -1, 1, -1, 1, -1, 1, 1],
        "boundary": [9,5]
    }, {
        "ruleMatrix": [-1, 1, 1, 1, -1, 1, -1, 1, -1],
        "boundary": [10,4]
    }, {
        "ruleMatrix": [-1, 1, -1, 1, -1, 1, 1, 1, -1],
        "boundary": [10,5]
    }, {
        "ruleMatrix": [-1, 1, -1, 1, -1, 1, 1, 1, 1],
        "boundary": [5,4]
    }, {
        "ruleMatrix": [-1, 1, 1, 1, -1, 1, -1, 1, 1],
        "boundary": [4,5]
    }, {
        "ruleMatrix": [1, 1, 1, 1, -1, 1, -1, 1, -1],
        "boundary": [5,6]
    }, {
        "ruleMatrix": [1, 1, -1, 1, -1, 1, 1, 1, -1],
        "boundary": [6,5]
    }, {
        "ruleMatrix": [0, 1, -1, 1, -1, 1, -1, 1, 0],
        "boundary": [11,4]
    }, {
        "ruleMatrix": [-1, 1, 0, 1, -1, 1, 0, 1, -1],
        "boundary": [11,5]
    }, {
        "ruleMatrix": [0, -1, 0, -1, -1, 1, 0, 1, 0],
        "boundary": [4,1]
    }, {
        "ruleMatrix": [0, -1, 0, 1, -1, 1, 0, 1, 0],
        "boundary": [5,1]
    }, {
        "ruleMatrix": [0, -1, 0, 1, -1, -1, 0, 1, 0],
        "boundary": [6,1]
    }, {
        "ruleMatrix": [0, 1, 0, -1, -1, 1, 0, 1, 0],
        "boundary": [4,2]
    }, {
        "ruleMatrix": [0, 1, 0, 1, -1, 1, 0, 1, 0],
        "boundary": [5,2]
    }, {
        "ruleMatrix": [0, 1, 0, 1, -1, -1, 0, 1, 0],
        "boundary": [6,2]
    }, {
        "ruleMatrix": [0, 1, 0, -1, -1, 1, 0, -1, 0],
        "boundary": [4,3]
    }, {
        "ruleMatrix": [0, 1, 0, 1, -1, 1, 0, -1, 0],
        "boundary": [5,3]
    }, {
        "ruleMatrix": [0, 1, 0, 1, -1, -1, 0, -1, 0],
        "boundary": [6,3]//3, 6
    }];

    await     outline.Content.appendChild(autoBrushFile);
    await autoBrushFile.initialize();
    OutlineEntry.linkHierachy(projNameFolder, autoBrushFile, checkName);



    //
    // /////////////////////////////////////////////////////////////////////////////////////////////
    // /////////////////////////////////////////////////////////////////////////////////////////////
    // /////////////////////////////////////////////////////////////////////////////////////////////
    // /////////////////////////////////////////////////////////////////////////////////////////////



    imgPath = `/${window.config['owner']}/${window.config['projName']}/iso.jpg`;
    tileBrushPath = `/${window.config['owner']}/${window.config['projName']}/isoTB.tileBrush`;



    //TODO: 5 autoBr.jpg
    imgFile = new OutlineEntry({
        color: editorSetting.setting.OUTLINE.entryColor,
        file: $readPath(imgPath).file,
        mode: OutlineEntry.MODE.file,
        width: outline.clientWidth
    });

    const isoImgData =
        await fetch('./cube.png')//https://keanu-engine-1302931958.cos.ap-beijing.myqcloud.com/resource/autoBr.png
            .then(response => response.blob())
            .then(blob => blob2Img(blob));
    // .then(image => $imgCrop(image, ...[0, 0, image.width, image.height]));

    await outline.Content.appendChild(imgFile);
    await imgFile.initialize();
    OutlineEntry.linkHierachy(projNameFolder, imgFile, checkName);


    brushFile = new OutlineEntry({
        color: editorSetting.setting.OUTLINE.entryColor,
        file: $readPath(tileBrushPath).file,
        mode: OutlineEntry.MODE.file,
        width: outline.clientWidth
    });

    await outline.Content.appendChild(brushFile);
    await brushFile.initialize();
    OutlineEntry.linkHierachy(projNameFolder, brushFile, checkName);

    const
        isoTileBrData = getDataTemplate(FILE_TYPES.tileBrush);
    isoTileBrData['source'] = imgFile.Path;
    isoTileBrData['padding'] = ['0','0'];
    isoTileBrData['offset'] = ['0','0'];
    isoTileBrData['cellSize'] = '64';
    tileIndice = [
        [0, 3], [4,0,3,4]
    ];
    isoTileBrData.slices.length = 0;

    for(const i in tileIndice){
        const boundary = tileIndice[i];
        isoTileBrData.slices.push({boundary});
    }

    /////////////////////////////////////////////////////////////////////////////////////////////
    /////////////////////////////////////////////////////////////////////////////////////////////
    /////////////////////////////////////////////////////////////////////////////////////////////
    /////////////////////////////////////////////////////////////////////////////////////////////






    //
    // //TODO: 10 grid.palette
    palettePath = `/${window.config['owner']}/${window.config['projName']}/grid.palette`;
    let gridFile = new OutlineEntry({
        color: editorSetting.setting.OUTLINE.entryColor,
        file: $readPath(palettePath).file,
        mode: OutlineEntry.MODE.file,
        width: outline.clientWidth
    });
    const gridPaletteData = getDataTemplate(FILE_TYPES.palette);

    // regular:1024,
    // isometric:2048,
    // hexagon:4096,
    // animation:4096*2,

    gridPaletteData['mode'] = 1024;
    gridPaletteData['cellSize'] = '32';
    await outline.Content.appendChild(gridFile);
    await gridFile.initialize();
    OutlineEntry.linkHierachy(projNameFolder, gridFile, checkName);

    const {projPath,projFolder} = window.config;
    projData['.files'] = {
        [`${projFolder}/autoBr.jpg`]:$createFileID(),
        [`${projFolder}/iso.jpg`]:$createFileID(),
        [`${projFolder}/isoTB.tileBrush`]:$createFileID(),
        [`${projFolder}/autoBrTB.tileBrush`]:$createFileID(),
        [`${projFolder}/autoBrAB.autoBrush`]:$createFileID(),
        [`${projFolder}/isometric.palette`]:$createFileID(),
        [`${projFolder}/grid.palette`]:$createFileID(),
    };

    FILES = [
        ...FILES,
        {state:HEADLESS_FILE_STATE.ready,               path:`${projFolder}/autoBr.jpg`,                data:autoBrImgData},//id:$createFileID(),
        {state:HEADLESS_FILE_STATE.ready,               path:`${projFolder}/iso.jpg`,                   data:isoImgData},

        {state:HEADLESS_FILE_STATE.ready,               path:`${projFolder}/isoTB.tileBrush`,           data:isoTileBrData}, //id:$createFileID(),
        {state:HEADLESS_FILE_STATE.ready,               path:`${projFolder}/autoBrTB.tileBrush`,        data:autoBrTileData},
        {state:HEADLESS_FILE_STATE.ready,               path:`${projFolder}/autoBrAB.autoBrush`,        data:autoBrushData},

        {state:HEADLESS_FILE_STATE.ready,               path:`${projFolder}/isometric.palette`,         data:isoPaletteData},
        {state:HEADLESS_FILE_STATE.ready,               path:`${projFolder}/grid.palette`,              data:gridPaletteData},
    ];
    await $projBegin(window.config.project, FILES);


    $setKeanuFileAssets(_getID(FILES,`${projFolder}/isometric.palette`));
    $setKeanuFileAssets(_getID(FILES,`${projFolder}/autoBr.jpg`),`${projFolder}/autoBr.jpg`,`${projFolder}/autoBrTB.tileBrush|source`);
    $setKeanuFileAssets(_getID(FILES,`${projFolder}/autoBrTB.tileBrush`),`${projFolder}/autoBrTB.tileBrush`,`${projFolder}/autoBrAB.autoBrush|source`);
    $setKeanuFileAssets(_getID(FILES,`${projFolder}/autoBrAB.autoBrush`));
    $setKeanuFileAssets(_getID(FILES,`${projFolder}/iso.jpg`),`${projFolder}/iso.jpg`,`${projFolder}/isoTB.tileBrush|source`);
    $setKeanuFileAssets(_getID(FILES,`${projFolder}/isoTB.tileBrush`));
    $setKeanuFileAssets(_getID(FILES,`${projFolder}/grid.palette`));


    $updateKeanuFileAssets();
    await Event$1.Instance.emit(common$1.setting.EVT_TYPES.onProcess, [`${projFolder}/isoTB.tileBrush`]);
    await Event$1.Instance.emit(common$1.setting.EVT_TYPES.onProcess, [`${projFolder}/autoBrTB.tileBrush`]);



    let entry = projNameFolder;
    const child = new OutlineEntry({
        color: editorSetting.setting.OUTLINE.entryColor,
        file: 'test0',
        mode: OutlineEntry.MODE.folder,
        width: outline.clientWidth
    });
    await outline.Content.appendChild(child);
    await child.initialize();
    OutlineEntry.linkHierachy(entry, child, checkName);



    for (let i = 0; i < window.config.test ?? 0; i++) {
        const child = new OutlineEntry({
            color: editorSetting.setting.OUTLINE.entryColor,
            file: 'test' + i,
            mode: OutlineEntry.MODE.folder,
            width: outline.clientWidth
        });
        await outline.Content.appendChild(child);
        await child.initialize();
        OutlineEntry.linkHierachy(entry, child, checkName);
        entry = child;
    }
};

const checkName = (parent, curNode) => {
    const newFile = $getValidName(parent, curNode.EntryFileName, $OUTLINE_RENAME_CHECKER);
    curNode.EntryFileName = newFile;
};

const _getID = (FILES,fullPath)=> FILES.find(({id,path})=> path === fullPath).id;
const genExampleProj =  async ()=> {
    if(data.history?.length)
        $batchEmit(data.history);
    else {
        await $projBegin(window.config.project,data.files);
        debugger;
        const outline =  Keanu.editors.array.find(ele=>ele.constructor.name === 'Outline'),
            palette = Keanu.editors.array.find(ele=>ele.constructor.name === 'Palette');
        debugger;
        if(outline){
            await GUI$1.$REFRESH_LOCK_BEGIN(outline);
            await initOutline(outline,data.files);
            await GUI$1.$REFRESH_LOCK_END(outline);
        }else if(palette){
            const paletteFiles = getFiles().map(ele=>ele.path).filter(ele=>/\.palette/.test(ele)),
                file = paletteFiles.find(ele=>$readPath(ele).fileNm === window.config.palette);
            debugger;
            if(file)
                palette.open($path2ID(file));

        }

        $loadProcess();
    }


};


const getTestProj = async (outline)=> {
    if (window.config['vr'])
        testVR();




    $assert(window.config['owner']);

    const root = new OutlineEntry({
        color: editorSetting.setting.OUTLINE.entryColor,
        file: window.config['owner'],
        mode: OutlineEntry.MODE.folder,
        width: outline.clientWidth
    });
    await outline.Content.appendChild(root);
    await root.initialize();
    OutlineEntry.linkHierachy(outline.Content, root, checkName);

    const projNameFolder = new OutlineEntry({
        color: editorSetting.setting.OUTLINE.entryColor,
        file: `${window.config['projName']}`,
        mode: OutlineEntry.MODE.folder,
        width: outline.clientWidth
    });
    await outline.Content.appendChild(projNameFolder);
    await projNameFolder.initialize();
    OutlineEntry.linkHierachy(root, projNameFolder, checkName);


    $assert(window.config['projName']);

    const projFile = new OutlineEntry({
        color: editorSetting.setting.OUTLINE.entryColor,
        file: `${window.config['projName']}.keanu`,
        mode: OutlineEntry.MODE.file,
        width: outline.clientWidth
    });


    await outline.Content.appendChild(projFile);
    await projFile.initialize();
    OutlineEntry.linkHierachy(projNameFolder, projFile, checkName);


    const projData = getDataTemplate(FILE_TYPES.projSetting);
    const {projPath,projFolder} = window.config;
    const    FILES=[
        {state:HEADLESS_FILE_STATE.ready,id:'{root}',   path:projPath,                                  data:projData}
    ];


    if(!config.record && !config.replay)
        await genTestFiles(outline,projNameFolder,FILES,projData);
    else {

        $projEnd(window.config.project);

        await $projBegin(window.config.project, FILES);
        // $setKeanuFileAssets(_getID(projPath),projPath);
    }




    await outline.beforeRefresh();
    outline.refresh();
 };

let aftermain = async _=>{


    if (window.config['record'])
        await INIT_RECORDER(aws);
    if (window.config['replay'])
        await INIT_REPLAY(aws,window.config['replay']);

    return Promise.resolve();
};
let main = async function () {
    window.GLFramework = new GLFramework();
    const windowNames = ['outline','resource','brush','history','palette','inspector'];
    window.config = $parseURL(window.location.href).params;
    if (!window.config['project'])
        console.error('&project= params is missing');

    window.config['project'] = window.config['project']??'jimmy-game';
    window.config['outline'] = window.config['outline'];
    window.config['palette'] = window.config['palette']??'unnamed';
    window.config['hint'] = true;


    window.genQRCode = function(canvas){
        const content = {project:config.project, canvas};
        const qrcode = new QRCode({
            content:JSON.stringify(content),
            padding: 4,
            width: 256,
            height: 256,
            color: "#000000",
            background: "#ffffff",
            ecl: "M",
        });
        return qrcode.toImg();
    };

    try {
        const VERSION = 'May03: ["AutoBr optimized", "Event.Instance.save()", "listAllFiles()"]';
        //document.body.appendChild(document.createTextNode(VERSION))



        window.Keanu = {loadedItems:{},editors: createObjList(), common: common$1, helper, code: __src, interfaces: interfaces};


        window.save =save;
        window.testXiaoGANGAN = _=>{


            setInterval(_=>push2CurrentStack(null,{type:"paint",
                params:["jimmy/game/ppp.palette","jimmy/game/ppp.palette",[[0,7+Math.round(Math.random()*15)]],[[0,0]]],
                timestamp:Math.round(Date.now()/1000)
            },window.config['project'],window.config['usrName'],window.config['deviceID']), 100);
        };


        document.body.style['background-color'] = editorSetting.setting.BACKGROUND;

        await window.checkingSrcInterfaces();



        const base = new Base('sharedBase');
        Keanu.editors['sharedBase'] = base;
        base.Controller = Controller.sharedController;
        base.appendChild(Controller.sharedController);
        base.initialize();


        let winCounts = 0;

        for(const key in window.config)
            if(windowNames.includes(key))
                winCounts++;

        initLocalStorage(config);
        const user = readLocalStorage('user')??{profile:{username: window.config['usrName']}},
            usrName = user['profile']?.username??'undefined',
            projInfo = readLocalStorage('projInfo') ?? encodeURIComponent(JSON.stringify({
                contributors: [
                    {
                        username: "jimmyChopin",
                        // headImgURL: "https://keanu-1302931958.cos.ap-beijing.myqcloud.com/keanuStatic/tester.jpg",
                    },
                    {
                        username: "moviezhou",
                        // headImgURL: "https://keanu-1302931958.cos.ap-beijing.myqcloud.com/keanuStatic/tester.jpg",
                    },
                ]
            }));


        const [owner, projName] = window.config['project'].split('-');

        $assert(owner && projName);
        window.config['owner'] = owner;
        window.config['usrName'] = usrName;
        window.config['projName'] = projName;
        window.config['projFolder'] = `${owner}/${projName}`;///${projName}.keanu
        window.config['projPath'] = `${owner}/${projName}/${projName}.keanu`;///
        window.config['contributors'] = JSON.parse(decodeURIComponent(projInfo)).contributors;





        await LoadManager.init();
        await LoadManager.execute();


        window.Base = Base;
        let inspector, propertyWindow, outline, resource, layerEditor, sceneEditor, palette, graphEditor, helperNote;



        let menu = new Menu();
        menu.initialize();
        document.body.appendChild(menu);



        registEvt();
        $traditionEvt4Focus();


        window.root = document.getElementById('root');
        $infinityDesktop(root);
        createMenu();
        window.Menu.btns['menu/inputStatus/mouse'].Status = true;


        let winPOSx = 0, clientY = 0,
            cssWidth = document.body.clientWidth/winCounts,//devicePixelRatio*
            cssHeight = 600;// document.body.clientHeight;//devicePixelRatio*


        if (window.config['3d'])
            return test3D();

        if(window.config['vr'])
            cssWidth = cssHeight = 1024;


        if (window.config.outline) {
            await common$1.cmd.ui.createWindow(
                root,
                Outline,
                'Outline',
                {
                    position: [winPOSx, clientY, 0],
                    titleHeight: editorSetting.setting.WINDOW.titleHeight,
                    titleColor: editorSetting.setting.WINDOW.titleColor,
                    strokeColor: editorSetting.setting.WINDOW.outlineStrokeColor,
                    lineWidth: editorSetting.setting.WINDOW.outlineStrokeWidth,
                    style: {width: `${300}px`, height: `${cssHeight}px`}
                }, getTestProj);

            winPOSx += 300;
        }else {
            registEvt$1();
            genExampleProj();
        }

        if (window.config.history) {
            await common$1.cmd.ui.createWindow(
                root,
                History,
                'History',
                {
                    position: [winPOSx, clientY, 0],
                    titleHeight: editorSetting.setting.WINDOW.titleHeight,
                    titleColor: editorSetting.setting.WINDOW.titleColor,
                    strokeColor: editorSetting.setting.WINDOW.outlineStrokeColor,
                    lineWidth: editorSetting.setting.WINDOW.outlineStrokeWidth,
                    style: {width: `${400}px`, height: `${600}px`}
                });
            winPOSx += 400;
        }






        if (window.config.resource) {
            window.config.stack = true;
            await common$1.cmd.ui.createWindow(
                root,
                Resource,
                'Resource',
                {
                    position: [winPOSx, clientY, 0],
                    titleHeight: editorSetting.setting.WINDOW.titleHeight,
                    titleColor: editorSetting.setting.WINDOW.titleColor,
                    strokeColor: editorSetting.setting.WINDOW.outlineStrokeColor,
                    lineWidth: editorSetting.setting.WINDOW.outlineStrokeWidth,
                    style: {width: `${cssWidth}px`, height: `${cssHeight}px`}
                }, async (resource, evt, editorName) => {


                    await Event$1.Instance.emit( common$1.setting.EVT_TYPES.onConnect, [
                        window.config['projName'], aws
                    ], {timestamp: evt.options.timestamp});

                }
            );

            winPOSx += cssWidth;
        }



        const testInspector = async inspector=> {
            //TEST
            Layout.beginInit(inspector.Content);


            await draggableLayoutTest();
            // // inspector.autoTileLayoutTest();
            // // inspector.sliceLabelTest();
            //
            //  inspector.anchorTest();


            //{'path': `/${window.config['owner']}/${window.config['projName']}/test.json`},
            // inspector.initData(testData['.path'], [
            //     {
            //         '.path':'as',
            //         'test': 'asdfasdfasdfasdfasdfasdf',
            //         'test2': 'wqwerqwerqwerqwerqwerqwerqwer',
            //     }
            // ]);

            Layout.endInit();
        }, anchorTest = async _ => {
            await FoldableLayout.begin('usr1', {layoutMode: Layout.LAYOUT_MODE.vertical | Layout.LAYOUT_MODE.resizeX});

            // GUI.TextBox('testX_IB', {mode: 8});
            // GUI.TextBox('testX_IB1', {mode: 8}); //TextBox.MODE.freeze = 8

            await GUI$1.Label('asdfasdfasdf', {mode:2, width:120, height:60});

            FoldableLayout.end();
        },draggableLayoutTest = async _ => {

            const mode = Layout.LAYOUT_MODE.vertical | Layout.LAYOUT_MODE.resizeX | Layout.LAYOUT_MODE.expandY;

            await DraggableLayout.begin('draggable', {layoutMode: mode});


            await Layout.begin('drag1', {layoutMode: mode, color: 'red'});

            await  GUI$1.TextBox('myBtn1');

            Layout.end();


            await Layout.begin('drag2', {layoutMode: mode, color: 'red'});

            await GUI$1.TextBox('myBtn2');

            Layout.end();


            await Layout.begin('drag3', {layoutMode: mode, color: 'red'});

            await GUI$1.TextBox('myBtn3');

            Layout.end();

            DraggableLayout.end();
        },autoTileLayoutTest = _ => {
            AutoTileLayout.begin('autoTile');


            AutoTileLayout.end();
        },sliceLabelTest = async _ => {

            await  GUI$1.TextBox('unnamed', {
                width: 90,
                mode: TextBox.MODE.omit | TextBox.MODE.editing,
                color: 'pink',
                fontParams: {
                    bold: false,
                    font: 'Arial',
                    size: 16,
                    color: 'black'
                }
            });

        };

        if (window.config.inspector) {
            await common$1.cmd.ui.createWindow(
                root,
                Inspector,
                'Inspector',
                {
                    position: [winPOSx, clientY, 0],
                    titleHeight: editorSetting.setting.WINDOW.titleHeight,
                    titleColor: editorSetting.setting.WINDOW.titleColor,
                    strokeColor: editorSetting.setting.WINDOW.outlineStrokeColor,
                    lineWidth: editorSetting.setting.WINDOW.outlineStrokeWidth,
                    style: {width: `${cssWidth*0.6}px`, height: `${cssHeight}px`}
                }, testInspector);

            winPOSx += cssWidth*0.6;



        }


        if (window.config.brush) {

              await  common$1.cmd.ui.createWindow(
                    root,
                    Brush,
                    'Brush',
                    {
                        position: [winPOSx, clientY, 0],
                        titleHeight: editorSetting.setting.WINDOW.titleHeight,
                        titleColor: editorSetting.setting.WINDOW.titleColor,
                        strokeColor: editorSetting.setting.WINDOW.outlineStrokeColor,
                        lineWidth: editorSetting.setting.WINDOW.outlineStrokeWidth,
                        style: {width: `${cssHeight}px`, height: '650px'}
                    }
                );
            winPOSx += cssWidth;
        }

        if (window.config.palette) {

              await  common$1.cmd.ui.createWindow(
                    root,
                    Palette,
                    'Palette',
                    {
                        position: [winPOSx, clientY, 0],
                        titleHeight: editorSetting.setting.WINDOW.titleHeight,
                        titleColor: editorSetting.setting.WINDOW.titleColor,
                        strokeColor: editorSetting.setting.WINDOW.outlineStrokeColor,
                        lineWidth: editorSetting.setting.WINDOW.outlineStrokeWidth,
                        style: {width: `${cssHeight*16/9-300}px`, height: `${cssHeight}px`}
                    }
                );
            winPOSx += cssWidth;
        }

        const testMenu = {
            OutlineEntry:{
                pathRegExp:/(Outline|Resource)\/controller\/mainLayout\/body\/scrollable\/bodyLayoutH\/scrollable-content-layout\/group/,
                menus:[
                    {cmd: '#import', writeHistory: false},
                    {cmd: '#create', children: [
                            {cmd: '#palette'},
                            {cmd: '#brush', children: [
                                    {cmd: '#autoBrush'},
                                    {cmd: '#tileBrush'}
                                ]},
                            {cmd: '#object'},
                            {cmd: '#camera'},
                            {cmd: '#scene'},
                            {cmd: '#folder'},
                        ],
                    },
                    {cmd: '#delete'},
                ]
            },
            InspectorSlice:{
                pathRegExp:/Inspector\/controller\/mainLayout\/body\/scrollable\/bodyLayoutH\/scrollable-content-layout\/group\/tileBrush:\/slices/,
                menus:[
                    {cmd: '#delete'},
                ]
            }
        };
        if (window.config.outline) menu.regist(testMenu);
        if (window.config.resource) menu.regist(testMenu);


        Controller.addEventListener("menu", evt =>{
            try{
                const info = menu.getTarget(evt);
                if(info == null) return;

                const {target, menuSetting} = info;

                if(!menuSetting) return;

                // setTimeout(_=> menu.active(evt.target, menuSetting,[evt.clientX,evt.clientY],Controller),10)
                menu.active(target, menuSetting,[evt.clientX,evt.clientY],Controller);
            }catch (e){debugger;}
        });



        if (window.config.hint){
            const root = document.getElementById('root');
            for(const panel of root.children){
                const tools = $findByFullName(`${panel.FullName}/controller/mainLayout/body/toolBoxLayout`);

                if(!tools.Children.array.length) continue;

                for(const tool of tools.Children.array){
                    const hint = document.createElement( 'div' );
                    hint.id = `${panel.name}_${tool.name}`;
                    hint.style['display'] = 'block';
                    hint.style['position'] = 'absolute';
                    hint.style['background-color'] = 'transparent';
                    hint.style['width'] = `${tool.boundary[2]}px`;
                    hint.style['height'] = `${tool.boundary[3]}px`;
                    hint.style['left'] = `${tool.transform.globalMatrix[4]}px`;
                    hint.style['top'] = `${tool.transform.globalMatrix[5]}px`;
                    hint.style['visibility'] = 'hidden';
                    panel.insertBefore( hint, panel.CanvasDiv);

                }
            }
        }

        const evt = new CustomEvent("engineLoaded", {
            detail: {
                action: "didInitialize",
                payload: 3
            }
        });

        window.dispatchEvent(evt);


    }catch (e) {
        debugger;
        document.body.appendChild(document.createTextNode(e.toString()));
    }
};
window.addEventListener('DOMContentLoaded', _=>main().then(aftermain));//
